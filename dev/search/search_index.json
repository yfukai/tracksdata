{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"TracksData","text":"<p>A common data structure and basic tools for multi-object tracking.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Graph-based representation of tracking problems</li> <li>In-memory (RustWorkX) and database-backed (SQL) graph backends</li> <li>Nodes and edges can take arbitrary attributes</li> <li>Standardize API for node operators (e.g. defining objects and their attributes)</li> <li>Standardize API for edge operators (e.g. creating edges between nodes)</li> <li>Basic tracking solvers: nearest neighbors and integer linear programming</li> <li>Compatible with Cell Tracking Challenge (CTC) format</li> <li>Efficient subgraphing based on attributes on any graph backend</li> <li>Integration with cell tracking evaluation metrics</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install tracksdata\n</code></pre>"},{"location":"#why-tracksdata","title":"Why tracksdata?","text":"<p>TracksData provides a common data structure for multi-object tracking problems. It uses graphs to represent detections (nodes) and their connections (edges), making it easier to work with tracking data across different algorithms.</p> <p>Key benefits: - Consistent data representation for tracking problems - Modular components that can be combined as needed - Support for both small datasets (in-memory) and large datasets (database)</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Full Documentation</li> <li>Installation</li> <li>Core Concepts</li> <li>Getting Started</li> <li>API Reference</li> <li>FAQ</li> </ul>"},{"location":"concepts/","title":"Core Concepts","text":""},{"location":"concepts/#graph-based-tracking","title":"Graph-Based Tracking","text":"<p>TracksData represents tracking data as a directed graph where:</p> <ul> <li>Nodes are detections/objects at specific time points</li> <li>Edges connect objects across consecutive time frames forward in time (t to t + delta_t)</li> <li>Tracks are paths through the graph representing object trajectories</li> </ul>"},{"location":"concepts/#graph-backends","title":"Graph Backends","text":"<p>TracksData supports multiple graph backends for different use cases:</p>"},{"location":"concepts/#rustworkxgraph","title":"RustWorkXGraph","text":"<ul> <li>Use case: In-memory graphs that fit in RAM</li> <li>Performance: Excellent for algorithms and analysis</li> <li>Recommended: For most tracking applications</li> </ul>"},{"location":"concepts/#sqlgraph","title":"SQLGraph","text":"<ul> <li>Use case: Large datasets that don't fit in memory</li> <li>Performance: Good for storage and querying</li> <li>Features: Persistent storage, complex queries</li> </ul>"},{"location":"concepts/#graphview","title":"GraphView","text":"<ul> <li>Use case: Results subgraph either backends</li> <li>Performance: Low overhead, similar to RustWorkXGraph</li> <li>Features: Maintains connection to root graph, all operations are mirrored to the root graph</li> </ul>"},{"location":"concepts/#graph-operators","title":"Graph Operators","text":"<p>Graph operators are used to manipulate the graph:</p> <ul> <li>Node operators: Create or add attributes to nodes</li> <li>Edge operators: Create or add attributes to edges</li> <li>Solver operators: Solve the tracking problem</li> </ul>"},{"location":"concepts/#attribute-system","title":"Attribute System","text":"<p>TracksData uses a flexible attribute system:</p>"},{"location":"concepts/#node-attributes","title":"Node Attributes","text":"<ul> <li>Store object properties (coordinates, features, measurements)</li> <li>Support various data types (floats, arrays, segmentation masks)</li> </ul>"},{"location":"concepts/#edge-attributes","title":"Edge Attributes","text":"<ul> <li>Store connection properties (distances, costs, confidences)</li> <li>Used by solvers for optimization</li> </ul>"},{"location":"concepts/#attribute-expressions","title":"Attribute Expressions","text":"<p>Attributes are used to filter nodes or edges, or to formulate the objective function for solvers.</p> <pre><code>import tracksdata as td\n\n# Simple attribute access\nx_coords = td.NodeAttr(\"x\")\n\n# Mathematical expressions\ndistance_cost = td.EdgeAttr(\"distance\") + 0.1 * td.EdgeAttr(\"angle_change\")\n\n# Comparison operations for filtering\nrecent_nodes = td.NodeAttr(\"t\") &gt;= 10\nlarge_objects = td.NodeAttr(\"area\") &gt; 100\n</code></pre>"},{"location":"concepts/#data-flow","title":"Data Flow","text":"<p>A typical TracksData workflow:</p> <ol> <li>Create Graph: Choose appropriate backend</li> <li>Add Nodes: Use node operators to populate detections</li> <li>Add Edges: Use edge operators to create potential connections</li> <li>Solve: Apply solver to find optimal tracks</li> <li>Analyze: Query and filter results for downstream analysis</li> </ol> <p>This modular design allows mixing and matching components for different tracking scenarios.</p>"},{"location":"contributing/","title":"Contributing to Documentation","text":""},{"location":"contributing/#documentation-versioning","title":"Documentation Versioning","text":"<p>This project uses mike for documentation versioning. Documentation is automatically built and deployed via GitHub Actions.</p>"},{"location":"contributing/#automatic-deployment","title":"Automatic Deployment","text":"<ul> <li>Development docs: Built on every push to <code>main</code> branch \u2192 available at <code>/dev/</code></li> <li>Release docs: Built on every tag push (<code>v*</code>) \u2192 available at <code>/latest/</code> and <code>/v{version}/</code></li> </ul>"},{"location":"contributing/#manual-version-management","title":"Manual Version Management","text":"<p>If you need to manually manage documentation versions:</p> <pre><code># Install dependencies\nuv sync --extra docs\n\n# Deploy a new version\nuv run mike deploy --push --update-aliases v1.0.0 latest\n\n# Set default version\nuv run mike set-default --push latest\n\n# List all versions\nuv run mike list\n\n# Delete a version\nuv run mike delete --push v0.9.0\n</code></pre>"},{"location":"contributing/#local-development","title":"Local Development","text":"<p>To build and serve documentation locally:</p> <pre><code># Serve with live reload\nuv run mkdocs serve\n\n# Build static site\nuv run mkdocs build\n</code></pre>"},{"location":"contributing/#version-structure","title":"Version Structure","text":"<ul> <li><code>latest</code> - Latest stable release</li> <li><code>dev</code> - Development version from main branch</li> <li><code>v{X.Y.Z}</code> - Specific version tags</li> </ul> <p>The documentation will be available at: - https://royerlab.github.io/tracksdata/ (latest) - https://royerlab.github.io/tracksdata/dev/ (development) - https://royerlab.github.io/tracksdata/v1.0.0/ (specific version)</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples of using TracksData for multi-object tracking tasks.</p>"},{"location":"examples/#basic-tracking-example","title":"Basic Tracking Example","text":"<p>Here's a complete basic example that demonstrates the core workflow of TracksData. This example is available as an executable Python file at <code>docs/examples/basic.py</code>.</p> <pre><code>\"\"\"\nBasic multi-object tracking example using TracksData.\n\nThis example demonstrates the complete workflow for tracking objects across time:\n1. Load segmented image data\n2. Extract object features (nodes) from each frame\n3. Create temporal connections (edges) between objects\n4. Compute additional attributes to edges (e.g. IoU)\n5. Solve the tracking optimization problem\n6. Convert results to napari format\n7. Visualize results\n\n\nRequirements:\n- Set CTC_DIR environment variable pointing to Cell Tracking Challenge data\n- Example assumes Fluo-N2DL-HeLa dataset structure\n\nUsage:\n    python basic.py                    # Run with napari visualization\n    python basic.py --profile          # Run with performance profiling\n\"\"\"\n\nimport os\nfrom pathlib import Path\n\nimport click\nimport napari\nimport numpy as np\nfrom profilehooks import profile as profile_hook\nfrom tifffile import imread\n\nimport tracksdata as td\n\n\ndef basic_tracking_example(show_napari_viewer: bool = True) -&gt; None:\n    \"\"\"\n    Perform basic multi-object tracking on segmented microscopy data.\n\n    This function demonstrates the core TracksData workflow:\n    - Node extraction from regionprops\n    - Distance-based edge creation\n    - IoU attribute computation\n    - Nearest neighbors tracking solution\n\n    Parameters\n    ----------\n    show_napari_viewer : bool\n        Whether to display results in napari viewer\n    \"\"\"\n    # Step 1: Load and prepare data\n\n    # Load example data from Cell Tracking Challenge format\n    data_dir = Path(os.environ[\"CTC_DIR\"]) / \"training/Fluo-N2DL-HeLa/01_GT/TRA\"\n    assert data_dir.exists(), f\"Data directory {data_dir} does not exist.\"\n\n    # Load all timepoints as a 3D array: (time, height, width)\n    labels = np.stack(\n        [imread(p) for p in sorted(data_dir.glob(\"*.tif\"))],\n    )\n\n    # Configure TracksData options (disable progress bars for cleaner output)\n    td.options.set_options(show_progress=False)\n\n    print(\"Starting tracking workflow...\")\n\n    # Step 2: Initialize graph and extract nodes\n    graph = td.graph.InMemoryGraph()\n\n    # Extract object features using region properties\n    # This creates one node per object per timeframe\n    nodes_operator = td.nodes.RegionPropsNodes()\n    nodes_operator.add_nodes(graph, labels=labels)\n    print(f\"\u2713 Extracted {graph.num_nodes} nodes from {labels.shape[0]} timeframes\")\n\n    # Step 3: Create temporal edges between consecutive frames\n\n    # Add distance-based edges between objects in consecutive timeframes\n    # Only connects objects within distance_threshold and limits to n_neighbors\n    dist_operator = td.edges.DistanceEdges(\n        distance_threshold=30.0,\n        n_neighbors=5,\n    )\n    dist_operator.add_edges(graph)\n    print(f\"\u2713 Created {graph.num_edges} potential temporal connections\")\n\n    # Step 4: Add IoU (Intersection over Union) attributes to edges\n\n    # Compute IoU between connected objects to measure shape similarity\n    # Higher IoU values indicate better matches for tracking\n    iou_operator = td.edges.IoUEdgeAttr(output_key=\"iou\")\n    iou_operator.add_edge_attrs(graph)\n    print(\"\u2713 Computed IoU attributes for edge weights\")\n\n    # Step 5: Solve tracking optimization problem\n\n    # Create edge weights combining distance and IoU information\n    # Lower distance + higher IoU = better connection (lower cost)\n    dist_weight = 1 / dist_operator.distance_threshold\n\n    # Use nearest neighbors solver for fast, greedy tracking\n    # Each edge weight is defined as:\n    # - IoU(e_ij) * exp(-distance(e_ij) / dist_threshold)\n    # Where e_ij is the edge between nodes i and j.\n    # Alternative: ILPSolver for globally optimal but slower solutions\n    solver = td.solvers.NearestNeighborsSolver(\n        edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"distance\") * dist_weight).exp(),\n        max_children=2,  # Allow cell divisions (max 2 children per parent)\n    )\n\n    # Alternative ILP solver (uncomment for optimal tracking):\n    # solver = td.solvers.ILPSolver(\n    #     edge_weight=-td.EdgeAttr(\"iou\") * (td.EdgeAttr(\"weight\") * dist_weight).exp(),\n    #     node_weight=0.0,           # Cost for keeping an object\n    #     appearance_weight=1.0,    # Cost for object appearing\n    #     disappearance_weight=1.0, # Cost for object disappearing\n    #     division_weight=1.0,       # Cost for cell division\n    # )\n\n    solver.solve(graph)\n    print(\"\u2713 Solved tracking assignments\")\n\n    # Step 6: Convert results for visualization\n\n    # Convert tracking graph to napari-compatible format\n    # Returns: tracked labels, tracks dataframe, and track graph\n    print(\"Converting results to napari format...\")\n    tracks_df, track_graph, track_labels = td.functional.to_napari_format(graph, labels.shape, mask_key=\"mask\")\n\n    print(f\"\u2713 Generated {len(tracks_df)} track points across {len(set(tracks_df['tracklet_id']))} tracks\")\n\n    # Step 7: Visualize results (optional)\n\n    if show_napari_viewer:\n        print(\"Opening napari viewer...\")\n        viewer = napari.Viewer()\n\n        # Add original segmented labels\n        viewer.add_labels(track_labels, name=\"Tracked Labels\")\n\n        # Add tracking trajectories with lineage information\n        viewer.add_tracks(tracks_df, graph=track_graph, name=\"Tracks\")\n\n        # Start interactive viewer\n        napari.run()\n\n\n@click.command()\n@click.option(\"--profile\", is_flag=True, help=\"Enable performance profiling (disables napari viewer)\")\ndef main(profile: bool) -&gt; None:\n    \"\"\"Run the basic tracking example with optional profiling.\"\"\"\n    if profile:\n        # Run with performance profiling, no visualization\n        profile_hook(basic_tracking_example, immediate=True, sort=\"time\")(show_napari_viewer=False)\n    else:\n        # Normal run with visualization\n        basic_tracking_example(show_napari_viewer=True)\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#key-components-explained","title":"Key Components Explained","text":"<ul> <li>Graph: The core data structure holding nodes (objects) and edges (connections)</li> <li>Nodes Operators: Extract object features from segmented images (RegionPropsNodes, MaskNodes, etc.)</li> <li>Edges Operators: Create temporal connections between objects (DistanceEdges, IoUEdges, etc.)</li> <li>Solvers: Optimize a minimization problem to find the best tracking assignments (NearestNeighborsSolver, ILPSolver)</li> <li>Functional: Utilities for format conversion and visualization</li> </ul>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Check the Getting Started guide for more detailed explanations</li> <li>Explore the Concepts page to understand the architecture</li> <li>See the API reference for complete documentation of all components</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-tracksdata","title":"What is TracksData?","text":"<p>TracksData is a Python library that provides a common data structure and tools for multi-object tracking. It uses a graph-based representation where objects are nodes and tracks are edges connecting objects across time.</p>"},{"location":"faq/#when-should-i-use-tracksdata","title":"When should I use TracksData?","text":"<p>TracksData is ideal for:</p> <ul> <li>Multi-object tracking in microscopy or computer vision</li> <li>Biological cell tracking and lineage analysis</li> <li>Particle tracking in physics simulations</li> <li>Any scenario requiring temporal object associations</li> </ul>"},{"location":"faq/#how-does-tracksdata-differ-from-other-tracking-libraries","title":"How does TracksData differ from other tracking libraries?","text":"<p>TracksData focuses on providing a general unified data structure and modular components that can be combined for different tracking scenarios and scale to large datasets (e.g. millions of nodes in terabytes of 3D + time imaging data).</p>"},{"location":"faq/#which-graph-backend-should-i-use","title":"Which graph backend should I use?","text":"<ul> <li>RustWorkXGraph: For most applications where data fits in memory</li> <li>SQLGraph: For large datasets or when you need persistent storage</li> <li>GraphView: You shouldn't instantiate this directly, it is used internally by the library when you use <code>graph.subgraph()</code></li> </ul>"},{"location":"faq/#can-tracksdata-handle-cell-divisions","title":"Can TracksData handle cell divisions?","text":"<p>Yes! The :class:<code>tracksdata.solvers.NearestNeighborsSolver</code> lets you defined the maximum number of children nodes and :class:<code>tracksdata.solvers.ILPSolver</code> specifically supports division events with configurable division costs.</p>"},{"location":"faq/#how-do-i-add-custom-attributes","title":"How do I add custom attributes?","text":"<pre><code># Add new attribute keys to the graph\ngraph.add_node_attr_key(\"my_feature\", 0.0)\ngraph.add_edge_attr_key(\"confidence\", 1.0)\n\n# Use them when adding nodes/edges\ngraph.add_node({\"t\": 0, \"x\": 10, \"my_feature\": 42.0})\ngraph.add_edge(source_id, target_id, {\"confidence\": 0.95})\n</code></pre>"},{"location":"faq/#how-do-i-create-custom-operators","title":"How do I create custom operators?","text":"<p>Inherit from :class:<code>tracksdata.edges.BaseEdgesOperator</code> or :class:<code>tracksdata.nodes.BaseNodesOperator</code> and implement <code>_add_edges_per_time</code> or <code>_add_nodes_per_time</code>:</p> <pre><code>import tracksdata as td\n\nclass CustomNodes(td.nodes.BaseNodesOperator):\n    def add_nodes(\n        self,\n        graph: td.graph.BaseGraph,\n        *,\n        t: int | None = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        # Your custom logic here to add nodes to the graph\n        pass\n</code></pre>"},{"location":"faq/#how-do-i-visualize-results","title":"How do I visualize results?","text":"<p>TracksData provides utilities for converting to napari format:</p> <pre><code>import tracksdata as td\n\nlabels = ...\n\ntracks_df, track_graph, track_labels = td.functional.to_napari_format(\n    solution_graph, shape=labels.shape, mask_key=\"mask\",\n)\n\nviewer = napari.Viewer()\nviewer.add_labels(track_labels)\nviewer.add_tracks(tracks_df, graph=track_graph)\nnapari.run()\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#basic-concepts","title":"Basic Concepts","text":"<p>TracksData is built around a graph-based representation of multi-object tracking data:</p> <ul> <li>Nodes represent objects at specific time points (detections)</li> <li>Edges represent connections between objects across time (connections)</li> <li>Attributes store additional data like coordinates, features, or costs</li> </ul>"},{"location":"getting_started/#quick-example","title":"Quick Example","text":"<p>Here's a simple example of creating a graph and adding tracking data:</p> <pre><code>import numpy as np\nimport tracksdata as td\n\n# Create a graph\ngraph = td.graph.InMemoryGraph()\n\n# Generate random nodes for testing\nnode_generator = td.nodes.RandomNodes(\n    n_time_points=5,\n    n_nodes_per_tp=(10, 15),\n    n_dim=2\n)\nnode_generator.add_nodes(graph)\n\n# Connect nearby nodes across time\nedge_generator = td.edges.DistanceEdges(\n    distance_threshold=0.3,\n    n_neighbors=3\n)\nedge_generator.add_edges(graph)\n\n# Solve the tracking problem\nsolver = td.solvers.NearestNeighborsSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n\nprint(f\"Original graph has {graph.num_nodes} nodes and {graph.num_edges} edges\")\nprint(f\"Solution has {solution.num_nodes} nodes and {solution.num_edges} edges\")\n</code></pre>"},{"location":"getting_started/#working-with-real-data","title":"Working with Real Data","text":"<p>For real tracking applications, you'll typically:</p> <ol> <li>Create nodes from detections using <code>RegionPropsNodes</code> for segmented images</li> <li>Add edges using <code>DistanceEdges</code> or custom edge operators</li> <li>Solve tracking using <code>ILPSolver</code> for optimal results or <code>NearestNeighborsSolver</code> for speed</li> <li>Analyze results using the graph's filtering and querying capabilities</li> </ol> <pre><code>import tracksdata as td\n\n# Extract nodes from labeled images\nnode_op = td.nodes.RegionPropsNodes(extra_properties=[\"area\", \"eccentricity\"])\nnode_op.add_nodes(graph, labels=labels)\n\n# Filter nodes by time\ngraph_filter = graph.filter(td.NodeAttr(\"t\") == 0)\nnode_data = graph_filter.node_attrs()\nprint(node_data)\n</code></pre>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>See the Concepts page for detailed explanations</li> <li>Check the FAQ for common questions</li> <li>Browse the API documentation for complete reference</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>TracksData requires Python 3.10 or later.</p>"},{"location":"installation/#install-tracksdata","title":"Install TracksData","text":""},{"location":"installation/#from-pypi","title":"From pypi","text":"<pre><code>pip install tracksdata\n</code></pre>"},{"location":"installation/#from-source-development","title":"From Source (Development)","text":"<p>To install the latest development version:</p> <pre><code>git clone https://github.com/royerlab/tracksdata.git\ncd tracksdata\npip install .\n</code></pre>"},{"location":"installation/#with-optional-dependencies","title":"With Optional Dependencies","text":"<p>For testing: <pre><code>pip install .[test]\n</code></pre></p> <p>For documentation: <pre><code>pip install .[docs]\n</code></pre></p>"},{"location":"installation/#verify-installation","title":"Verify Installation","text":"<p>You can verify the installation by importing the library:</p> <pre><code>import tracksdata as td\nprint(td.__version__)\n</code></pre>"},{"location":"reference/tracksdata/","title":"tracksdata","text":""},{"location":"reference/tracksdata/#tracksdata","title":"tracksdata","text":"<p>A common data structure and basic tools for multi-object tracking.</p> <p>Modules:</p> <ul> <li> <code>array</code>           \u2013            <p>Array representation of graphical data.</p> </li> <li> <code>attrs</code>           \u2013            <p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> </li> <li> <code>constants</code>           \u2013            <p>Module to define default and often global values used through <code>tracksdata</code>.</p> </li> <li> <code>edges</code>           \u2013            <p>Edge operators for creating connections between nodes of a graph.</p> </li> <li> <code>functional</code>           \u2013            <p>Functional utilities for graph operations.</p> </li> <li> <code>graph</code>           \u2013            <p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> </li> <li> <code>io</code>           \u2013            <p>Input/output utilities for loading and saving tracking data in various formats.</p> </li> <li> <code>metrics</code>           \u2013            <p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> </li> <li> <code>nodes</code>           \u2013            <p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> </li> <li> <code>options</code>           \u2013            <p>Global options system for TracksData.</p> </li> <li> <code>solvers</code>           \u2013            <p>Solvers for finding a valid tracking solution from a candidate graph.</p> </li> <li> <code>utils</code>           \u2013            <p>Utility functions for data processing, type conversions, and progress tracking.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <pre><code>\n              flowchart TD\n              tracksdata.EdgeAttr[EdgeAttr]\n              tracksdata.attrs.Attr[Attr]\n\n                              tracksdata.attrs.Attr --&gt; tracksdata.EdgeAttr\n                \n\n\n              click tracksdata.EdgeAttr href \"\" \"tracksdata.EdgeAttr\"\n              click tracksdata.attrs.Attr href \"\" \"tracksdata.attrs.Attr\"\n            </code></pre> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> <li> <code>is_in</code>             \u2013              <p>Create a membership comparison between the attribute and a collection of literals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(\n    other: ExprInput, op: Callable, reverse: bool = False\n) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(\n    other: ExprInput,\n    op: Callable[[Expr, Expr], Expr],\n    reverse: bool = False,\n) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.is_in","title":"is_in","text":"<pre><code>is_in(values: MembershipExprInput) -&gt; AttrComparison\n</code></pre> <p>Create a membership comparison between the attribute and a collection of literals.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>A comparison suitable for filtering across all graph backends.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def is_in(self, values: MembershipExprInput) -&gt; \"AttrComparison\":\n    \"\"\"\n    Create a membership comparison between the attribute and a collection of literals.\n\n    Parameters\n    ----------\n    values : Iterable[Scalar] | Sequence[Scalar] | np.ndarray | Series\n        Values the attribute should belong to.\n\n    Returns\n    -------\n    AttrComparison\n        A comparison suitable for filtering across all graph backends.\n    \"\"\"\n    return AttrComparison(self, _is_in_op, values)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.EdgeAttr.is_in(values)","title":"<code>values</code>","text":"(<code>Iterable[Scalar] | Sequence[Scalar] | ndarray | Series</code>)           \u2013            <p>Values the attribute should belong to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <pre><code>\n              flowchart TD\n              tracksdata.NodeAttr[NodeAttr]\n              tracksdata.attrs.Attr[Attr]\n\n                              tracksdata.attrs.Attr --&gt; tracksdata.NodeAttr\n                \n\n\n              click tracksdata.NodeAttr href \"\" \"tracksdata.NodeAttr\"\n              click tracksdata.attrs.Attr href \"\" \"tracksdata.attrs.Attr\"\n            </code></pre> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> <li> <code>is_in</code>             \u2013              <p>Create a membership comparison between the attribute and a collection of literals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(\n    other: ExprInput, op: Callable, reverse: bool = False\n) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(\n    other: ExprInput,\n    op: Callable[[Expr, Expr], Expr],\n    reverse: bool = False,\n) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.is_in","title":"is_in","text":"<pre><code>is_in(values: MembershipExprInput) -&gt; AttrComparison\n</code></pre> <p>Create a membership comparison between the attribute and a collection of literals.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>A comparison suitable for filtering across all graph backends.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def is_in(self, values: MembershipExprInput) -&gt; \"AttrComparison\":\n    \"\"\"\n    Create a membership comparison between the attribute and a collection of literals.\n\n    Parameters\n    ----------\n    values : Iterable[Scalar] | Sequence[Scalar] | np.ndarray | Series\n        Values the attribute should belong to.\n\n    Returns\n    -------\n    AttrComparison\n        A comparison suitable for filtering across all graph backends.\n    \"\"\"\n    return AttrComparison(self, _is_in_op, values)\n</code></pre>"},{"location":"reference/tracksdata/#tracksdata.NodeAttr.is_in(values)","title":"<code>values</code>","text":"(<code>Iterable[Scalar] | Sequence[Scalar] | ndarray | Series</code>)           \u2013            <p>Values the attribute should belong to.</p>"},{"location":"reference/tracksdata/array/","title":"array","text":""},{"location":"reference/tracksdata/array/#tracksdata.array","title":"tracksdata.array","text":"<p>Array representation of graphical data.</p> <p>Provides read-only array views of graph attributes, with lazy loading from original data sources.</p> <p>Classes:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>Class used to view the content of a graph as an array.</p> </li> </ul>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView","title":"GraphArrayView","text":"<pre><code>GraphArrayView(\n    graph: BaseGraph,\n    attr_key: str,\n    *,\n    offset: int | ndarray = 0,\n    shape: tuple[int, ...] | None = None,\n    chunk_shape: tuple[int, ...] | int | None = None,\n    buffer_cache_size: int | None = None,\n    dtype: dtype | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseReadOnlyArray</code></p> <pre><code>\n              flowchart TD\n              tracksdata.array.GraphArrayView[GraphArrayView]\n              tracksdata.array._base_array.BaseReadOnlyArray[BaseReadOnlyArray]\n\n                              tracksdata.array._base_array.BaseReadOnlyArray --&gt; tracksdata.array.GraphArrayView\n                \n\n\n              click tracksdata.array.GraphArrayView href \"\" \"tracksdata.array.GraphArrayView\"\n              click tracksdata.array._base_array.BaseReadOnlyArray href \"\" \"tracksdata.array._base_array.BaseReadOnlyArray\"\n            </code></pre> <p>Class used to view the content of a graph as an array.</p> <p>The resulting graph behaves as a read-only numpy array, displaying arbitrary attributes inside their respective instance mask.</p> <p>The content is lazy loaded from the original data source as it's done with a zarr.Array</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>__array__</code>             \u2013              <p>Convert the GraphArrayView to a numpy array.</p> </li> <li> <code>__getitem__</code>             \u2013              <p>Return a sliced view of the GraphArrayView.</p> </li> <li> <code>__len__</code>             \u2013              <p>Returns the length of the first dimension of the array.</p> </li> <li> <code>reindex</code>             \u2013              <p>Reindex the GraphArrayView.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dtype</code>               (<code>dtype</code>)           \u2013            <p>Returns the dtype of the array.</p> </li> <li> <code>ndim</code>               (<code>int</code>)           \u2013            <p>Returns the number of dimensions of the array.</p> </li> <li> <code>shape</code>               (<code>tuple[int, ...]</code>)           \u2013            <p>Returns the shape of the array.</p> </li> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Returns the total number of elements in the array.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __init__(\n    self,\n    graph: BaseGraph,\n    attr_key: str,\n    *,\n    offset: int | np.ndarray = 0,\n    shape: tuple[int, ...] | None = None,\n    chunk_shape: tuple[int, ...] | int | None = None,\n    buffer_cache_size: int | None = None,\n    dtype: np.dtype | None = None,\n):\n    if attr_key not in graph.node_attr_keys:\n        raise ValueError(f\"Attribute key '{attr_key}' not found in graph. Expected '{graph.node_attr_keys}'\")\n\n    self.graph = graph\n    self._attr_key = attr_key\n    self._offset = offset\n\n    if dtype is None:\n        # Infer the dtype from the graph's attribute\n        # TODO improve performance\n        df = graph.node_attrs(attr_keys=[self._attr_key])\n        if df.is_empty():\n            dtype = get_options().gav_default_dtype\n        else:\n            try:\n                dtype = polars_dtype_to_numpy_dtype(df[self._attr_key].dtype, allow_sequence=False)\n            except ValueError as e:\n                raise ValueError(f\"Attribute values for key '{self._attr_key}' must be scalar.\") from e\n            # napari support for bool is limited\n            if np.issubdtype(dtype, bool):\n                dtype = np.uint8\n\n    self._dtype = dtype\n    self.original_shape = _validate_shape(shape, graph, \"GraphArrayView\")\n\n    chunk_shape = chunk_shape or get_options().gav_chunk_shape\n    if isinstance(chunk_shape, int):\n        chunk_shape = (chunk_shape,) * (len(self.original_shape) - 1)\n    elif len(chunk_shape) &lt; len(self.original_shape) - 1:\n        chunk_shape = (1,) * (len(self.original_shape) - 1 - len(chunk_shape)) + tuple(chunk_shape)\n\n    self.chunk_shape = chunk_shape\n    self.buffer_cache_size = buffer_cache_size or get_options().gav_buffer_cache_size\n\n    self._indices = tuple(slice(0, s) for s in self.original_shape)\n    self._cache = NDChunkCache(\n        compute_func=self._fill_array,\n        shape=self.shape[1:],\n        chunk_shape=self.chunk_shape,\n        buffer_cache_size=self.buffer_cache_size,\n        dtype=self.dtype,\n    )\n\n    self._spatial_filter = self.graph.bbox_spatial_filter(\n        frame_attr_key=DEFAULT_ATTR_KEYS.T,\n        bbox_attr_key=DEFAULT_ATTR_KEYS.BBOX,\n    )\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(attr_key)","title":"<code>attr_key</code>","text":"(<code>str</code>)           \u2013            <p>The attribute key to view as an array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(offset)","title":"<code>offset</code>","text":"(<code>int | ndarray</code>, default:                   <code>0</code> )           \u2013            <p>The offset to apply to the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the array. If None, the shape is inferred from the graph metadata <code>shape</code> key.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape for the array. If None, the default chunk size is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView(buffer_cache_size)","title":"<code>buffer_cache_size</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of buffers to keep in the cache for the array. If None, the default buffer cache size is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype: dtype\n</code></pre> <p>Returns the dtype of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim: int\n</code></pre> <p>Returns the number of dimensions of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Returns the shape of the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.size","title":"size  <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Returns the total number of elements in the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__","title":"__array__","text":"<pre><code>__array__(\n    dtype: dtype | None = None, copy: bool | None = None\n) -&gt; np.ndarray\n</code></pre> <p>Convert the GraphArrayView to a numpy array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>In memory numpy array of the GraphArrayView of the current indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __array__(\n    self,\n    dtype: np.dtype | None = None,\n    copy: bool | None = None,\n) -&gt; np.ndarray:\n    \"\"\"Convert the GraphArrayView to a numpy array.\n\n    Parameters\n    ----------\n    dtype : np.dtype, optional\n        The desired dtype of the output array. If None, the dtype of the GraphArrayView is used.\n    copy : bool, optional\n        This parameter is ignored, as the GraphArrayView is read-only.\n\n    Returns\n    -------\n    np.ndarray\n        In memory numpy array of the GraphArrayView of the current indices.\n    \"\"\"\n\n    if sum(isinstance(i, Sequence) for i in self._indices) &gt; 1:\n        raise NotImplementedError(\"Multiple sequences in indices are not supported for __array__.\")\n\n    time = self._indices[0]\n    volume_slicing = self._indices[1:]\n\n    if np.isscalar(time):\n        try:\n            time = time.item()  # convert from numpy.int to int\n        except AttributeError:\n            pass\n        result = self._cache.get(\n            time=time,\n            volume_slicing=volume_slicing,\n        ).astype(dtype or self.dtype)\n        return np.array(result) if np.isscalar(result) else result\n    else:\n        if isinstance(time, slice):\n            time = range(self.original_shape[0])[time]\n\n        return np.stack(\n            [\n                self._cache.get(\n                    time=t,\n                    volume_slicing=volume_slicing,\n                )\n                for t in time\n            ]\n        ).astype(dtype or self.dtype)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__(dtype)","title":"<code>dtype</code>","text":"(<code>dtype</code>, default:                   <code>None</code> )           \u2013            <p>The desired dtype of the output array. If None, the dtype of the GraphArrayView is used.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__array__(copy)","title":"<code>copy</code>","text":"(<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>This parameter is ignored, as the GraphArrayView is read-only.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index: ArrayIndex) -&gt; GraphArrayView\n</code></pre> <p>Return a sliced view of the GraphArrayView.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>A new GraphArrayView object with updated indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def __getitem__(self, index: ArrayIndex) -&gt; \"GraphArrayView\":\n    \"\"\"Return a sliced view of the GraphArrayView.\n\n    Parameters\n    ----------\n    index : ArrayIndex\n        The indices to slice the array.\n\n    Returns\n    -------\n    GraphArrayView\n        A new GraphArrayView object with updated indices.\n    \"\"\"\n    normalized_index = []\n    if not isinstance(index, tuple):\n        index = (index,)\n    if None in index:\n        raise ValueError(\"None is not allowed for GraphArrayView indexing.\")\n    jj = 0\n    for oi in self._indices:\n        if np.isscalar(oi):\n            normalized_index.append(None)\n        else:\n            if len(index) &lt;= jj:\n                normalized_index.append(slice(None))\n            else:\n                normalized_index.append(index[jj])\n            jj += 1\n\n    return self.reindex(normalized_index)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__getitem__(index)","title":"<code>index</code>","text":"(<code>ArrayIndex</code>)           \u2013            <p>The indices to slice the array.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> <p>Returns the length of the first dimension of the array.</p> Source code in <code>src/tracksdata/array/_base_array.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Returns the length of the first dimension of the array.\"\"\"\n    return self.shape[0]\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array","title":"_fill_array","text":"<pre><code>_fill_array(\n    time: int,\n    volume_slicing: Sequence[slice],\n    buffer: ndarray,\n) -&gt; np.ndarray\n</code></pre> <p>Fill the buffer with data from the graph at a specific time.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The filled buffer.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def _fill_array(self, time: int, volume_slicing: Sequence[slice], buffer: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Fill the buffer with data from the graph at a specific time.\n\n    Parameters\n    ----------\n    time : int\n        The time point to retrieve data for.\n    volume_slicing : Sequence[slice]\n        The volume slicing information (currently not fully utilized).\n    buffer : np.ndarray\n        The buffer to fill with data.\n\n    Returns\n    -------\n    np.ndarray\n        The filled buffer.\n    \"\"\"\n    subgraph = self._spatial_filter[(slice(time, time), *volume_slicing)]\n    df = subgraph.node_attrs(\n        attr_keys=[self._attr_key, DEFAULT_ATTR_KEYS.MASK],\n    )\n\n    for mask, value in zip(df[DEFAULT_ATTR_KEYS.MASK], df[self._attr_key], strict=True):\n        mask: Mask\n        mask.paint_buffer(buffer, value, offset=self._offset)\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(time)","title":"<code>time</code>","text":"(<code>int</code>)           \u2013            <p>The time point to retrieve data for.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(volume_slicing)","title":"<code>volume_slicing</code>","text":"(<code>Sequence[slice]</code>)           \u2013            <p>The volume slicing information (currently not fully utilized).</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView._fill_array(buffer)","title":"<code>buffer</code>","text":"(<code>ndarray</code>)           \u2013            <p>The buffer to fill with data.</p>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.reindex","title":"reindex","text":"<pre><code>reindex(slicing: Sequence[ArrayIndex]) -&gt; GraphArrayView\n</code></pre> <p>Reindex the GraphArrayView. Returns a shallow copy of the GraphArrayView with the new indices.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphArrayView</code>           \u2013            <p>A new GraphArrayView object with updated indices.</p> </li> </ul> Source code in <code>src/tracksdata/array/_graph_array.py</code> <pre><code>def reindex(\n    self,\n    slicing: Sequence[ArrayIndex],\n) -&gt; \"GraphArrayView\":\n    \"\"\"\n    Reindex the GraphArrayView.\n    Returns a shallow copy of the GraphArrayView with the new indices.\n\n    Parameters\n    ----------\n    slicing : tuple[ArrayIndex, ...]\n        The new indices to apply to the GraphArrayView.\n\n    Returns\n    -------\n    GraphArrayView\n        A new GraphArrayView object with updated indices.\n    \"\"\"\n    obj = copy(self)\n    obj._indices = tuple(chain_indices(i1, i2) for i1, i2 in zip(self._indices, slicing, strict=False))\n    return obj\n</code></pre>"},{"location":"reference/tracksdata/array/#tracksdata.array.GraphArrayView.reindex(slicing)","title":"<code>slicing</code>","text":"(<code>tuple[ArrayIndex, ...]</code>)           \u2013            <p>The new indices to apply to the GraphArrayView.</p>"},{"location":"reference/tracksdata/attrs/","title":"attrs","text":""},{"location":"reference/tracksdata/attrs/#tracksdata.attrs","title":"tracksdata.attrs","text":"<p>Module to compose attribute expressions for attribute filtering or value evaluation.</p> <p>Attributes are used to query content of nodes and edges through their names as columns in a data frame.</p> <p>Users will mostly interact with NodeAttr and EdgeAttr which are thin wrappers around Attr to distinguish between node and edge attributes in ambiguous cases.</p> <p>They can be used to filter elements in the graph as: <pre><code>graph.filter(NodeAttr(\"t\") == 1).subgraph()\n</code></pre></p> <p>Or to create complex expression when solving the tracking problem: <pre><code>NearestNeighborsSolver(-Attr(\"iou\") * (-Attr(\"distance\") / 30.0).exp())\n</code></pre></p> <p>Classes:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>Class to store a comparison between an Attr and a value</p> </li> <li> <code>EdgeAttr</code>           \u2013            <p>Wrapper of Attr to represent an edge attribute.</p> </li> <li> <code>NodeAttr</code>           \u2013            <p>Wrapper of Attr to represent a node attribute.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>attr_comps_to_strs</code>             \u2013              <p>Convert a list of attribute comparisons to a list of strings.</p> </li> <li> <code>polars_reduce_attr_comps</code>             \u2013              <p>Reduce a list of attribute comparisons into a single polars expression.</p> </li> <li> <code>split_attr_comps</code>             \u2013              <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> </li> </ul>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr","title":"Attr","text":"<pre><code>Attr(value: ExprInput)\n</code></pre> <p>A class to compose an attribute expression for attribute filtering or value evaluation.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--parameters","title":"Parameters","text":"<p>value : ExprInput     The value to compose the attribute expression from.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr--examples","title":"Examples","text":"<pre><code>Attr(\"t\") == 1  # filter for time point 1\nAttr(\"iou\").log()  # log the iou\nAttr(1.0)  # constant value\nAttr((1 - Attr(\"iou\")) * Attr(\"distance\"))  # complex expression\n</code></pre> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> <li> <code>is_in</code>             \u2013              <p>Create a membership comparison between the attribute and a collection of literals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(\n    other: ExprInput, op: Callable, reverse: bool = False\n) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(\n    other: ExprInput,\n    op: Callable[[Expr, Expr], Expr],\n    reverse: bool = False,\n) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.is_in","title":"is_in","text":"<pre><code>is_in(values: MembershipExprInput) -&gt; AttrComparison\n</code></pre> <p>Create a membership comparison between the attribute and a collection of literals.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>A comparison suitable for filtering across all graph backends.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def is_in(self, values: MembershipExprInput) -&gt; \"AttrComparison\":\n    \"\"\"\n    Create a membership comparison between the attribute and a collection of literals.\n\n    Parameters\n    ----------\n    values : Iterable[Scalar] | Sequence[Scalar] | np.ndarray | Series\n        Values the attribute should belong to.\n\n    Returns\n    -------\n    AttrComparison\n        A comparison suitable for filtering across all graph backends.\n    \"\"\"\n    return AttrComparison(self, _is_in_op, values)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.Attr.is_in(values)","title":"<code>values</code>","text":"(<code>Iterable[Scalar] | Sequence[Scalar] | ndarray | Series</code>)           \u2013            <p>Values the attribute should belong to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison","title":"AttrComparison","text":"<pre><code>AttrComparison(\n    attr: Attr,\n    op: Callable,\n    other: ExprInput | MembershipExprInput,\n)\n</code></pre> <p>Class to store a comparison between an Attr and a value (a sequence of values for <code>is_in</code>). It's mainly used for filtering. Complex expression are transformed back to Attr objects which can be used to evaluate the expression on a DataFrame.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison--parameters","title":"Parameters","text":"<p>attr : Attr     The attribute to compare. op : Callable     The operator to use for the comparison. other : ExprInput | MembershipExprInput     The value to compare the attribute to.</p> <p>Methods:</p> <ul> <li> <code>to_attr</code>             \u2013              <p>Transform the comparison back to an Attr object.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, attr: \"Attr\", op: Callable, other: ExprInput | MembershipExprInput) -&gt; None:\n    is_membership_expr = _is_membership_expr_input(other)\n    if is_membership_expr and op != _is_in_op:\n        raise ValueError(\n            f\"Membership values can only be used with the 'is_in' method. Found '{_OPS_MATH_SYMBOLS[op]}'.\"\n        )\n    elif not is_membership_expr and op == _is_in_op:\n        raise ValueError(\n            f\"Cannot use 'is_in' method with non-membership values. Found '{other}' of type {type(other)}.\"\n        )\n\n    if attr.has_inf():\n        raise ValueError(\"Comparison operators are not supported for expressions with infinity.\")\n\n    if isinstance(other, Attr):\n        raise ValueError(f\"Does not support comparison between expressions. Found {other} and {attr}.\")\n\n    columns = attr.expr_columns\n\n    if len(columns) == 0:\n        raise ValueError(\"Comparison operators are not supported for empty expressions.\")\n\n    elif len(columns) &gt; 1:\n        raise ValueError(f\"Comparison operators are not supported for multiple columns. Found {columns}.\")\n\n    self.attr = attr\n    self.column = columns[0]\n    self.op = op\n\n    # casting numpy scalars to python scalars\n    # numpy scalars are problematic for sqlalchemy\n    if is_membership_expr:\n        if isinstance(other, np.ndarray):\n            other = other.tolist()\n        else:\n            other = list(other)\n    elif isinstance(other, np.ndarray):\n        other = other.item()\n    self.other = other\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.AttrComparison.to_attr","title":"to_attr","text":"<pre><code>to_attr() -&gt; Attr\n</code></pre> <p>Transform the comparison back to an Attr object. This is useful for evaluating the expression on a DataFrame.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def to_attr(self) -&gt; \"Attr\":\n    \"\"\"\n    Transform the comparison back to an [Attr][tracksdata.attrs.Attr] object.\n    This is useful for evaluating the expression on a DataFrame.\n    \"\"\"\n    return Attr(self.op(pl.col(self.column), self.other))\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr","title":"EdgeAttr","text":"<pre><code>EdgeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <pre><code>\n              flowchart TD\n              tracksdata.attrs.EdgeAttr[EdgeAttr]\n              tracksdata.attrs.Attr[Attr]\n\n                              tracksdata.attrs.Attr --&gt; tracksdata.attrs.EdgeAttr\n                \n\n\n              click tracksdata.attrs.EdgeAttr href \"\" \"tracksdata.attrs.EdgeAttr\"\n              click tracksdata.attrs.Attr href \"\" \"tracksdata.attrs.Attr\"\n            </code></pre> <p>Wrapper of Attr to represent an edge attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> <li> <code>is_in</code>             \u2013              <p>Create a membership comparison between the attribute and a collection of literals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(\n    other: ExprInput, op: Callable, reverse: bool = False\n) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(\n    other: ExprInput,\n    op: Callable[[Expr, Expr], Expr],\n    reverse: bool = False,\n) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.is_in","title":"is_in","text":"<pre><code>is_in(values: MembershipExprInput) -&gt; AttrComparison\n</code></pre> <p>Create a membership comparison between the attribute and a collection of literals.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>A comparison suitable for filtering across all graph backends.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def is_in(self, values: MembershipExprInput) -&gt; \"AttrComparison\":\n    \"\"\"\n    Create a membership comparison between the attribute and a collection of literals.\n\n    Parameters\n    ----------\n    values : Iterable[Scalar] | Sequence[Scalar] | np.ndarray | Series\n        Values the attribute should belong to.\n\n    Returns\n    -------\n    AttrComparison\n        A comparison suitable for filtering across all graph backends.\n    \"\"\"\n    return AttrComparison(self, _is_in_op, values)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.EdgeAttr.is_in(values)","title":"<code>values</code>","text":"(<code>Iterable[Scalar] | Sequence[Scalar] | ndarray | Series</code>)           \u2013            <p>Values the attribute should belong to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr","title":"NodeAttr","text":"<pre><code>NodeAttr(value: ExprInput)\n</code></pre> <p>               Bases: <code>Attr</code></p> <pre><code>\n              flowchart TD\n              tracksdata.attrs.NodeAttr[NodeAttr]\n              tracksdata.attrs.Attr[Attr]\n\n                              tracksdata.attrs.Attr --&gt; tracksdata.attrs.NodeAttr\n                \n\n\n              click tracksdata.attrs.NodeAttr href \"\" \"tracksdata.attrs.NodeAttr\"\n              click tracksdata.attrs.Attr href \"\" \"tracksdata.attrs.Attr\"\n            </code></pre> <p>Wrapper of Attr to represent a node attribute.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr--see-also","title":"See Also","text":"<p>Attr:     The base class for all attributes.</p> <p>Methods:</p> <ul> <li> <code>evaluate</code>             \u2013              <p>Evaluate the expression on a DataFrame returning a numeric result.</p> </li> <li> <code>has_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> </li> <li> <code>has_neg_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by negative infinity.</p> </li> <li> <code>has_pos_inf</code>             \u2013              <p>Check if any column in the expression is multiplied by positive infinity.</p> </li> <li> <code>is_in</code>             \u2013              <p>Create a membership comparison between the attribute and a collection of literals.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>expr_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns in the expression.</p> </li> <li> <code>inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by positive infinity.</p> </li> <li> <code>inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by positive infinity.</p> </li> <li> <code>neg_inf_columns</code>               (<code>list[str]</code>)           \u2013            <p>Get the names of columns multiplied by negative infinity.</p> </li> <li> <code>neg_inf_exprs</code>               (<code>list[Attr]</code>)           \u2013            <p>Get the expressions multiplied by negative infinity.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def __init__(self, value: ExprInput) -&gt; None:\n    self._inf_exprs = []  # expressions multiplied by +inf\n    self._neg_inf_exprs = []  # expressions multiplied by -inf\n\n    if isinstance(value, str):\n        self.expr = pl.col(value)\n    elif isinstance(value, Attr):\n        self.expr = value.expr\n        # Copy infinity tracking from the other AttrExpr\n        self._inf_exprs = value.inf_exprs\n        self._neg_inf_exprs = value.neg_inf_exprs\n    elif isinstance(value, AttrComparison):\n        attr = value.to_attr()\n        self.expr = attr.expr\n        self._inf_exprs = attr.inf_exprs\n        self._neg_inf_exprs = attr.neg_inf_exprs\n    elif isinstance(value, Expr):\n        self.expr = value\n    else:\n        self.expr = pl.lit(value)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.expr_columns","title":"expr_columns  <code>property</code>","text":"<pre><code>expr_columns: list[str]\n</code></pre> <p>Get the names of columns in the expression.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_columns","title":"inf_columns  <code>property</code>","text":"<pre><code>inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.inf_exprs","title":"inf_exprs  <code>property</code>","text":"<pre><code>inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by positive infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_columns","title":"neg_inf_columns  <code>property</code>","text":"<pre><code>neg_inf_columns: list[str]\n</code></pre> <p>Get the names of columns multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.neg_inf_exprs","title":"neg_inf_exprs  <code>property</code>","text":"<pre><code>neg_inf_exprs: list[Attr]\n</code></pre> <p>Get the expressions multiplied by negative infinity.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator","title":"_delegate_comparison_operator","text":"<pre><code>_delegate_comparison_operator(\n    other: ExprInput, op: Callable, reverse: bool = False\n) -&gt; AttrComparison | Attr\n</code></pre> <p>Simplified version of <code>_delegate_operator</code> for comparison operators. AttrComparison has a limited scope and it's mainly used for filtering. If creating an AttrComparison object is not possible, it will return an Attr object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison | Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_comparison_operator(\n    self,\n    other: ExprInput,\n    op: Callable,\n    reverse: bool = False,\n) -&gt; \"AttrComparison | Attr\":\n    \"\"\"\n    Simplified version of `_delegate_operator` for comparison operators.\n    [AttrComparison][tracksdata.attrs.AttrComparison] has a limited scope and\n    it's mainly used for filtering.\n    If creating an [AttrComparison][tracksdata.attrs.AttrComparison] object is\n    not possible, it will return an [Attr][tracksdata.attrs.Attr] object.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    AttrComparison | Attr\n        The result of the operator.\n    \"\"\"\n    if reverse:\n        lhs = Attr(other)\n        rhs = self\n    else:\n        lhs = self\n        rhs = other\n\n    if isinstance(other, Attr):\n        return self._delegate_operator(other, op, reverse=False)\n\n    return AttrComparison(lhs, op, rhs)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(op)","title":"<code>op</code>","text":"(<code>Callable</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_comparison_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator","title":"_delegate_operator","text":"<pre><code>_delegate_operator(\n    other: ExprInput,\n    op: Callable[[Expr, Expr], Expr],\n    reverse: bool = False,\n) -&gt; Attr\n</code></pre> <p>Delegate the operator to the expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Attr</code>           \u2013            <p>The result of the operator.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _delegate_operator(self, other: ExprInput, op: Callable[[Expr, Expr], Expr], reverse: bool = False) -&gt; \"Attr\":\n    \"\"\"\n    Delegate the operator to the expression.\n\n    Parameters\n    ----------\n    other : ExprInput\n        The other expression to delegate the operator to.\n    op : Callable[[Expr, Expr], Expr]\n        The operator to delegate.\n    reverse : bool, optional\n        Whether the operator is reversed.\n\n    Returns\n    -------\n    Attr\n        The result of the operator.\n    \"\"\"\n    # Special handling for multiplication with infinity\n    if op == operator.mul:\n        # Check if we're multiplying with infinity scalar\n        # In both reverse and non-reverse cases, 'other' is the infinity value\n        # and 'self' is the AttrExpr we want to track\n        if isinstance(other, int | float) and math.isinf(other):\n            result = Attr(pl.lit(0))  # Clean expression is zero (infinity term removed)\n\n            # Copy existing infinity tracking\n            result._inf_exprs = self._inf_exprs.copy()\n            result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n            # Add the expression to appropriate infinity list\n            if other &gt; 0:\n                result._inf_exprs.append(self)\n            else:\n                result._neg_inf_exprs.append(self)\n\n            return result\n\n    # Regular operation - no infinity involved\n    left = Attr(other).expr if reverse else self.expr\n    right = self.expr if reverse else Attr(other).expr\n    result = Attr(op(left, right))\n\n    # Combine infinity tracking from both operands\n    if isinstance(other, Attr):\n        result._inf_exprs = self._inf_exprs + other._inf_exprs\n        result._neg_inf_exprs = self._neg_inf_exprs + other._neg_inf_exprs\n\n        # Special handling for subtraction: flip signs of the second operand's infinity terms\n        if op == operator.sub and not reverse:\n            # self - other: other's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = self._inf_exprs + other._neg_inf_exprs\n            result._neg_inf_exprs = self._neg_inf_exprs + other._inf_exprs\n        elif op == operator.sub and reverse:\n            # other - self: self's positive infinity becomes negative, negative becomes positive\n            result._inf_exprs = other._inf_exprs + self._neg_inf_exprs\n            result._neg_inf_exprs = other._neg_inf_exprs + self._inf_exprs\n    else:\n        result._inf_exprs = self._inf_exprs.copy()\n        result._neg_inf_exprs = self._neg_inf_exprs.copy()\n\n    return result\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(other)","title":"<code>other</code>","text":"(<code>ExprInput</code>)           \u2013            <p>The other expression to delegate the operator to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(op)","title":"<code>op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operator to delegate.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr._delegate_operator(reverse)","title":"<code>reverse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether the operator is reversed.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate","title":"evaluate","text":"<pre><code>evaluate(df: DataFrame) -&gt; Series\n</code></pre> <p>Evaluate the expression on a DataFrame returning a numeric result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Series</code>           \u2013            <p>The evaluated expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def evaluate(self, df: DataFrame) -&gt; Series:\n    \"\"\"\n    Evaluate the expression on a DataFrame returning a numeric result.\n\n    Parameters\n    ----------\n    df : DataFrame\n        The DataFrame to evaluate the expression on.\n\n    Returns\n    -------\n    Series\n        The evaluated expression.\n    \"\"\"\n    return df.select(self.expr).to_series()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.evaluate(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The DataFrame to evaluate the expression on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_inf","title":"has_inf","text":"<pre><code>has_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by infinity or negative infinity.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if any column is multiplied by infinity, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by infinity or negative infinity.\n\n    Returns\n    -------\n    bool\n        True if any column is multiplied by infinity, False otherwise.\n    \"\"\"\n    return self.has_pos_inf() or self.has_neg_inf()\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_neg_inf","title":"has_neg_inf","text":"<pre><code>has_neg_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by negative infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_neg_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by negative infinity.\n    \"\"\"\n    return len(self._neg_inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.has_pos_inf","title":"has_pos_inf","text":"<pre><code>has_pos_inf() -&gt; bool\n</code></pre> <p>Check if any column in the expression is multiplied by positive infinity.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def has_pos_inf(self) -&gt; bool:\n    \"\"\"\n    Check if any column in the expression is multiplied by positive infinity.\n    \"\"\"\n    return len(self._inf_exprs) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.is_in","title":"is_in","text":"<pre><code>is_in(values: MembershipExprInput) -&gt; AttrComparison\n</code></pre> <p>Create a membership comparison between the attribute and a collection of literals.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AttrComparison</code>           \u2013            <p>A comparison suitable for filtering across all graph backends.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def is_in(self, values: MembershipExprInput) -&gt; \"AttrComparison\":\n    \"\"\"\n    Create a membership comparison between the attribute and a collection of literals.\n\n    Parameters\n    ----------\n    values : Iterable[Scalar] | Sequence[Scalar] | np.ndarray | Series\n        Values the attribute should belong to.\n\n    Returns\n    -------\n    AttrComparison\n        A comparison suitable for filtering across all graph backends.\n    \"\"\"\n    return AttrComparison(self, _is_in_op, values)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.NodeAttr.is_in(values)","title":"<code>values</code>","text":"(<code>Iterable[Scalar] | Sequence[Scalar] | ndarray | Series</code>)           \u2013            <p>Values the attribute should belong to.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs._is_in_op","title":"_is_in_op","text":"<pre><code>_is_in_op(lhs: Any, values: MembershipExprInput) -&gt; Any\n</code></pre> <p>Backend-aware membership operator that works for Polars expressions, SQLAlchemy columns, and Python scalars.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _is_in_op(lhs: Any, values: MembershipExprInput) -&gt; Any:\n    \"\"\"\n    Backend-aware membership operator that works for Polars expressions, SQLAlchemy columns, and Python scalars.\n    \"\"\"\n    if isinstance(lhs, pl.Expr):\n        return lhs.is_in(values)\n    if hasattr(lhs, \"in_\"):\n        return lhs.in_(values)\n    return lhs in values\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs._setup_ops","title":"_setup_ops","text":"<pre><code>_setup_ops() -&gt; None\n</code></pre> <p>Setup the operator methods for the AttrExpr class.</p> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def _setup_ops() -&gt; None:\n    \"\"\"\n    Setup the operator methods for the AttrExpr class.\n    \"\"\"\n    bin_ops = {\n        \"add\": operator.add,\n        \"sub\": operator.sub,\n        \"mul\": operator.mul,\n        \"truediv\": operator.truediv,\n        \"floordiv\": operator.floordiv,\n        \"mod\": operator.mod,\n        \"pow\": operator.pow,\n        \"and\": operator.and_,\n        \"or\": operator.or_,\n        \"xor\": operator.xor,\n    }\n\n    comp_ops = {\n        \"eq\": operator.eq,\n        \"ne\": operator.ne,\n        \"lt\": operator.lt,\n        \"le\": operator.le,\n        \"gt\": operator.gt,\n        \"ge\": operator.ge,\n    }\n\n    for op_name, op_func in bin_ops.items():\n        _add_operator(Attr, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(Attr, f\"__r{op_name}__\", op_func, reverse=True)\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n\n    for op_name, op_func in comp_ops.items():\n        _add_comparison_operator(f\"__{op_name}__\", op_func, reverse=False)\n        _add_comparison_operator(f\"__r{op_name}__\", op_func, reverse=True)\n\n        # attrr_comparision uses normal delegate_operator\n        _add_operator(AttrComparison, f\"__{op_name}__\", op_func, reverse=False)\n        _add_operator(AttrComparison, f\"__r{op_name}__\", op_func, reverse=True)\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs","title":"attr_comps_to_strs","text":"<pre><code>attr_comps_to_strs(\n    attr_comps: Sequence[AttrComparison],\n) -&gt; list[str]\n</code></pre> <p>Convert a list of attribute comparisons to a list of strings.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The attribute comparisons as strings.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def attr_comps_to_strs(attr_comps: Sequence[AttrComparison]) -&gt; list[str]:\n    \"\"\"\n    Convert a list of attribute comparisons to a list of strings.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to convert to strings.\n\n    Returns\n    -------\n    list[str]\n        The attribute comparisons as strings.\n    \"\"\"\n    return [str(attr_comp.column) for attr_comp in attr_comps]\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.attr_comps_to_strs(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to convert to strings.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps","title":"polars_reduce_attr_comps","text":"<pre><code>polars_reduce_attr_comps(\n    df: DataFrame,\n    attr_comps: Sequence[AttrComparison],\n    reduce_op: Callable[[Expr, Expr], Expr],\n) -&gt; pl.Expr\n</code></pre> <p>Reduce a list of attribute comparisons into a single polars expression.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Expr</code>           \u2013            <p>The reduced polars expression.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def polars_reduce_attr_comps(\n    df: pl.DataFrame,\n    attr_comps: Sequence[AttrComparison],\n    reduce_op: Callable[[Expr, Expr], Expr],\n) -&gt; pl.Expr:\n    \"\"\"\n    Reduce a list of attribute comparisons into a single polars expression.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        The dataframe to reduce the attribute comparisons on.\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to reduce.\n    reduce_op : Callable[[Expr, Expr], Expr]\n        The operation to reduce the attribute comparisons with.\n\n    Returns\n    -------\n    pl.Expr\n        The reduced polars expression.\n    \"\"\"\n    if not attr_comps:\n        # Return True for all rows by using the first column as a reference\n        raise ValueError(\"No attribute comparisons provided.\")\n\n    return pl.reduce(reduce_op, [attr_comp.op(df[str(attr_comp.column)], attr_comp.other) for attr_comp in attr_comps])\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to reduce the attribute comparisons on.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to reduce.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.polars_reduce_attr_comps(reduce_op)","title":"<code>reduce_op</code>","text":"(<code>Callable[[Expr, Expr], Expr]</code>)           \u2013            <p>The operation to reduce the attribute comparisons with.</p>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps","title":"split_attr_comps","text":"<pre><code>split_attr_comps(\n    attr_comps: Sequence[AttrComparison],\n) -&gt; tuple[list[AttrComparison], list[AttrComparison]]\n</code></pre> <p>Split a list of attribute comparisons into node and edge attribute comparisons.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[AttrComparison], list[AttrComparison]]</code>           \u2013            <p>A tuple of lists of node and edge attribute comparisons.</p> </li> </ul> Source code in <code>src/tracksdata/attrs.py</code> <pre><code>def split_attr_comps(attr_comps: Sequence[AttrComparison]) -&gt; tuple[list[AttrComparison], list[AttrComparison]]:\n    \"\"\"\n    Split a list of attribute comparisons into node and edge attribute comparisons.\n\n    Parameters\n    ----------\n    attr_comps : Sequence[AttrComparison]\n        The attribute comparisons to split.\n\n    Returns\n    -------\n    tuple[list[AttrComparison], list[AttrComparison]]\n        A tuple of lists of node and edge attribute comparisons.\n    \"\"\"\n    node_attr_comps = []\n    edge_attr_comps = []\n\n    for attr_comp in attr_comps:\n        if isinstance(attr_comp.attr, NodeAttr):\n            node_attr_comps.append(attr_comp)\n        elif isinstance(attr_comp.attr, EdgeAttr):\n            edge_attr_comps.append(attr_comp)\n        else:\n            raise ValueError(f\"Expected comparisons of 'NodeAttr' or 'EdgeAttr' objects, got {type(attr_comp.attr)}\")\n\n    return node_attr_comps, edge_attr_comps\n</code></pre>"},{"location":"reference/tracksdata/attrs/#tracksdata.attrs.split_attr_comps(attr_comps)","title":"<code>attr_comps</code>","text":"(<code>Sequence[AttrComparison]</code>)           \u2013            <p>The attribute comparisons to split.</p>"},{"location":"reference/tracksdata/constants/","title":"constants","text":""},{"location":"reference/tracksdata/constants/#tracksdata.constants","title":"tracksdata.constants","text":"<p>Module to define default and often global values used through <code>tracksdata</code>.</p> <p>Classes:</p> <ul> <li> <code>DefaultAttrKeys</code>           \u2013            <p>This class defines the standard attribute names for nodes and edges in graphs to ensure</p> </li> </ul>"},{"location":"reference/tracksdata/constants/#tracksdata.constants.DefaultAttrKeys","title":"DefaultAttrKeys","text":"<p>This class defines the standard attribute names for nodes and edges in graphs to ensure consistency across different graph implementations and operators.</p> <p>Using these constants instead of hardcoded strings helps prevent typos.</p> <p>Attributes:</p> <ul> <li> <code>NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for node identifiers.</p> </li> <li> <code>T</code>               (<code>str</code>)           \u2013            <p>Default key for time information.</p> </li> <li> <code>MASK</code>               (<code>str</code>)           \u2013            <p>Default key for node masks.</p> </li> <li> <code>BBOX</code>               (<code>str</code>)           \u2013            <p>Default key for node bounding boxes. For a 2D image, the bounding box is a tuple of (x_start, y_start, x_end, y_end). For a 3D image, the bounding box is a tuple of (x_start, y_start, z_start, x_end, y_end, z_end).</p> </li> <li> <code>SOLUTION</code>               (<code>str</code>)           \u2013            <p>Default key for solution information.</p> </li> <li> <code>tracklet_id</code>               (<code>str</code>)           \u2013            <p>Default key for track identifiers.</p> </li> <li> <code>EDGE_ID</code>               (<code>str</code>)           \u2013            <p>Default key for edge identifiers.</p> </li> <li> <code>EDGE_WEIGHT</code>               (<code>str</code>)           \u2013            <p>Default key for edge weights.</p> </li> <li> <code>EDGE_SOURCE</code>               (<code>str</code>)           \u2013            <p>Default key for edge source node identifier.</p> </li> <li> <code>EDGE_TARGET</code>               (<code>str</code>)           \u2013            <p>Default key for edge target node identifier.</p> </li> <li> <code>MATCHED_NODE_ID</code>               (<code>str</code>)           \u2013            <p>Default key to identify respective node in another graph used for matching.</p> </li> <li> <code>MATCH_SCORE</code>               (<code>str</code>)           \u2013            <p>Default key between a node and its respective node in another graph used for matching.</p> </li> <li> <code>MATCHED_EDGE_MASK</code>               (<code>str</code>)           \u2013            <p>Default key for boolean mask indicating if edge exists in the matching graph.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.constants import DEFAULT_ATTR_KEYS\n\nprint(DEFAULT_ATTR_KEYS.NODE_ID)  # Output: node_id\nprint(DEFAULT_ATTR_KEYS.EDGE_WEIGHT)  # Output: weight\n</code></pre>"},{"location":"reference/tracksdata/edges/","title":"edges","text":""},{"location":"reference/tracksdata/edges/#tracksdata.edges","title":"tracksdata.edges","text":"<p>Edge operators for creating connections between nodes of a graph.</p> <p>Classes:</p> <ul> <li> <code>DistanceEdges</code>           \u2013            <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> </li> <li> <code>GenericFuncEdgeAttrs</code>           \u2013            <p>Add weights to the edges of the graph based on the output of a function.</p> </li> <li> <code>IoUEdgeAttr</code>           \u2013            <p>Add weights to the edges of the graph based on the IoU</p> </li> </ul>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges","title":"DistanceEdges","text":"<pre><code>DistanceEdges(\n    distance_threshold: float,\n    n_neighbors: int,\n    delta_t: int = 1,\n    output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    attr_keys: Sequence[str] | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseEdgesOperator</code></p> <pre><code>\n              flowchart TD\n              tracksdata.edges.DistanceEdges[DistanceEdges]\n              tracksdata.edges._base_edges.BaseEdgesOperator[BaseEdgesOperator]\n\n                              tracksdata.edges._base_edges.BaseEdgesOperator --&gt; tracksdata.edges.DistanceEdges\n                \n\n\n              click tracksdata.edges.DistanceEdges href \"\" \"tracksdata.edges.DistanceEdges\"\n              click tracksdata.edges._base_edges.BaseEdgesOperator href \"\" \"tracksdata.edges._base_edges.BaseEdgesOperator\"\n            </code></pre> <p>Operator that adds edges to a graph based on Euclidean distance between nodes.</p> <p>Creates edges between nodes in consecutive time points by finding the closest neighbors within a specified distance threshold using efficient KDTree-based spatial indexing. Creates directed edges from nodes in the range t-1 to t-delta_t to the nodes in the current time point t, representing potential transitions.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>distance_threshold</code>               (<code>float</code>)           \u2013            <p>The distance threshold for adding edges.</p> </li> <li> <code>n_neighbors</code>               (<code>int</code>)           \u2013            <p>The maximum number of neighbors to consider for adding edges. This in respect from the current to the previous frame. That means, a node in frame t will have edges to the closest n_neighbors nodes in frame t-1.</p> </li> <li> <code>output_key</code>               (<code>str</code>)           \u2013            <p>The key used to store distance values in edges.</p> </li> <li> <code>attr_keys</code>               (<code>Sequence[str] | None</code>)           \u2013            <p>The attribute keys to use for the distance calculation. When None, \"z\", \"y\", \"x\" are used.</p> </li> <li> <code>show_progress</code>               (<code>bool</code>)           \u2013            <p>Whether to print progress of the edges addition.</p> </li> </ul> <p>Examples:</p> <p>Create a distance-based edge operator:</p> <pre><code>from tracksdata.edges import DistanceEdges\n\nedge_op = DistanceEdges(distance_threshold=50.0, n_neighbors=3, attr_keys=[\"x\", \"y\"])\n</code></pre> <p>Add edges to a graph:</p> <pre><code>edge_op.add_edges(graph)\n</code></pre> <p>Add edges for a specific time point:</p> <pre><code>edge_op.add_edges(graph, t=5)\n</code></pre> <p>Use custom output key:</p> <pre><code>edge_op = DistanceEdges(distance_threshold=30.0, n_neighbors=2, output_key=\"euclidean_distance\")\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_edges</code>             \u2013              <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring</p> </li> </ul> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def __init__(\n    self,\n    distance_threshold: float,\n    n_neighbors: int,\n    delta_t: int = 1,\n    output_key: str = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    attr_keys: Sequence[str] | None = None,\n):\n    if delta_t &lt; 1:\n        raise ValueError(f\"'delta_t' must be at least 1, got {delta_t}\")\n\n    super().__init__(output_key=output_key)\n    self.distance_threshold = distance_threshold\n    self.n_neighbors = n_neighbors\n    self.delta_t = delta_t\n    self.attr_keys = attr_keys\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(distance_threshold)","title":"<code>distance_threshold</code>","text":"(<code>float</code>)           \u2013            <p>Maximum Euclidean distance for adding edges between nodes. Nodes farther apart than this threshold will not be connected.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(n_neighbors)","title":"<code>n_neighbors</code>","text":"(<code>int</code>)           \u2013            <p>Maximum number of neighbors to consider for each node when adding edges. For each node at time t, edges will be created to at most n_neighbors closest nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(delta_t)","title":"<code>delta_t</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of time points to consider for adding edges. For each node at time t, edges will be created to the closest n_neighbors nodes at time t-1 to t-delta_t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>The attribute key to store the distance values in the edges.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node attribute keys to use for distance calculation. If None, defaults to [\"z\", \"y\", \"x\"] if \"z\" exists, otherwise [\"y\", \"x\"].</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time","title":"_add_edges_per_time","text":"<pre><code>_add_edges_per_time(\n    t: int, *, graph: BaseGraph\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add distance-based edges between nodes at consecutive time points.</p> <p>Finds nodes at time t-1 and t, computes pairwise distances using KDTree, and creates edges between nearby nodes within the distance threshold. Uses bulk edge insertion for efficiency.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _add_edges_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add distance-based edges between nodes at consecutive time points.\n\n    Finds nodes at time t-1 and t, computes pairwise distances using KDTree,\n    and creates edges between nearby nodes within the distance threshold.\n    Uses bulk edge insertion for efficiency.\n\n    Parameters\n    ----------\n    t : int\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    graph : BaseGraph\n        The current time point. Edges will be created from nodes at\n        time t-1 to nodes at time t.\n    \"\"\"\n    if self.attr_keys is None:\n        if \"z\" in graph.node_attr_keys:\n            attr_keys = [\"z\", \"y\", \"x\"]\n        else:\n            attr_keys = [\"y\", \"x\"]\n    else:\n        attr_keys = self.attr_keys\n\n    if self.delta_t == 1:\n        # faster than the range filter\n        prev_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t - 1)\n    else:\n        prev_filter = graph.filter(\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &gt;= t - self.delta_t,\n            NodeAttr(DEFAULT_ATTR_KEYS.T) &lt; t,\n        )\n\n    if prev_filter.is_empty():\n        LOG.warning(\n            \"No nodes found for time point in range (%d &lt;= t &lt; %d)\",\n            t - self.delta_t,\n            t,\n        )\n        return []\n\n    current_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if current_filter.is_empty():\n        LOG.warning(\n            \"No nodes found for time point %d\",\n            t,\n        )\n        return []\n\n    prev_attrs = prev_filter.node_attrs(attr_keys=attr_keys)\n    cur_attrs = current_filter.node_attrs(attr_keys=attr_keys)\n\n    prev_kdtree = KDTree(prev_attrs.to_numpy())\n\n    distances, prev_neigh_ids = prev_kdtree.query(\n        cur_attrs.to_numpy(),\n        k=self.n_neighbors,\n        distance_upper_bound=self.distance_threshold,\n    )\n    is_valid = ~np.isinf(distances)\n\n    prev_node_ids = np.asarray(prev_filter.node_ids())\n    # kdtree return from 0 to n-1\n    # converting back to arbitrary indexing\n    prev_neigh_ids[is_valid] = prev_node_ids[prev_neigh_ids[is_valid]]\n\n    edges_data = []\n    for cur_id, neigh_ids, neigh_dist, neigh_valid in zip(\n        current_filter.node_ids(), prev_neigh_ids, distances, is_valid, strict=True\n    ):\n        for neigh_id, dist in zip(neigh_ids[neigh_valid].tolist(), neigh_dist[neigh_valid].tolist(), strict=True):\n            edges_data.append(\n                {\n                    \"source_id\": neigh_id,\n                    \"target_id\": cur_id,\n                    self.output_key: dist,\n                }\n            )\n\n    if len(edges_data) == 0:\n        LOG.warning(\"No valid edges found for the pair of time point (%d, %d)\", t, t - 1)\n\n    return edges_data\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._add_edges_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The current time point. Edges will be created from nodes at time t-1 to nodes at time t.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_distance_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges","title":"add_edges","text":"<pre><code>add_edges(\n    graph: BaseGraph, *, t: int | None = None, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Initialize the edges from nodes of given <code>time</code> to nodes in neighboring times (<code>time</code> + <code>\\delta time</code>)</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edges.py</code> <pre><code>def add_edges(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    r\"\"\"\n    Initialize the edges from nodes of given `time` to nodes in neighboring\n    times (`time` + `\\delta time`)\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to initialize the edges in.\n    t: int\n        The time of the nodes to initialize the edges from.\n    **kwargs: Any\n        Additional keyword arguments to pass to the `add_edges` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_attrs in multiprocessing_apply(\n        partial(self._add_edges_per_time, graph=graph, **kwargs),\n        time_points,\n        desc=\"Adding edges\",\n    ):\n        graph.bulk_add_edges(edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to initialize the edges in.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time of the nodes to initialize the edges from.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.DistanceEdges.add_edges(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>add_edges</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs","title":"GenericFuncEdgeAttrs","text":"<pre><code>GenericFuncEdgeAttrs(\n    func: Callable[\n        [dict[str, Any] | Any, dict[str, Any] | Any], Any\n    ],\n    attr_keys: Sequence[str] | str,\n    output_key: str,\n)\n</code></pre> <p>               Bases: <code>BaseEdgeAttrsOperator</code></p> <pre><code>\n              flowchart TD\n              tracksdata.edges.GenericFuncEdgeAttrs[GenericFuncEdgeAttrs]\n              tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator[BaseEdgeAttrsOperator]\n\n                              tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator --&gt; tracksdata.edges.GenericFuncEdgeAttrs\n                \n\n\n              click tracksdata.edges.GenericFuncEdgeAttrs href \"\" \"tracksdata.edges.GenericFuncEdgeAttrs\"\n              click tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator href \"\" \"tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator\"\n            </code></pre> <p>Add weights to the edges of the graph based on the output of a function.</p> <p>When provided multiple attribute keys, the function should take a dict with the keys as values for each node.</p> <p>When provided a single attribute key, the function should take the value for each node.</p> <p>For example, if the function is <code>func(source_attr, target_attr)</code>, and the attribute keys are <code>[\"a\", \"b\"]</code>, then the function should be <code>func({\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4})</code>.</p> <p>For a single attribute key \"a\", the function should take a single value for each node, as <code>func(1, 3)</code>.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any],\n    attr_keys: Sequence[str] | str,\n    output_key: str,\n) -&gt; None:\n    super().__init__(output_key=output_key)\n    self.attr_keys = attr_keys\n    self.func = func\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[dict[str, Any] | Any, dict[str, Any] | Any], Any]</code>)           \u2013            <p>The function to apply to the source and target attributes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str</code>)           \u2013            <p>The keys of the attributes to pass to the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to store the output of the function.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(\n    t: int, *, graph: BaseGraph\n) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t, include_targets=True)\n    edges_df = graph_filter.edge_attrs(attr_keys=[])\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to successors\")\n        return [], {}\n\n    att_keys_list = self.attr_keys if isinstance(self.attr_keys, list) else [self.attr_keys]\n    nodes_df = graph_filter.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *att_keys_list])\n\n    source_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_SOURCE: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    target_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_TARGET: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    for df in [source_df, target_df]:\n        if len(df) != len(edges_df):\n            raise ValueError(\n                f\"Number of edges ({len(edges_df)}) and nodes ({len(df)}) do not match. Something went wrong.\"\n            )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(\n    graph: BaseGraph, *, t: int | None = None, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=partial(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.GenericFuncEdgeAttrs.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr","title":"IoUEdgeAttr","text":"<pre><code>IoUEdgeAttr(\n    output_key: str, mask_key: str = DEFAULT_ATTR_KEYS.MASK\n)\n</code></pre> <p>               Bases: <code>GenericFuncEdgeAttrs</code></p> <pre><code>\n              flowchart TD\n              tracksdata.edges.IoUEdgeAttr[IoUEdgeAttr]\n              tracksdata.edges._generic_edges.GenericFuncEdgeAttrs[GenericFuncEdgeAttrs]\n              tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator[BaseEdgeAttrsOperator]\n\n                              tracksdata.edges._generic_edges.GenericFuncEdgeAttrs --&gt; tracksdata.edges.IoUEdgeAttr\n                                tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator --&gt; tracksdata.edges._generic_edges.GenericFuncEdgeAttrs\n                \n\n\n\n              click tracksdata.edges.IoUEdgeAttr href \"\" \"tracksdata.edges.IoUEdgeAttr\"\n              click tracksdata.edges._generic_edges.GenericFuncEdgeAttrs href \"\" \"tracksdata.edges._generic_edges.GenericFuncEdgeAttrs\"\n              click tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator href \"\" \"tracksdata.edges._base_edge_attrs.BaseEdgeAttrsOperator\"\n            </code></pre> <p>Add weights to the edges of the graph based on the IoU of the masks of the nodes.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_edge_attrs</code>             \u2013              <p>Add attributes to the edges of the graph for a given time or all time points.</p> </li> </ul> Source code in <code>src/tracksdata/edges/_iou_edges.py</code> <pre><code>def __init__(\n    self,\n    output_key: str,\n    mask_key: str = DEFAULT_ATTR_KEYS.MASK,\n):\n    super().__init__(\n        func=Mask.iou,\n        attr_keys=mask_key,\n        output_key=output_key,\n    )\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the output of the IoU.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr(mask_key)","title":"<code>mask_key</code>","text":"(<code>str</code>, default:                   <code>MASK</code> )           \u2013            <p>The key to use for the masks of the nodes.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time","title":"_edge_attrs_per_time","text":"<pre><code>_edge_attrs_per_time(\n    t: int, *, graph: BaseGraph\n) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add weights to the edges of the graph based on the output of a function for a specific time point.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _edge_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add weights to the edges of the graph based on the output of a function\n    for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add weights for.\n    graph : BaseGraph\n        The graph to add weights to.\n    \"\"\"\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t, include_targets=True)\n    edges_df = graph_filter.edge_attrs(attr_keys=[])\n\n    if len(edges_df) == 0:\n        LOG.warning(f\"No edges found for time point {t} to successors\")\n        return [], {}\n\n    att_keys_list = self.attr_keys if isinstance(self.attr_keys, list) else [self.attr_keys]\n    nodes_df = graph_filter.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *att_keys_list])\n\n    source_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_SOURCE: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    target_df = edges_df.rename({DEFAULT_ATTR_KEYS.EDGE_TARGET: DEFAULT_ATTR_KEYS.NODE_ID}).join(\n        nodes_df,\n        on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    for df in [source_df, target_df]:\n        if len(df) != len(edges_df):\n            raise ValueError(\n                f\"Number of edges ({len(edges_df)}) and nodes ({len(df)}) do not match. Something went wrong.\"\n            )\n\n    weights = np.zeros(len(edges_df), dtype=np.float32)\n\n    if isinstance(self.attr_keys, str):\n        # faster than creating a dict\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys],\n                target_df[self.attr_keys],\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n    else:\n        # a bit more expensive to create a dict but more flexible\n        for i, (source_attr, target_attr) in enumerate(\n            zip(\n                source_df[self.attr_keys].iter_rows(named=True),\n                target_df[self.attr_keys].iter_rows(named=True),\n                strict=True,\n            )\n        ):\n            weights[i] = self.func(source_attr, target_attr)\n\n    return edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_list(), {self.output_key: weights}\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add weights for.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._edge_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add weights to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr._init_edge_attrs","title":"_init_edge_attrs","text":"<pre><code>_init_edge_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the edge attributes for the graph.</p> Source code in <code>src/tracksdata/edges/_generic_edges.py</code> <pre><code>def _init_edge_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the edge attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, default_value=-99999.0)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs","title":"add_edge_attrs","text":"<pre><code>add_edge_attrs(\n    graph: BaseGraph, *, t: int | None = None, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Add attributes to the edges of the graph for a given time or all time points.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/edges/_base_edge_attrs.py</code> <pre><code>def add_edge_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Add attributes to the edges of the graph for a given time or all time points.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    **kwargs : Any\n        Additional keyword arguments to pass to the `_add_edge_attrs_per_time` method.\n    \"\"\"\n    self._init_edge_attrs(graph)\n\n    if t is None:\n        time_points = graph.time_points()\n    else:\n        time_points = [t]\n\n    for edge_ids, edge_attrs in multiprocessing_apply(\n        func=partial(self._edge_attrs_per_time, graph=graph, **kwargs),\n        sequence=time_points,\n        desc=\"Adding edge attributes\",\n    ):\n        graph.update_edge_attrs(edge_ids=edge_ids, attrs=edge_attrs)\n</code></pre>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/edges/#tracksdata.edges.IoUEdgeAttr.add_edge_attrs(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>_add_edge_attrs_per_time</code> method.</p>"},{"location":"reference/tracksdata/functional/","title":"functional","text":""},{"location":"reference/tracksdata/functional/#tracksdata.functional","title":"tracksdata.functional","text":"<p>Functional utilities for graph operations.</p> <p>Classes:</p> <ul> <li> <code>TilingScheme</code>           \u2013            <p>Tiling scheme for the graph.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>ancestral_connected_edges</code>             \u2013              <p>Let an ancestral path be any sequence from (target, source)-edges in the <code>reference_graph</code>.</p> </li> <li> <code>apply_tiled</code>             \u2013              <p>Apply a function to a graph tiled by the tiling scheme.</p> </li> <li> <code>join_node_attrs_to_edges</code>             \u2013              <p>Add node attributes to edge attributes by joining on the node ID.</p> </li> <li> <code>rx_digraph_to_napari_dict</code>             \u2013              <p>Convert a tracklet graph to a napari-ready dictionary.</p> </li> <li> <code>to_napari_format</code>             \u2013              <p>Convert the subgraph of solution nodes to a napari-ready format.</p> </li> </ul>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.TilingScheme","title":"TilingScheme  <code>dataclass</code>","text":"<pre><code>TilingScheme(\n    tile_shape: tuple[S, ...],\n    overlap_shape: tuple[S, ...],\n    attrs: list[str] | None = None,\n)\n</code></pre> <p>Tiling scheme for the graph. Graph will be sliced with 'tile_shape' + 2 * 'overlap_shape' per axis.</p> <p>Parameters:</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.TilingScheme(tile_shape)","title":"<code>tile_shape</code>","text":"(<code>tuple[S, ...]</code>)           \u2013            <p>The shape of the tile.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.TilingScheme(overlap_shape)","title":"<code>overlap_shape</code>","text":"(<code>tuple[S, ...]</code>)           \u2013            <p>The overlap between tiles PER SIDE.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.TilingScheme(attrs)","title":"<code>attrs</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes to include in the tile. If None, all attributes will be included. By default \"t\", \"z\", \"y\", \"x\" are included. If some columns are not present, they will be ignored.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.ancestral_connected_edges","title":"ancestral_connected_edges","text":"<pre><code>ancestral_connected_edges(\n    input_graph: BaseGraph,\n    reference_graph: BaseGraph,\n    match: bool = True,\n) -&gt; list[int]\n</code></pre> <p>Let an ancestral path be any sequence from (target, source)-edges in the <code>reference_graph</code>. This function returns the subset of edges in the <code>input_graph</code> that are part of an ancestral path in the reference graph.</p> <p>IMPORTANT: This function updates the <code>input_graph</code> in place when matching with the <code>reference_graph</code>.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/functional/_labeling.py</code> <pre><code>def ancestral_connected_edges(\n    input_graph: BaseGraph,\n    reference_graph: BaseGraph,\n    match: bool = True,\n) -&gt; list[int]:\n    \"\"\"\n    Let an ancestral path be any sequence from (target, source)-edges in the `reference_graph`.\n    This function returns the subset of edges in the `input_graph` that are\n    part of an ancestral path in the reference graph.\n\n    IMPORTANT: This function updates the `input_graph` in place when matching\n    with the `reference_graph`.\n\n    Parameters\n    ----------\n    input_graph : BaseGraph\n        The input graph.\n    reference_graph : BaseGraph\n        The reference graph.\n    match : bool, optional\n        Whether to match the input graph with the reference graph.\n    \"\"\"\n    if DEFAULT_ATTR_KEYS.TRACKLET_ID not in reference_graph.node_attr_keys:\n        tracklet_graph = reference_graph.assign_tracklet_ids()\n    else:\n        tracklet_graph = reference_graph.tracklet_graph()\n\n    if match:\n        input_graph.match(reference_graph)\n\n    elif DEFAULT_ATTR_KEYS.MATCHED_NODE_ID not in input_graph.node_attr_keys:\n        raise ValueError(\n            \"`ancestral_connected_edges` requires the input graph to previously matched \"\n            f\"and have a `{DEFAULT_ATTR_KEYS.MATCHED_NODE_ID}` column when `match=False`\"\n        )\n\n    in_node_attrs = input_graph.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MATCHED_NODE_ID])\n    ref_node_attrs = reference_graph.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.TRACKLET_ID])\n\n    in_node_attrs = in_node_attrs.filter(\n        pl.col(DEFAULT_ATTR_KEYS.MATCHED_NODE_ID) &gt;= 0,\n    ).join(\n        ref_node_attrs,\n        left_on=DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n        right_on=DEFAULT_ATTR_KEYS.NODE_ID,\n        how=\"left\",\n    )\n\n    edge_attrs = input_graph.edge_attrs(attr_keys=[])\n\n    edge_attrs = join_node_attrs_to_edges(\n        node_attrs=in_node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.TRACKLET_ID),\n        edge_attrs=edge_attrs,\n    )\n\n    tracklet_ancestral_edges = _ancestral_edges(tracklet_graph)\n    input_graph_ancestral_edges = _input_graph_ancestral_edges(\n        edge_attrs=edge_attrs,\n        ancestral_edges=tracklet_ancestral_edges,\n    )\n\n    return input_graph_ancestral_edges\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.ancestral_connected_edges(input_graph)","title":"<code>input_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.ancestral_connected_edges(reference_graph)","title":"<code>reference_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The reference graph.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.ancestral_connected_edges(match)","title":"<code>match</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to match the input graph with the reference graph.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.apply_tiled","title":"apply_tiled","text":"<pre><code>apply_tiled(\n    graph: BaseGraph,\n    tiling_scheme: TilingScheme,\n    func: MapFunc,\n    *,\n    agg_func: None,\n) -&gt; Iterator[T]\n</code></pre><pre><code>apply_tiled(\n    graph: BaseGraph,\n    tiling_scheme: TilingScheme,\n    func: MapFunc,\n    *,\n    agg_func: ReduceFunc,\n) -&gt; R\n</code></pre> <pre><code>apply_tiled(\n    graph: BaseGraph,\n    tiling_scheme: TilingScheme,\n    func: MapFunc,\n    *,\n    agg_func: ReduceFunc | None = None,\n) -&gt; Iterator[T] | R\n</code></pre> <p>Apply a function to a graph tiled by the tiling scheme. Graph will be sliced with 'tile_shape' + 2 * 'overlap_shape' per axis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[T] | R</code>           \u2013            <p>The results of the function. If agg_func is provided, the results will be reduced. Otherwise, the results will be yielded.</p> </li> </ul> Source code in <code>src/tracksdata/functional/_apply.py</code> <pre><code>def apply_tiled(\n    graph: BaseGraph,\n    tiling_scheme: TilingScheme,\n    func: MapFunc,\n    *,\n    agg_func: ReduceFunc | None = None,\n) -&gt; Iterator[T] | R:\n    \"\"\"\n    Apply a function to a graph tiled by the tiling scheme.\n    Graph will be sliced with 'tile_shape' + 2 * 'overlap_shape' per axis.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to apply the function to.\n    tiling_scheme : TilingScheme\n        The tiling scheme to use.\n    func : MapFunc\n        The function to apply to each tile.\n        It takes two arguments:\n        - filtered_graph_with_overlap: the subgraph inside the tile with the overlap\n        - filtered_graph: the subgraph inside the tile without the overlap\n        If all overlaps are 0, filtered_graph_with_overlap == filtered_graph with minimal overhead.\n\n    agg_func : ReduceFunc | None, optional\n        The function to reduce the results of the function. If None, the results will be yielded.\n\n    Returns\n    -------\n    Iterator[T] | R\n        The results of the function. If agg_func is provided, the results will be reduced.\n        Otherwise, the results will be yielded.\n    \"\"\"\n    # this needs to be a separate function because python behave weirdly\n    # with functions with both yield and return statements\n    res_generator = _yield_apply_tiled(\n        graph=graph,\n        tiling_scheme=tiling_scheme,\n        func=func,\n    )\n\n    # if agg_func is provided, we need to reduce the results\n    if agg_func is not None:\n        return agg_func(res_generator)\n\n    return res_generator\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.apply_tiled(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to apply the function to.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.apply_tiled(tiling_scheme)","title":"<code>tiling_scheme</code>","text":"(<code>TilingScheme</code>)           \u2013            <p>The tiling scheme to use.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.apply_tiled(func)","title":"<code>func</code>","text":"(<code>MapFunc</code>)           \u2013            <p>The function to apply to each tile. It takes two arguments: - filtered_graph_with_overlap: the subgraph inside the tile with the overlap - filtered_graph: the subgraph inside the tile without the overlap If all overlaps are 0, filtered_graph_with_overlap == filtered_graph with minimal overhead.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.apply_tiled(agg_func)","title":"<code>agg_func</code>","text":"(<code>ReduceFunc | None</code>, default:                   <code>None</code> )           \u2013            <p>The function to reduce the results of the function. If None, the results will be yielded.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges","title":"join_node_attrs_to_edges","text":"<pre><code>join_node_attrs_to_edges(\n    node_attrs: DataFrame,\n    edge_attrs: DataFrame,\n    node_id_key: str = DEFAULT_ATTR_KEYS.NODE_ID,\n    source_key: str = DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n    target_key: str = DEFAULT_ATTR_KEYS.EDGE_TARGET,\n    source_prefix: str = \"source_\",\n    target_prefix: str = \"target_\",\n    how: JoinStrategy = \"left\",\n) -&gt; pl.DataFrame\n</code></pre> <p>Add node attributes to edge attributes by joining on the node ID.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Edge attributes with node attributes added.</p> </li> </ul> <p>Examples:</p> <pre><code>node_attrs = pl.DataFrame({\"node_id\": [1, 2, 3], \"a\": [1, 2, 3], \"b\": [4, 5, 6]})\nedge_attrs = pl.DataFrame({\"source\": [1, 2], \"target\": [2, 3]})\nnode_attr_to_edges(node_attrs, edge_attrs)\n# shape: (2, 5)\n# \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n# \u2502 source_a \u2506 source_b \u2506 target_a \u2506 target_b \u2506 source_node_id \u2506 target_node_id \u2502\n# \u2502 ---      \u2506 ---      \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---            \u2502\n# \u2502 i64      \u2506 i64      \u2506 i64      \u2506 i64      \u2506 i64            \u2506 i64            \u2502\n# \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n# \u2502 1        \u2506 4        \u2506 2        \u2506 5        \u2506 1              \u2506 2              \u2502\n# \u2502 2        \u2506 5        \u2506 3        \u2506 6        \u2506 2              \u2506 3              \u2502\n# \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> Source code in <code>src/tracksdata/functional/_edges.py</code> <pre><code>def join_node_attrs_to_edges(\n    node_attrs: pl.DataFrame,\n    edge_attrs: pl.DataFrame,\n    node_id_key: str = DEFAULT_ATTR_KEYS.NODE_ID,\n    source_key: str = DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n    target_key: str = DEFAULT_ATTR_KEYS.EDGE_TARGET,\n    source_prefix: str = \"source_\",\n    target_prefix: str = \"target_\",\n    how: JoinStrategy = \"left\",\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Add node attributes to edge attributes by joining on the node ID.\n\n    Parameters\n    ----------\n    node_attrs : pl.DataFrame\n        Node attributes.\n    edge_attrs : pl.DataFrame\n        Edge attributes.\n    node_id_key : str, optional\n        The key of the node ID column.\n    source_key : str, optional\n        The key of the source column.\n    target_key : str, optional\n        The key of the target column.\n    source_prefix : str, optional\n        The prefix of the source column.\n    target_prefix : str, optional\n        The prefix of the target column.\n    how : JoinStrategy, optional\n        The join type, where the \"left\" dataframe is the edge attributes and\n        the \"right\" dataframe is the node attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        Edge attributes with node attributes added.\n\n    Examples\n    --------\n    ```python\n    node_attrs = pl.DataFrame({\"node_id\": [1, 2, 3], \"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n    edge_attrs = pl.DataFrame({\"source\": [1, 2], \"target\": [2, 3]})\n    node_attr_to_edges(node_attrs, edge_attrs)\n    # shape: (2, 5)\n    # \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    # \u2502 source_a \u2506 source_b \u2506 target_a \u2506 target_b \u2506 source_node_id \u2506 target_node_id \u2502\n    # \u2502 ---      \u2506 ---      \u2506 ---      \u2506 ---      \u2506 ---            \u2506 ---            \u2502\n    # \u2502 i64      \u2506 i64      \u2506 i64      \u2506 i64      \u2506 i64            \u2506 i64            \u2502\n    # \u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n    # \u2502 1        \u2506 4        \u2506 2        \u2506 5        \u2506 1              \u2506 2              \u2502\n    # \u2502 2        \u2506 5        \u2506 3        \u2506 6        \u2506 2              \u2506 3              \u2502\n    # \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    ```\n    \"\"\"\n    node_attr_keys = node_attrs.columns\n    node_attr_keys.remove(node_id_key)\n\n    source_mapping = dict(zip(node_attr_keys, [f\"{source_prefix}{c}\" for c in node_attr_keys], strict=False))\n    target_mapping = dict(zip(node_attr_keys, [f\"{target_prefix}{c}\" for c in node_attr_keys], strict=False))\n\n    edge_attrs = edge_attrs.join(\n        node_attrs.select(node_id_key, *node_attr_keys).rename(source_mapping),\n        left_on=source_key,\n        right_on=node_id_key,\n        how=how,\n    ).join(\n        node_attrs.select(node_id_key, *node_attr_keys).rename(target_mapping),\n        left_on=target_key,\n        right_on=node_id_key,\n        how=how,\n    )\n\n    return edge_attrs\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(node_attrs)","title":"<code>node_attrs</code>","text":"(<code>DataFrame</code>)           \u2013            <p>Node attributes.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(edge_attrs)","title":"<code>edge_attrs</code>","text":"(<code>DataFrame</code>)           \u2013            <p>Edge attributes.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(node_id_key)","title":"<code>node_id_key</code>","text":"(<code>str</code>, default:                   <code>NODE_ID</code> )           \u2013            <p>The key of the node ID column.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(source_key)","title":"<code>source_key</code>","text":"(<code>str</code>, default:                   <code>EDGE_SOURCE</code> )           \u2013            <p>The key of the source column.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(target_key)","title":"<code>target_key</code>","text":"(<code>str</code>, default:                   <code>EDGE_TARGET</code> )           \u2013            <p>The key of the target column.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(source_prefix)","title":"<code>source_prefix</code>","text":"(<code>str</code>, default:                   <code>'source_'</code> )           \u2013            <p>The prefix of the source column.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(target_prefix)","title":"<code>target_prefix</code>","text":"(<code>str</code>, default:                   <code>'target_'</code> )           \u2013            <p>The prefix of the target column.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.join_node_attrs_to_edges(how)","title":"<code>how</code>","text":"(<code>JoinStrategy</code>, default:                   <code>'left'</code> )           \u2013            <p>The join type, where the \"left\" dataframe is the edge attributes and the \"right\" dataframe is the node attributes.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict","title":"rx_digraph_to_napari_dict","text":"<pre><code>rx_digraph_to_napari_dict(\n    tracklet_graph: PyDiGraph,\n) -&gt; dict[int, list[int]]\n</code></pre> <p>Convert a tracklet graph to a napari-ready dictionary. The input is a (child -&gt; parent) graph (forward in time) and it is converted to a (parent -&gt; child) dictionary (backward in time).</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict--parameters","title":"Parameters","text":"<p>tracklet_graph : rx.PyDiGraph     The tracklet graph to convert.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.rx_digraph_to_napari_dict--returns","title":"Returns","text":"<p>dict[int, list[int]]     A dictionary of parent -&gt; child relationships.</p> Source code in <code>src/tracksdata/functional/_napari.py</code> <pre><code>def rx_digraph_to_napari_dict(\n    tracklet_graph: rx.PyDiGraph,\n) -&gt; dict[int, list[int]]:\n    \"\"\"\n    Convert a tracklet graph to a napari-ready dictionary.\n    The input is a (child -&gt; parent) graph (forward in time) and it is converted\n    to a (parent -&gt; child) dictionary (backward in time).\n\n    Parameters\n    ----------\n    tracklet_graph : rx.PyDiGraph\n        The tracklet graph to convert.\n\n    Returns\n    -------\n    dict[int, list[int]]\n        A dictionary of parent -&gt; child relationships.\n    \"\"\"\n    dict_graph = {}\n    for parent, child in tracklet_graph.edges():\n        dict_graph.setdefault(child, []).append(parent)\n    return dict_graph\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format","title":"to_napari_format","text":"<pre><code>to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...] | None,\n    solution_key: str | None,\n    output_tracklet_id_key: str,\n    mask_key: None,\n) -&gt; tuple[pl.DataFrame, dict[int, int]]\n</code></pre><pre><code>to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...] | None,\n    solution_key: str | None,\n    output_tracklet_id_key: str,\n    mask_key: str,\n) -&gt; tuple[pl.DataFrame, dict[int, int], GraphArrayView]\n</code></pre> <pre><code>to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...] | None = None,\n    solution_key: str | None = DEFAULT_ATTR_KEYS.SOLUTION,\n    output_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    mask_key: str | None = None,\n    chunk_shape: tuple[int] | None = None,\n    buffer_cache_size: int | None = None,\n) -&gt; (\n    tuple[pl.DataFrame, dict[int, int], GraphArrayView]\n    | tuple[pl.DataFrame, dict[int, int]]\n)\n</code></pre> <p>Convert the subgraph of solution nodes to a napari-ready format.</p> <p>This includes: - a tracks layer with the solution tracks - a graph with the parent-child relationships for the solution tracks - a labels layer with the solution nodes if <code>mask_key</code> is provided.</p> <p>IMPORTANT: This function will reset the track ids if they already exist.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>labels = ...\ngraph = ...\ntracks_data, dict_graph, array_view = to_napari_format(graph, labels.shape, mask_key=\"mask\")\n</code></pre> <p>Returns:</p> <ul> <li> <code>tuple[DataFrame, dict[int, int], GraphArrayView] | tuple[DataFrame, dict[int, int]]</code>           \u2013            <ul> <li>tracks_data: The tracks data as a polars DataFrame.</li> <li>dict_graph: A dictionary of parent -&gt; child relationships.</li> <li>array_view: The array view of the solution graph if <code>mask_key</code> is provided.</li> </ul> </li> </ul> Source code in <code>src/tracksdata/functional/_napari.py</code> <pre><code>def to_napari_format(\n    graph: BaseGraph,\n    shape: tuple[int, ...] | None = None,\n    solution_key: str | None = DEFAULT_ATTR_KEYS.SOLUTION,\n    output_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    mask_key: str | None = None,\n    chunk_shape: tuple[int] | None = None,\n    buffer_cache_size: int | None = None,\n) -&gt; (\n    tuple[\n        pl.DataFrame,\n        dict[int, int],\n        \"GraphArrayView\",\n    ]\n    | tuple[\n        pl.DataFrame,\n        dict[int, int],\n    ]\n):\n    \"\"\"\n    Convert the subgraph of solution nodes to a napari-ready format.\n\n    This includes:\n    - a tracks layer with the solution tracks\n    - a graph with the parent-child relationships for the solution tracks\n    - a labels layer with the solution nodes if `mask_key` is provided.\n\n    IMPORTANT: This function will reset the track ids if they already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to convert.\n    shape : tuple[int, ...] | None, optional\n        The shape of the labels layer. If None, the shape is inferred from the graph metadata `shape` key.\n    solution_key : str, optional\n        The key of the solution attribute. If None, the graph is not filtered by the solution attribute.\n    output_tracklet_id_key : str, optional\n        The key of the output track id attribute.\n    mask_key : str | None, optional\n        The key of the mask attribute.\n    chunk_shape : tuple[int] | None, optional\n        The chunk shape for the labels layer. If None, the default chunk size is used.\n    buffer_cache_size : int, optional\n        The maximum number of buffers to keep in the cache for the labels layer.\n        If None, the default buffer cache size is used.\n\n    Examples\n    --------\n\n    ```python\n    labels = ...\n    graph = ...\n    tracks_data, dict_graph, array_view = to_napari_format(graph, labels.shape, mask_key=\"mask\")\n    ```\n\n    Returns\n    -------\n    tuple[pl.DataFrame, dict[int, int], GraphArrayView] | tuple[pl.DataFrame, dict[int, int]]\n        - tracks_data: The tracks data as a polars DataFrame.\n        - dict_graph: A dictionary of parent -&gt; child relationships.\n        - array_view: The array view of the solution graph if `mask_key` is provided.\n    \"\"\"\n    if solution_key is not None:\n        solution_graph = graph.filter(\n            NodeAttr(solution_key) == True,\n            EdgeAttr(solution_key) == True,\n        ).subgraph()\n\n    else:\n        solution_graph = graph\n\n    shape = _validate_shape(shape, solution_graph, \"to_napari_format\")\n\n    tracks_graph = solution_graph.assign_tracklet_ids(output_tracklet_id_key)\n    dict_graph = {tracks_graph[child]: tracks_graph[parent] for parent, child in tracks_graph.edge_list()}\n\n    spatial_cols = [\"z\", \"y\", \"x\"][-len(shape) + 1 :]\n\n    tracks_data = solution_graph.node_attrs(\n        attr_keys=[output_tracklet_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols],\n    )\n\n    # sorting columns\n    tracks_data = tracks_data.select([output_tracklet_id_key, DEFAULT_ATTR_KEYS.T, *spatial_cols])\n\n    if mask_key is not None:\n        from tracksdata.array._graph_array import GraphArrayView\n\n        array_view = GraphArrayView(\n            solution_graph,\n            shape=shape,\n            attr_key=output_tracklet_id_key,\n            chunk_shape=chunk_shape,\n            buffer_cache_size=buffer_cache_size,\n        )\n\n        return tracks_data, dict_graph, array_view\n\n    return tracks_data, dict_graph\n</code></pre>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to convert.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the labels layer. If None, the shape is inferred from the graph metadata <code>shape</code> key.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(solution_key)","title":"<code>solution_key</code>","text":"(<code>str</code>, default:                   <code>SOLUTION</code> )           \u2013            <p>The key of the solution attribute. If None, the graph is not filtered by the solution attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(output_tracklet_id_key)","title":"<code>output_tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(mask_key)","title":"<code>mask_key</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The key of the mask attribute.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The chunk shape for the labels layer. If None, the default chunk size is used.</p>"},{"location":"reference/tracksdata/functional/#tracksdata.functional.to_napari_format(buffer_cache_size)","title":"<code>buffer_cache_size</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of buffers to keep in the cache for the labels layer. If None, the default buffer cache size is used.</p>"},{"location":"reference/tracksdata/graph/","title":"graph","text":""},{"location":"reference/tracksdata/graph/#tracksdata.graph","title":"tracksdata.graph","text":"<p>Graph backends for representing tracking data as directed graphs in memory or on disk.</p> <p>Modules:</p> <ul> <li> <code>filters</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>Base class for a graph backend.</p> </li> <li> <code>GraphView</code>           \u2013            <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> </li> <li> <code>IndexedRXGraph</code>           \u2013            <p>A graph with arbitrary node indices.</p> </li> <li> <code>RustWorkXGraph</code>           \u2013            <p>High-performance in-memory graph implementation using rustworkx.</p> </li> <li> <code>SQLGraph</code>           \u2013            <p>SQL-based graph implementation using SQLAlchemy ORM.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph","title":"BaseGraph","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              tracksdata.graph.BaseGraph[BaseGraph]\n\n              \n\n              click tracksdata.graph.BaseGraph href \"\" \"tracksdata.graph.BaseGraph\"\n            </code></pre> <p>Base class for a graph backend.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>assign_tracklet_ids</code>             \u2013              <p>Compute and assign track ids to nodes.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>filter</code>             \u2013              <p>Creates a filter object that can be used to create a subgraph or query ids and attributes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a pandas DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_edge</code>             \u2013              <p>Remove an edge from the graph.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>to_traccuracy_graph</code>             \u2013              <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>tracklet_nodes</code>             \u2013              <p>Compute the non-branching tracklets around the provided seed node_ids.</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> <li> <code>supports_custom_indices</code>               (<code>bool</code>)           \u2013            <p>Whether the graph backend supports custom indices.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attr_keys","title":"edge_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attr_keys","title":"node_attr_keys  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_edges","title":"num_edges  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.num_nodes","title":"num_nodes  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.supports_custom_indices","title":"supports_custom_indices  <code>property</code>","text":"<pre><code>supports_custom_indices: bool\n</code></pre> <p>Whether the graph backend supports custom indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys() and ref_key != DEFAULT_ATTR_KEYS.NODE_ID:\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge","title":"add_edge  <code>abstractmethod</code>","text":"<pre><code>add_edge(\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added edge.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n\n    Returns\n    -------\n    int\n        The ID of the added edge.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_edge_attr_key","title":"add_edge_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node","title":"add_node  <code>abstractmethod</code>","text":"<pre><code>add_node(\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added node.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    index : int | None\n        Optional node index/ID to use. If None, the backend will assign\n        an appropriate ID. Only supported by certain backends (e.g., SQLGraph).\n\n    Returns\n    -------\n    int\n        The ID of the added node.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional node index/ID to use. If None, the backend will assign an appropriate ID. Only supported by certain backends (e.g., SQLGraph).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_node_attr_key","title":"add_node_attr_key  <code>abstractmethod</code>","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    raise NotImplementedError(f\"{self.__class__.__name__} backend does not support overlaps.\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids","title":"assign_tracklet_ids  <code>abstractmethod</code>","text":"<pre><code>assign_tracklet_ids(\n    output_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reset: bool = True,\n    tracklet_id_offset: int | None = None,\n    node_ids: list[int] | None = None,\n    return_id_update: Literal[False] = False,\n) -&gt; rx.PyDiGraph\n</code></pre><pre><code>assign_tracklet_ids(\n    output_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reset: bool = True,\n    tracklet_id_offset: int | None = None,\n    node_ids: list[int] | None = None,\n    return_id_update: Literal[True] = True,\n) -&gt; tuple[rx.PyDiGraph, pl.DataFrame]\n</code></pre> <pre><code>assign_tracklet_ids(\n    output_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reset: bool = True,\n    tracklet_id_offset: int | None = None,\n    node_ids: list[int] | None = None,\n    return_id_update: bool = False,\n) -&gt; rx.PyDiGraph | tuple[rx.PyDiGraph, pl.DataFrame]\n</code></pre> <p>Compute and assign track ids to nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed graph (parent -&gt; child) with track ids lineage relationships. If node_ids is provided, it will only include linages including those nodes.</p> </li> <li> <code>DataFrame</code>           \u2013            <p>A DataFrame with the updated node ids and their previous and assigned track ids. This has columns \"node_id\", f\"{output_key}\", and f\"{output_key}_new\". Only returned if return_id_update is True.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef assign_tracklet_ids(\n    self,\n    output_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reset: bool = True,\n    tracklet_id_offset: int | None = None,\n    node_ids: list[int] | None = None,\n    return_id_update: bool = False,\n) -&gt; rx.PyDiGraph | tuple[rx.PyDiGraph, pl.DataFrame]:\n    \"\"\"\n    Compute and assign track ids to nodes.\n    Parameters\n    ----------\n    output_key : str\n        The key of the output track id attribute.\n    reset : bool\n        Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.\n    tracklet_id_offset : int | None\n        The starting track id, useful when assigning track ids to a subgraph.\n        If None, the track ids will start from 1 or from the maximum existing track id + 1\n        if the output_key already exists and reset is False.\n    node_ids : list[int] | None\n        The node ids to assign track ids to. If None, all nodes are used.\n    return_id_update : bool\n        Whether to return a DataFrame with the updated node ids and their previous and assigned track ids.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed graph (parent -&gt; child) with track ids lineage relationships.\n        If node_ids is provided, it will only include linages including those nodes.\n    pl.DataFrame\n        A DataFrame with the updated node ids and their previous and assigned track ids.\n        This has columns \"node_id\", f\"{output_key}\", and f\"{output_key}_new\".\n        Only returned if return_id_update is True.\n    \"\"\"\n    raise NotImplementedError(f\"{self.__class__.__name__} backend does not support track id assignment.\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the output track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids(tracklet_id_offset)","title":"<code>tracklet_id_offset</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The starting track id, useful when assigning track ids to a subgraph. If None, the track ids will start from 1 or from the maximum existing track id + 1 if the output_key already exists and reset is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to assign track ids to. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.assign_tracklet_ids(return_id_update)","title":"<code>return_id_update</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return a DataFrame with the updated node ids and their previous and assigned track ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    cache_key = (frame_attr_key, bbox_attr_key)\n    if not hasattr(self, \"_bbox_spatial_filter_cache\") or clear_cache:\n        self._bbox_spatial_filter_cache: dict[tuple[str | None, str], BBoxSpatialFilter] = {}\n\n    if cache_key not in self._bbox_spatial_filter_cache:\n        self._bbox_spatial_filter_cache[cache_key] = BBoxSpatialFilter(\n            self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key\n        )\n    return self._bbox_spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bbox_spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: Literal[False]\n) -&gt; None\n</code></pre><pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: Literal[True]\n) -&gt; list[int]\n</code></pre> <pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: bool = False\n) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # this method benefits the SQLGraph backend\n    if return_ids:\n        edge_ids = []\n        for edge in edges:\n            edge_ids.append(\n                self.add_edge(\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n                    edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n                    edge,\n                    validate_keys=False,\n                )\n            )\n        return edge_ids\n\n    # avoiding many ifs and appends\n    for edge in edges:\n        self.add_edge(\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n            edge.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET),\n            edge,\n            validate_keys=False,\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n    indices : list[int] | None\n        Optional list of node indices/IDs to use. If None, the backend will assign\n        appropriate IDs. Only supported by certain backends (e.g., SQLGraph).\n        Must be the same length as nodes if provided.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    # this method benefits the SQLGraph backend\n    if indices is None:\n        return [self.add_node(node, validate_keys=False) for node in nodes]\n    else:\n        return [\n            self.add_node(node, validate_keys=False, index=idx) for node, idx in zip(nodes, indices, strict=True)\n        ]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of node indices/IDs to use. If None, the backend will assign appropriate IDs. Only supported by certain backends (e.g., SQLGraph). Must be the same length as nodes if provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs","title":"edge_attrs  <code>abstractmethod</code>","text":"<pre><code>edge_attrs(\n    *,\n    attr_keys: Sequence[str] | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_id","title":"edge_id  <code>abstractmethod</code>","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.edge_ids","title":"edge_ids  <code>abstractmethod</code>","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter","title":"filter  <code>abstractmethod</code>","text":"<pre><code>filter(\n    *attr_filters: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n    include_targets: bool = False,\n    include_sources: bool = False,\n) -&gt; BaseFilter\n</code></pre> <p>Creates a filter object that can be used to create a subgraph or query ids and attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter object that can be used to create a subgraph or query attributes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef filter(\n    self,\n    *attr_filters: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n    include_targets: bool = False,\n    include_sources: bool = False,\n) -&gt; \"BaseFilter\":\n    \"\"\"\n    Creates a filter object that can be used to create a subgraph or query ids and attributes.\n\n    Parameters\n    ----------\n    *attr_filters : AttrComparison\n        The attributes to filter the nodes by.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n    include_targets : bool\n        Whether to include edges out-going from the given node_ids even\n        if the target node is not in the given node_ids.\n    include_sources : bool\n        Whether to include edges incoming to the given node_ids even\n        if the source node is not in the given node_ids.\n\n    Returns\n    -------\n    BaseFilter\n        A filter object that can be used to create a subgraph or query attributes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(*attr_filters)","title":"<code>*attr_filters</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter the nodes by.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(include_targets)","title":"<code>include_targets</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges out-going from the given node_ids even if the target node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.filter(include_sources)","title":"<code>include_sources</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include edges incoming to the given node_ids even if the source node is not in the given node_ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. tracklet_ids : np.ndarray | None     Track ids of the nodes if available. tracklet_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    tracklet_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    tracklet_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        tracklet_ids=tracklet_ids,\n        tracklet_id_graph=tracklet_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> <li> <code>geff_metadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The geff metadata of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    geff_read_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `geff.read` function.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    geff_metadata : GeffMetadata\n        The geff metadata of the graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    if geff_read_kwargs is None:\n        geff_read_kwargs = {}\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, geff_metadata = geff.read(geff_store, backend=\"rustworkx\", **geff_read_kwargs)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    node_id_map = rx_graph.attrs[\"to_rx_id_map\"]\n    rx_graph.attrs = {\"geff\": rx_graph.attrs, **rx_graph.attrs[\"extra\"].pop(\"tracksdata\", {})}\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=node_id_map,\n        **kwargs,\n    )\n\n    if DEFAULT_ATTR_KEYS.MASK in indexed_graph.node_attr_keys:\n        from tracksdata.nodes._mask import Mask\n\n        # unsafe operation, changing graph content inplace\n        for node_attr in indexed_graph.rx_graph.nodes():\n            node_attr[DEFAULT_ATTR_KEYS.MASK] = Mask(\n                node_attr[DEFAULT_ATTR_KEYS.MASK].astype(bool),\n                bbox=node_attr[DEFAULT_ATTR_KEYS.BBOX],\n            )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph, geff_metadata\n\n    return cls.from_other(indexed_graph, **kwargs), geff_metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff(geff_read_kwargs)","title":"<code>geff_read_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>geff.read</code> function.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            first_value = node_attrs[col].first()\n            graph.add_node_attr_key(col, infer_default_value(first_value))\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.has_edge","title":"has_edge  <code>abstractmethod</code>","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.in_degree","title":"in_degree  <code>abstractmethod</code>","text":"<pre><code>in_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>in_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>in_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match","title":"match","text":"<pre><code>match(\n    other: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs","title":"node_attrs  <code>abstractmethod</code>","text":"<pre><code>node_attrs(\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a pandas DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a pandas DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributes into multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributes into multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.node_ids","title":"node_ids  <code>abstractmethod</code>","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.out_degree","title":"out_degree  <code>abstractmethod</code>","text":"<pre><code>out_degree(node_ids: int) -&gt; int\n</code></pre><pre><code>out_degree(node_ids: list[int] | None = None) -&gt; list[int]\n</code></pre> <pre><code>out_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    return []\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors","title":"predecessors  <code>abstractmethod</code>","text":"<pre><code>predecessors(\n    node_ids: int,\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[True],\n) -&gt; pl.DataFrame\n</code></pre><pre><code>predecessors(\n    node_ids: list[int],\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[True],\n) -&gt; dict[int, pl.DataFrame]\n</code></pre><pre><code>predecessors(\n    node_ids: int,\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[False] = False,\n) -&gt; list[int]\n</code></pre><pre><code>predecessors(\n    node_ids: list[int],\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[False] = False,\n) -&gt; dict[int, list[int]]\n</code></pre> <pre><code>predecessors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return node attributes in a `polars.DataFrame`. When False only\n        the predecessor node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.predecessors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return node attributes in a <code>polars.DataFrame</code>. When False only the predecessor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_edge","title":"remove_edge  <code>abstractmethod</code>","text":"<pre><code>remove_edge(\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an edge from the graph.</p> <p>Either provide <code>edge_id</code> to remove by edge identifier, or provide both <code>source_id</code> and <code>target_id</code> to remove by endpoints.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the specified edge does not exist or insufficient identifiers are provided.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef remove_edge(\n    self,\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an edge from the graph.\n\n    Either provide `edge_id` to remove by edge identifier, or\n    provide both `source_id` and `target_id` to remove by endpoints.\n\n    Parameters\n    ----------\n    source_id : int | None\n        The ID of the source node (when removing by endpoints).\n    target_id : int | None\n        The ID of the target node (when removing by endpoints).\n    edge_id : int | None\n        The ID of the edge to delete (when removing by ID).\n\n    Raises\n    ------\n    ValueError\n        If the specified edge does not exist or insufficient identifiers are provided.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the source node (when removing by endpoints).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the target node (when removing by endpoints).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_edge(edge_id)","title":"<code>edge_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The ID of the edge to delete (when removing by ID).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_node","title":"remove_node  <code>abstractmethod</code>","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges).</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges).\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(\n    attr_keys: list[str] | None = None,\n    clear_cache: bool = False,\n) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None, clear_cache: bool = False) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    cache_key = None if attr_keys is None else tuple(attr_keys)\n    if not hasattr(self, \"_spatial_filter_cache\") or clear_cache:\n        self._spatial_filter_cache: dict[tuple[str, ...] | None, SpatialFilter] = {}\n\n    if cache_key not in self._spatial_filter_cache:\n        self._spatial_filter_cache[cache_key] = SpatialFilter(self, attr_keys=attr_keys)\n\n    return self._spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors","title":"successors  <code>abstractmethod</code>","text":"<pre><code>successors(\n    node_ids: int,\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[True],\n) -&gt; pl.DataFrame\n</code></pre><pre><code>successors(\n    node_ids: list[int],\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[True],\n) -&gt; dict[int, pl.DataFrame]\n</code></pre><pre><code>successors(\n    node_ids: int,\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[False] = False,\n) -&gt; list[int]\n</code></pre><pre><code>successors(\n    node_ids: list[int],\n    attr_keys: Sequence[str] | str | None = ...,\n    *,\n    return_attrs: Literal[False] = False,\n) -&gt; dict[int, list[int]]\n</code></pre> <pre><code>successors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return node attributes in a `polars.DataFrame`. When False only\n        the successor node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.successors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return node attributes in a <code>polars.DataFrame</code>. When False only the successor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary","title":"summary","text":"<pre><code>summary(\n    attrs_stats: bool = False, print_summary: bool = True\n) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.time_points","title":"time_points  <code>abstractmethod</code>","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--parameters","title":"Parameters","text":"<p>output_dir : str | Path     The directory to save the graph to. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_tracklet_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        The directory to save the graph to.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_tracklet_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        tracklet_id_key=tracklet_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: geff.GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: tracklet_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n    node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy()\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACKLET_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACKLET_ID,\n            }\n        else:\n            track_node_props = None\n\n        node_props_metadata = {\n            k: PropMetadata(\n                identifier=k,\n                dtype=polars_dtype_to_numpy_dtype(v.dtype) if k != DEFAULT_ATTR_KEYS.MASK else np.uint64,\n                varlength=k == DEFAULT_ATTR_KEYS.MASK,\n            )\n            for k, v in node_attrs.to_dict().items()\n        }\n        edge_props_metadata = {\n            k: PropMetadata(identifier=k, dtype=polars_dtype_to_numpy_dtype(v.dtype))\n            for k, v in edge_attrs.to_dict().items()\n        }\n\n        td_metadata = self.metadata.copy()\n        td_metadata.pop(\"geff\", None)  # avoid geff being written multiple times\n\n        geff_metadata = geff.GeffMetadata(\n            directed=True,\n            axes=axes,\n            node_props_metadata=node_props_metadata,\n            edge_props_metadata=edge_props_metadata,\n            track_node_props=track_node_props,\n            extra={\n                \"tracksdata\": td_metadata,\n            },\n        )\n\n    node_dict = {\n        k: {\"values\": column_to_numpy(v), \"missing\": None}\n        for k, v in node_attrs.to_dict().items()\n        if k != DEFAULT_ATTR_KEYS.MASK\n    }\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_dict[DEFAULT_ATTR_KEYS.MASK] = construct_var_len_props(\n            [mask.mask.astype(np.uint64) for mask in node_attrs[DEFAULT_ATTR_KEYS.MASK]]\n        )\n\n    edge_dict = {k: {\"values\": column_to_numpy(v), \"missing\": None} for k, v in edge_attrs.to_dict().items()}\n\n    write_arrays(\n        geff_store,\n        node_ids=node_ids.astype(np.uint64),\n        node_props=node_dict,\n        edge_ids=edge_ids.astype(np.uint64),\n        edge_props=edge_dict,\n        metadata=geff_metadata,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: tracklet_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_traccuracy_graph","title":"to_traccuracy_graph","text":"<pre><code>to_traccuracy_graph(\n    array_view_kwargs: dict[str, Any] | None = None,\n) -&gt; TrackingGraph\n</code></pre> <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TrackingGraph</code>           \u2013            <p>A traccuracy graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_traccuracy_graph(self, array_view_kwargs: dict[str, Any] | None = None) -&gt; \"TrackingGraph\":\n    \"\"\"\n    Convert the graph to a `traccuracy.TrackingGraph`.\n\n    Parameters\n    ----------\n    array_view_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `GraphArrayView` constructor used to create the segmentation.\n\n    Returns\n    -------\n    TrackingGraph\n        A traccuracy graph.\n    \"\"\"\n    from tracksdata.metrics._traccuracy import to_traccuracy_graph\n\n    return to_traccuracy_graph(self, array_view_kwargs=array_view_kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.to_traccuracy_graph(array_view_kwargs)","title":"<code>array_view_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>GraphArrayView</code> constructor used to create the segmentation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    tracklet_id_key : str\n        The key of the track id attribute.\n    ignore_tracklet_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n    from tracksdata.functional._edges import join_node_attrs_to_edges\n\n    if tracklet_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{tracklet_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, tracklet_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_tracklet_id is not None:\n        nodes_df = nodes_df.filter(pl.col(tracklet_id_key) != ignore_tracklet_id)\n\n    track_ids = nodes_df[tracklet_id_key].unique().to_list()\n    tracklet_graph = rx.PyDiGraph()\n\n    rx_ids = np.asarray(tracklet_graph.add_nodes_from(track_ids), dtype=int)\n    track_id_to_rx_id = dict(zip(track_ids, rx_ids, strict=True))\n\n    src_col = f\"source_{tracklet_id_key}\"\n    tgt_col = f\"target_{tracklet_id_key}\"\n\n    edges_df = (\n        join_node_attrs_to_edges(\n            nodes_df,\n            edges_df,\n            how=\"right\",\n        )\n        .filter(pl.col(src_col) != pl.col(tgt_col))\n        .with_columns(\n            pl.col(src_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"source_rx_id\"),\n            pl.col(tgt_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"target_rx_id\"),\n        )\n    )\n\n    tracklet_graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[src_col].to_list(), edges_df[tgt_col].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return tracklet_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph(tracklet_id_key)","title":"<code>tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_graph(ignore_tracklet_id)","title":"<code>ignore_tracklet_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_nodes","title":"tracklet_nodes","text":"<pre><code>tracklet_nodes(seeds: list[int] | None) -&gt; list[int]\n</code></pre> <p>Compute the non-branching tracklets around the provided seed node_ids.</p> <p>Walks forward to successors only through nodes with exactly one successor, and backward to predecessors that also have out_degree == 1, until closure.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>Sorted unique node IDs forming the closure.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_nodes(self, seeds: list[int] | None) -&gt; list[int]:\n    \"\"\"\n    Compute the non-branching tracklets around the provided seed node_ids.\n\n    Walks forward to successors only through nodes with exactly one successor,\n    and backward to predecessors that also have out_degree == 1, until closure.\n\n    Parameters\n    ----------\n    seeds : list[int]\n        Seed node IDs where to start the closure.\n\n    Returns\n    -------\n    list[int]\n        Sorted unique node IDs forming the closure.\n    \"\"\"\n    # NOTE: if this function becomes a bottleneck in the future it might be worth having\n    # a specialized version per backend\n    if seeds is None or len(seeds) == 0:\n        return []\n\n    track_node_ids: set[int] = set()\n    active_ids: set[int] = set(seeds)\n\n    while len(active_ids) &gt; 0:\n        track_node_ids.update(active_ids)\n\n        # Successors: only nodes with exactly one successor\n        succ_map = self.successors(node_ids=list(active_ids))\n        successors = [int(nodes[0]) for nodes in succ_map.values() if len(nodes) == 1]\n\n        # Predecessors: only nodes with exactly one predecessor and predecessor out_degree == 1\n        pred_map = self.predecessors(node_ids=list(active_ids))\n        predecessors = [int(nodes[0]) for nodes in pred_map.values() if len(nodes) == 1]\n\n        if len(predecessors) &gt; 0:\n            out_degrees = self.out_degree(predecessors)\n            if isinstance(out_degrees, int):\n                out_degrees = [out_degrees]\n            predecessors = [node for node, degree in zip(predecessors, out_degrees, strict=True) if degree == 1]\n\n        active_ids = (set(successors) | set(predecessors)) - track_node_ids\n\n    return sorted(track_node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.tracklet_nodes(seeds)","title":"<code>seeds</code>","text":"(<code>list[int]</code>)           \u2013            <p>Seed node IDs where to start the closure.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs","title":"update_edge_attrs  <code>abstractmethod</code>","text":"<pre><code>update_edge_attrs(\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs","title":"update_node_attrs  <code>abstractmethod</code>","text":"<pre><code>update_node_attrs(\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@abc.abstractmethod\ndef update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.BaseGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView","title":"GraphView","text":"<pre><code>GraphView(\n    rx_graph: PyDiGraph,\n    node_map_to_root: dict[int, int],\n    root: BaseGraph,\n    sync: bool = True,\n    *,\n    node_attr_keys: list[str] | None = None,\n    edge_attr_keys: list[str] | None = None,\n)\n</code></pre> <p>               Bases: <code>RustWorkXGraph</code>, <code>MappedGraphMixin</code></p> <pre><code>\n              flowchart TD\n              tracksdata.graph.GraphView[GraphView]\n              tracksdata.graph._rustworkx_graph.RustWorkXGraph[RustWorkXGraph]\n              tracksdata.graph._base_graph.BaseGraph[BaseGraph]\n              tracksdata.graph._mapped_graph_mixin.MappedGraphMixin[MappedGraphMixin]\n\n                              tracksdata.graph._rustworkx_graph.RustWorkXGraph --&gt; tracksdata.graph.GraphView\n                                tracksdata.graph._base_graph.BaseGraph --&gt; tracksdata.graph._rustworkx_graph.RustWorkXGraph\n                \n\n                tracksdata.graph._mapped_graph_mixin.MappedGraphMixin --&gt; tracksdata.graph.GraphView\n                \n\n\n              click tracksdata.graph.GraphView href \"\" \"tracksdata.graph.GraphView\"\n              click tracksdata.graph._rustworkx_graph.RustWorkXGraph href \"\" \"tracksdata.graph._rustworkx_graph.RustWorkXGraph\"\n              click tracksdata.graph._base_graph.BaseGraph href \"\" \"tracksdata.graph._base_graph.BaseGraph\"\n              click tracksdata.graph._mapped_graph_mixin.MappedGraphMixin href \"\" \"tracksdata.graph._mapped_graph_mixin.MappedGraphMixin\"\n            </code></pre> <p>A filtered view of a graph that maintains bidirectional mapping to the root graph.</p> <p>GraphView provides a lightweight way to work with subsets of a larger graph while maintaining the ability to synchronize changes back to the original graph. It acts as a view layer that maps between local node/edge IDs and the root graph's IDs, enabling efficient subgraph operations with minimal data duplication.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>_local_to_external</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from local node IDs to external node IDs (via MappedGraphMixin).</p> </li> <li> <code>_external_to_local</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from external node IDs to local node IDs (via MappedGraphMixin).</p> </li> <li> <code>_edge_map_to_root</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from view edge IDs to root graph edge IDs.</p> </li> <li> <code>_edge_map_from_root</code>               (<code>bidict[int, int]</code>)           \u2013            <p>Mapping from root graph edge IDs to view edge IDs.</p> </li> </ul> See Also <p>RustWorkXGraph:     The base graph implementation that this view extends.</p> <p>SQLGraph:     Database-backed graph implementation for larger datasets.</p> <p>Examples:</p> <p>Create a subgraph view filtered by time:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nview = graph.filter(NodeAttr(\"t\") == 5).subgraph()\n</code></pre> <p>Access nodes in the view:</p> <pre><code>node_ids = view.node_ids()\nnode_attrs = view.node_attrs(node_ids=node_ids)\n</code></pre> <p>The view automatically maps between local and root IDs when needed.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Not supported for <code>GraphView</code>.</p> </li> <li> <code>detach</code>             \u2013              <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>remove_edge</code>             \u2013              <p>Remove an edge by ID or by endpoints in both the root and (if present) the view.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>to_traccuracy_graph</code>             \u2013              <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>tracklet_nodes</code>             \u2013              <p>Compute the non-branching tracklets around the provided seed node_ids.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def __init__(\n    self,\n    rx_graph: rx.PyDiGraph,\n    node_map_to_root: dict[int, int],\n    root: BaseGraph,\n    sync: bool = True,\n    *,\n    node_attr_keys: list[str] | None = None,\n    edge_attr_keys: list[str] | None = None,\n) -&gt; None:\n    # Initialize RustWorkXGraph\n    RustWorkXGraph.__init__(self, rx_graph=None)  # rx_graph is not used to avoid initialization\n    self._graph = rx_graph\n\n    # Initialize MappedGraphMixin\n    MappedGraphMixin.__init__(self, node_map_to_root)\n\n    # Setting up the time_to_nodes mapping (this was removed accidentally)\n    for idx in rx_graph.node_indices():\n        t = self.rx_graph[idx][DEFAULT_ATTR_KEYS.T]\n        self._time_to_nodes.setdefault(t, []).append(idx)\n\n    # Set up edge mapping (nodes handled by mixin)\n    self._edge_map_to_root: bidict.bidict[int, int] = bidict.bidict(\n        (idx, data[DEFAULT_ATTR_KEYS.EDGE_ID]) for idx, (_, _, data) in self.rx_graph.edge_index_map().items()\n    )\n    self._edge_map_from_root = self._edge_map_to_root.inverse\n\n    self._root = root\n    self._is_root_rx_graph = isinstance(root, RustWorkXGraph)\n    self._sync = sync\n    self._out_of_sync = False\n\n    # Existing for API compatibility for the SQLGraph generating GraphView,\n    # but RXGraph always uses the root graph's attributes and just filtering them\n    self._node_attr_keys = node_attr_keys\n    self._edge_attr_keys = edge_attr_keys\n\n    # use parent graph overlaps\n    self._overlaps = None\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(rx_graph)","title":"<code>rx_graph</code>","text":"(<code>PyDiGraph</code>)           \u2013            <p>The rustworkx graph object representing the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(node_map_to_root)","title":"<code>node_map_to_root</code>","text":"(<code>dict[int, int]</code>)           \u2013            <p>Mapping from local node IDs to root graph node IDs.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(root)","title":"<code>root</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>Reference to the root graph that this view is derived from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView(sync)","title":"<code>sync</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to automatically synchronize changes in the view. By default only the root graph is updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping","title":"_add_id_mapping","text":"<pre><code>_add_id_mapping(local_id: int, external_id: int) -&gt; None\n</code></pre> <p>Add a new ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mapping(self, local_id: int, external_id: int) -&gt; None:\n    \"\"\"\n    Add a new ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID\n    external_id : int\n        External node ID\n    \"\"\"\n    try:\n        self._local_to_external.put(local_id, external_id)\n    except bidict.ValueDuplicationError as e:\n        # Convert ValueDuplicationError to KeyDuplicationError since from user perspective\n        # the external_id (their \"key\"/index) is what's being duplicated\n        raise bidict.KeyDuplicationError(e.args[0]) from e\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>)           \u2013            <p>Local node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>)           \u2013            <p>External node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mappings","title":"_add_id_mappings","text":"<pre><code>_add_id_mappings(\n    mappings: Sequence[tuple[int, int]],\n) -&gt; None\n</code></pre> <p>Add multiple ID mappings at once.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mappings(self, mappings: Sequence[tuple[int, int]]) -&gt; None:\n    \"\"\"\n    Add multiple ID mappings at once.\n\n    Parameters\n    ----------\n    mappings : Sequence[tuple[int, int]]\n        Sequence of (local_id, external_id) pairs\n    \"\"\"\n    self._local_to_external.putall(mappings)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._add_id_mappings(mappings)","title":"<code>mappings</code>","text":"(<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>Sequence of (local_id, external_id) pairs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._get_external_ids","title":"_get_external_ids","text":"<pre><code>_get_external_ids() -&gt; list[int]\n</code></pre> <p>Get all external IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all external node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_external_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all external IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all external node IDs\n    \"\"\"\n    return list(self._local_to_external.values())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._get_local_ids","title":"_get_local_ids","text":"<pre><code>_get_local_ids() -&gt; list[int]\n</code></pre> <p>Get all local IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all local node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_local_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all local IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all local node IDs\n    \"\"\"\n    return list(self._local_to_external.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external","title":"_map_df_to_external","text":"<pre><code>_map_df_to_external(\n    df: DataFrame, columns: Sequence[str]\n) -&gt; pl.DataFrame\n</code></pre> <p>Transform node IDs in DataFrame columns from local to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with transformed node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_df_to_external(self, df: pl.DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame:\n    \"\"\"\n    Transform node IDs in DataFrame columns from local to external coordinates.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        DataFrame containing node IDs to transform\n    columns : Sequence[str]\n        Column names containing node IDs to transform\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with transformed node IDs\n    \"\"\"\n    for col in columns:\n        if col in df.columns:\n            df = df.with_columns(\n                pl.col(col).map_elements(self._local_to_external.__getitem__, return_dtype=pl.Int64).alias(col)\n            )\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_df_to_external(columns)","title":"<code>columns</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>Column names containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_external","title":"_map_to_external","text":"<pre><code>_map_to_external(local_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_external(local_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_external(local_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_external(\n    local_ids: int | Sequence[int] | None,\n) -&gt; int | list[int] | None\n</code></pre> <p>Transform local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>External IDs corresponding to the local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_external(self, local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : int | Sequence[int] | None\n        Local IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        External IDs corresponding to the local IDs\n    \"\"\"\n    if local_ids is None:\n        return None\n    if isinstance(local_ids, int):\n        return self._local_to_external[local_ids]\n    return [self._local_to_external[lid] for lid in local_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>Local IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_local","title":"_map_to_local","text":"<pre><code>_map_to_local(external_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_local(external_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_local(external_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_local(\n    external_ids: int | Sequence[int] | None,\n) -&gt; int | list[int] | None\n</code></pre> <p>Transform external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>Local IDs corresponding to the external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_local(self, external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : int | Sequence[int] | None\n        External IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        Local IDs corresponding to the external IDs\n    \"\"\"\n    if external_ids is None:\n        return None\n    if isinstance(external_ids, int):\n        return self._external_to_local[external_ids]\n    return [self._external_to_local[eid] for eid in external_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>External IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping","title":"_remove_id_mapping","text":"<pre><code>_remove_id_mapping(\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _remove_id_mapping(\n    self,\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID to remove from mapping\n    external_id : int\n        External node ID to remove from mapping\n    \"\"\"\n    if local_id is not None:\n        del self._local_to_external[local_id]\n    elif external_id is not None:\n        del self._external_to_local[external_id]\n    else:\n        raise ValueError(\"Either local_id or external_id must be provided\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Local node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._remove_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>External node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._replace_parent_graph_with_root","title":"_replace_parent_graph_with_root","text":"<pre><code>_replace_parent_graph_with_root() -&gt; None\n</code></pre> <p>Replace the parent graph with it's own parent graph (the root graph) This is internally called so every view of a graph maps to a single root, skipping intermediate views.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def _replace_parent_graph_with_root(self) -&gt; None:\n    \"\"\"\n    Replace the parent graph with it's own parent graph (the root graph)\n    This is internally called so every view of a graph maps to a single root, skipping intermediate views.\n    \"\"\"\n    parent = self._root\n\n    if not isinstance(parent, GraphView):\n        raise ValueError(\n            f\"Parent graph must be a GraphView to have its parent replaced with the root graph. Got {type(parent)}.\"\n        )\n\n    self._root = parent._root\n    self._local_to_external = bidict.bidict(\n        (k, parent._local_to_external[v]) for k, v in self._local_to_external.items()\n    )\n\n    self._edge_map_to_root = bidict.bidict(\n        (k, parent._edge_map_to_root[v]) for k, v in self._edge_map_to_root.items()\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    node_ids = self._map_to_local(node_ids)\n    rx_graph, node_map = super()._rx_subgraph_with_nodemap(node_ids)\n    node_map = {k: self._map_to_external(v) for k, v in node_map.items()}\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys() and ref_key != DEFAULT_ATTR_KEYS.NODE_ID:\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_external","title":"_vectorized_map_to_external","text":"<pre><code>_vectorized_map_to_external(\n    local_ids: ndarray | Sequence[int],\n) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_external(self, local_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : np.ndarray | Sequence[int]\n        Array or sequence of local IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of external IDs\n    \"\"\"\n    vec_map = np.vectorize(self._local_to_external.__getitem__, otypes=[int])\n    return vec_map(np.asarray(local_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of local IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_local","title":"_vectorized_map_to_local","text":"<pre><code>_vectorized_map_to_local(\n    external_ids: ndarray | Sequence[int],\n) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_local(self, external_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : np.ndarray | Sequence[int]\n        Array or sequence of external IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of local IDs\n    \"\"\"\n    vec_map = np.vectorize(self._external_to_local.__getitem__, otypes=[int])\n    return vec_map(np.asarray(external_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView._vectorized_map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of external IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    return self._root.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    cache_key = (frame_attr_key, bbox_attr_key)\n    if not hasattr(self, \"_bbox_spatial_filter_cache\") or clear_cache:\n        self._bbox_spatial_filter_cache: dict[tuple[str | None, str], BBoxSpatialFilter] = {}\n\n    if cache_key not in self._bbox_spatial_filter_cache:\n        self._bbox_spatial_filter_cache[cache_key] = BBoxSpatialFilter(\n            self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key\n        )\n    return self._bbox_spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bbox_spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.GraphView.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    self._root.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(\n    permanent_node_ids: Sequence[int],\n) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    subgraph = super().contract_nodes(\n        permanent_node_ids=self._map_to_local(permanent_node_ids),\n    )\n    subgraph._replace_parent_graph_with_root()\n\n    return subgraph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; GraphView\n</code></pre> <p>Not supported for <code>GraphView</code>.</p> <p>Use <code>detach</code> to create a new reference-less graph with the same nodes and edges.</p> See Also <p>detach     Create a new reference-less graph with the same nodes and edges.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"GraphView\":\n    \"\"\"\n    Not supported for `GraphView`.\n\n    Use `detach` to create a new reference-less graph with the same nodes and edges.\n\n    See Also\n    --------\n    [detach][tracksdata.graph.GraphView.detach]\n        Create a new reference-less graph with the same nodes and edges.\n    \"\"\"\n    raise ValueError(\n        \"`copy` is not supported for `GraphView`.\\n\"\n        \"Use `detach` to create a new reference-less graph with the same nodes and edges.\"\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach","title":"detach","text":"<pre><code>detach(reset_ids: Literal[False]) -&gt; IndexedRXGraph\n</code></pre><pre><code>detach(reset_ids: Literal[True]) -&gt; RustWorkXGraph\n</code></pre> <pre><code>detach(\n    reset_ids: bool = False,\n) -&gt; IndexedRXGraph | RustWorkXGraph\n</code></pre> <p>Detach the graph view from the root graph, returning a new graph with the same nodes and edges without the view's mapping and indenpendent ids.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach--parameters","title":"Parameters","text":"<p>reset_ids : bool     Whether to reset the ids of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.detach--returns","title":"Returns","text":"<p>IndexedRXGraph | RustWorkXGraph     The detached graph.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def detach(self, reset_ids: bool = False) -&gt; IndexedRXGraph | RustWorkXGraph:\n    \"\"\"\n    Detach the graph view from the root graph, returning a new graph with the same nodes and edges\n    without the view's mapping and indenpendent ids.\n\n    Parameters\n    ----------\n    reset_ids : bool\n        Whether to reset the ids of the graph.\n\n    Returns\n    -------\n    IndexedRXGraph | RustWorkXGraph\n        The detached graph.\n    \"\"\"\n    if reset_ids:\n        return RustWorkXGraph.from_other(self)\n    else:\n        return IndexedRXGraph.from_other(self)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    return self._root.edge_id(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. tracklet_ids : np.ndarray | None     Track ids of the nodes if available. tracklet_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    tracklet_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    tracklet_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        tracklet_ids=tracklet_ids,\n        tracklet_id_graph=tracklet_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> <li> <code>geff_metadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The geff metadata of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    geff_read_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `geff.read` function.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    geff_metadata : GeffMetadata\n        The geff metadata of the graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    if geff_read_kwargs is None:\n        geff_read_kwargs = {}\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, geff_metadata = geff.read(geff_store, backend=\"rustworkx\", **geff_read_kwargs)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    node_id_map = rx_graph.attrs[\"to_rx_id_map\"]\n    rx_graph.attrs = {\"geff\": rx_graph.attrs, **rx_graph.attrs[\"extra\"].pop(\"tracksdata\", {})}\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=node_id_map,\n        **kwargs,\n    )\n\n    if DEFAULT_ATTR_KEYS.MASK in indexed_graph.node_attr_keys:\n        from tracksdata.nodes._mask import Mask\n\n        # unsafe operation, changing graph content inplace\n        for node_attr in indexed_graph.rx_graph.nodes():\n            node_attr[DEFAULT_ATTR_KEYS.MASK] = Mask(\n                node_attr[DEFAULT_ATTR_KEYS.MASK].astype(bool),\n                bbox=node_attr[DEFAULT_ATTR_KEYS.BBOX],\n            )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph, geff_metadata\n\n    return cls.from_other(indexed_graph, **kwargs), geff_metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff(geff_read_kwargs)","title":"<code>geff_read_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>geff.read</code> function.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            first_value = node_attrs[col].first()\n            graph.add_node_attr_key(col, infer_default_value(first_value))\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n\n    try:\n        source_id = self._map_to_local(source_id)\n    except KeyError:\n        LOG.warning(f\"`source_id` {source_id} not found in index map.\")\n        return False\n\n    try:\n        target_id = self._map_to_local(target_id)\n    except KeyError:\n        LOG.warning(f\"`target_id` {target_id} not found in index map.\")\n        return False\n\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.in_degree","title":"in_degree","text":"<pre><code>in_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(self._map_to_local(node_ids))\n    return [rx_graph.in_degree(self._map_to_local(node_id)) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match","title":"match","text":"<pre><code>match(\n    other: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.out_degree","title":"out_degree","text":"<pre><code>out_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(self._map_to_local(node_ids))\n    return [rx_graph.out_degree(self._map_to_local(node_id)) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps","title":"overlaps","text":"<pre><code>overlaps(\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    return self._root.overlaps(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.remove_edge","title":"remove_edge","text":"<pre><code>remove_edge(\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an edge by ID or by endpoints in both the root and (if present) the view.</p> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def remove_edge(\n    self,\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an edge by ID or by endpoints in both the root and (if present) the view.\n    \"\"\"\n    # Remove from root first\n    if edge_id is None:\n        if source_id is None or target_id is None:\n            raise ValueError(\"Provide either edge_id or both source_id and target_id.\")\n        try:\n            edge_id = self._root.edge_id(source_id, target_id)\n        # Ensure the same error raised by the SQLGraph\n        except rx.NoEdgeBetweenNodes as e:\n            raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\") from e\n    self._root.remove_edge(edge_id=edge_id)  # Error raised from root if edge_id not found\n\n    # Remove from the local graph if synced\n    if self.sync:\n        if edge_id in self._edge_map_from_root:\n            local_edge_id = self._edge_map_from_root[edge_id]\n            edge_map = self.rx_graph.edge_index_map()\n            src, tgt, _ = edge_map[local_edge_id]\n            self.rx_graph.remove_edge(src, tgt)\n            del self._edge_map_to_root[local_edge_id]\n    else:\n        self._out_of_sync = True\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the node from both the view and the root graph, along with all connected edges. Also updates the node mappings.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_graph_view.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the node from both the view and the root graph,\n    along with all connected edges. Also updates the node mappings.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self._external_to_local:\n        raise ValueError(f\"Node {node_id} does not exist in the graph.\")\n\n    # Remove from root graph first, because removing bounding box requires node attrs\n    self._root.remove_node(node_id)\n    self.node_removed.emit_fast(node_id)\n\n    if self.sync:\n        # Get the local node ID and remove from local graph\n        local_node_id = self._external_to_local[node_id]\n\n        with self.node_removed.blocked():\n            super().remove_node(local_node_id)\n\n        # Remove the node mapping\n        self._remove_id_mapping(external_id=node_id)\n\n        # Update edge mappings - remove edges involving this node\n        edges_to_remove = []\n        edge_indices = self.rx_graph.edge_indices()\n        for local_edge_id, _ in list(self._edge_map_to_root.items()):\n            # Check if this edge is still in the local graph\n            if local_edge_id not in edge_indices:\n                edges_to_remove.append(local_edge_id)\n\n        for edge_id in edges_to_remove:\n            if edge_id in self._edge_map_to_root:\n                del self._edge_map_to_root[edge_id]\n    else:\n        self._out_of_sync = True\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(\n    attr_keys: list[str] | None = None,\n    clear_cache: bool = False,\n) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None, clear_cache: bool = False) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    cache_key = None if attr_keys is None else tuple(attr_keys)\n    if not hasattr(self, \"_spatial_filter_cache\") or clear_cache:\n        self._spatial_filter_cache: dict[tuple[str, ...] | None, SpatialFilter] = {}\n\n    if cache_key not in self._spatial_filter_cache:\n        self._spatial_filter_cache[cache_key] = SpatialFilter(self, attr_keys=attr_keys)\n\n    return self._spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary","title":"summary","text":"<pre><code>summary(\n    attrs_stats: bool = False, print_summary: bool = True\n) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--parameters","title":"Parameters","text":"<p>output_dir : str | Path     The directory to save the graph to. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_tracklet_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        The directory to save the graph to.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_tracklet_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        tracklet_id_key=tracklet_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff","title":"to_geff","text":"<pre><code>to_geff(\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: geff.GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: tracklet_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n    node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy()\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACKLET_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACKLET_ID,\n            }\n        else:\n            track_node_props = None\n\n        node_props_metadata = {\n            k: PropMetadata(\n                identifier=k,\n                dtype=polars_dtype_to_numpy_dtype(v.dtype) if k != DEFAULT_ATTR_KEYS.MASK else np.uint64,\n                varlength=k == DEFAULT_ATTR_KEYS.MASK,\n            )\n            for k, v in node_attrs.to_dict().items()\n        }\n        edge_props_metadata = {\n            k: PropMetadata(identifier=k, dtype=polars_dtype_to_numpy_dtype(v.dtype))\n            for k, v in edge_attrs.to_dict().items()\n        }\n\n        td_metadata = self.metadata.copy()\n        td_metadata.pop(\"geff\", None)  # avoid geff being written multiple times\n\n        geff_metadata = geff.GeffMetadata(\n            directed=True,\n            axes=axes,\n            node_props_metadata=node_props_metadata,\n            edge_props_metadata=edge_props_metadata,\n            track_node_props=track_node_props,\n            extra={\n                \"tracksdata\": td_metadata,\n            },\n        )\n\n    node_dict = {\n        k: {\"values\": column_to_numpy(v), \"missing\": None}\n        for k, v in node_attrs.to_dict().items()\n        if k != DEFAULT_ATTR_KEYS.MASK\n    }\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_dict[DEFAULT_ATTR_KEYS.MASK] = construct_var_len_props(\n            [mask.mask.astype(np.uint64) for mask in node_attrs[DEFAULT_ATTR_KEYS.MASK]]\n        )\n\n    edge_dict = {k: {\"values\": column_to_numpy(v), \"missing\": None} for k, v in edge_attrs.to_dict().items()}\n\n    write_arrays(\n        geff_store,\n        node_ids=node_ids.astype(np.uint64),\n        node_props=node_dict,\n        edge_ids=edge_ids.astype(np.uint64),\n        edge_props=edge_dict,\n        metadata=geff_metadata,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: tracklet_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_traccuracy_graph","title":"to_traccuracy_graph","text":"<pre><code>to_traccuracy_graph(\n    array_view_kwargs: dict[str, Any] | None = None,\n) -&gt; TrackingGraph\n</code></pre> <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TrackingGraph</code>           \u2013            <p>A traccuracy graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_traccuracy_graph(self, array_view_kwargs: dict[str, Any] | None = None) -&gt; \"TrackingGraph\":\n    \"\"\"\n    Convert the graph to a `traccuracy.TrackingGraph`.\n\n    Parameters\n    ----------\n    array_view_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `GraphArrayView` constructor used to create the segmentation.\n\n    Returns\n    -------\n    TrackingGraph\n        A traccuracy graph.\n    \"\"\"\n    from tracksdata.metrics._traccuracy import to_traccuracy_graph\n\n    return to_traccuracy_graph(self, array_view_kwargs=array_view_kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.to_traccuracy_graph(array_view_kwargs)","title":"<code>array_view_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>GraphArrayView</code> constructor used to create the segmentation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    tracklet_id_key : str\n        The key of the track id attribute.\n    ignore_tracklet_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n    from tracksdata.functional._edges import join_node_attrs_to_edges\n\n    if tracklet_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{tracklet_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, tracklet_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_tracklet_id is not None:\n        nodes_df = nodes_df.filter(pl.col(tracklet_id_key) != ignore_tracklet_id)\n\n    track_ids = nodes_df[tracklet_id_key].unique().to_list()\n    tracklet_graph = rx.PyDiGraph()\n\n    rx_ids = np.asarray(tracklet_graph.add_nodes_from(track_ids), dtype=int)\n    track_id_to_rx_id = dict(zip(track_ids, rx_ids, strict=True))\n\n    src_col = f\"source_{tracklet_id_key}\"\n    tgt_col = f\"target_{tracklet_id_key}\"\n\n    edges_df = (\n        join_node_attrs_to_edges(\n            nodes_df,\n            edges_df,\n            how=\"right\",\n        )\n        .filter(pl.col(src_col) != pl.col(tgt_col))\n        .with_columns(\n            pl.col(src_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"source_rx_id\"),\n            pl.col(tgt_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"target_rx_id\"),\n        )\n    )\n\n    tracklet_graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[src_col].to_list(), edges_df[tgt_col].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return tracklet_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph(tracklet_id_key)","title":"<code>tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_graph(ignore_tracklet_id)","title":"<code>ignore_tracklet_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_nodes","title":"tracklet_nodes","text":"<pre><code>tracklet_nodes(seeds: list[int] | None) -&gt; list[int]\n</code></pre> <p>Compute the non-branching tracklets around the provided seed node_ids.</p> <p>Walks forward to successors only through nodes with exactly one successor, and backward to predecessors that also have out_degree == 1, until closure.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>Sorted unique node IDs forming the closure.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_nodes(self, seeds: list[int] | None) -&gt; list[int]:\n    \"\"\"\n    Compute the non-branching tracklets around the provided seed node_ids.\n\n    Walks forward to successors only through nodes with exactly one successor,\n    and backward to predecessors that also have out_degree == 1, until closure.\n\n    Parameters\n    ----------\n    seeds : list[int]\n        Seed node IDs where to start the closure.\n\n    Returns\n    -------\n    list[int]\n        Sorted unique node IDs forming the closure.\n    \"\"\"\n    # NOTE: if this function becomes a bottleneck in the future it might be worth having\n    # a specialized version per backend\n    if seeds is None or len(seeds) == 0:\n        return []\n\n    track_node_ids: set[int] = set()\n    active_ids: set[int] = set(seeds)\n\n    while len(active_ids) &gt; 0:\n        track_node_ids.update(active_ids)\n\n        # Successors: only nodes with exactly one successor\n        succ_map = self.successors(node_ids=list(active_ids))\n        successors = [int(nodes[0]) for nodes in succ_map.values() if len(nodes) == 1]\n\n        # Predecessors: only nodes with exactly one predecessor and predecessor out_degree == 1\n        pred_map = self.predecessors(node_ids=list(active_ids))\n        predecessors = [int(nodes[0]) for nodes in pred_map.values() if len(nodes) == 1]\n\n        if len(predecessors) &gt; 0:\n            out_degrees = self.out_degree(predecessors)\n            if isinstance(out_degrees, int):\n                out_degrees = [out_degrees]\n            predecessors = [node for node, degree in zip(predecessors, out_degrees, strict=True) if degree == 1]\n\n        active_ids = (set(successors) | set(predecessors)) - track_node_ids\n\n    return sorted(track_node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.GraphView.tracklet_nodes(seeds)","title":"<code>seeds</code>","text":"(<code>list[int]</code>)           \u2013            <p>Seed node IDs where to start the closure.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph","title":"IndexedRXGraph","text":"<pre><code>IndexedRXGraph(\n    rx_graph: PyDiGraph | None = None,\n    node_id_map: dict[int, int] | None = None,\n)\n</code></pre> <p>               Bases: <code>RustWorkXGraph</code>, <code>MappedGraphMixin</code></p> <pre><code>\n              flowchart TD\n              tracksdata.graph.IndexedRXGraph[IndexedRXGraph]\n              tracksdata.graph._rustworkx_graph.RustWorkXGraph[RustWorkXGraph]\n              tracksdata.graph._base_graph.BaseGraph[BaseGraph]\n              tracksdata.graph._mapped_graph_mixin.MappedGraphMixin[MappedGraphMixin]\n\n                              tracksdata.graph._rustworkx_graph.RustWorkXGraph --&gt; tracksdata.graph.IndexedRXGraph\n                                tracksdata.graph._base_graph.BaseGraph --&gt; tracksdata.graph._rustworkx_graph.RustWorkXGraph\n                \n\n                tracksdata.graph._mapped_graph_mixin.MappedGraphMixin --&gt; tracksdata.graph.IndexedRXGraph\n                \n\n\n              click tracksdata.graph.IndexedRXGraph href \"\" \"tracksdata.graph.IndexedRXGraph\"\n              click tracksdata.graph._rustworkx_graph.RustWorkXGraph href \"\" \"tracksdata.graph._rustworkx_graph.RustWorkXGraph\"\n              click tracksdata.graph._base_graph.BaseGraph href \"\" \"tracksdata.graph._base_graph.BaseGraph\"\n              click tracksdata.graph._mapped_graph_mixin.MappedGraphMixin href \"\" \"tracksdata.graph._mapped_graph_mixin.MappedGraphMixin\"\n            </code></pre> <p>A graph with arbitrary node indices.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph = IndexedRXGraph(rx_graph=rx_graph, node_id_map=node_id_map)\n...\ngraph = IndexedRXGraph()\ngraph.add_node({\"t\": 0}, index=1355)\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add an overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Add multiple nodes to the graph.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the edge attributes of the graph.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in degree of the graph.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the node attributes of the graph.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the node ids of the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out degree of the graph.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps of the graph.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_edge</code>             \u2013              <p>Remove an edge by endpoints (external IDs) or by edge_id.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>to_traccuracy_graph</code>             \u2013              <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>tracklet_nodes</code>             \u2013              <p>Compute the non-branching tracklets around the provided seed node_ids.</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the node attributes of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def __init__(\n    self,\n    rx_graph: rx.PyDiGraph | None = None,\n    node_id_map: dict[int, int] | None = None,\n) -&gt; None:\n    if rx_graph is not None and node_id_map is None:\n        raise ValueError(\"`node_id_map` must be provided when `rx_graph` is provided\")\n\n    if rx_graph is None and node_id_map is not None:\n        raise ValueError(\"`rx_graph` must be provided when `node_id_map` is provided\")\n\n    # Initialize RustWorkXGraph\n    RustWorkXGraph.__init__(self, rx_graph)\n\n    # Initialize MappedGraphMixin with inverted mapping (local -&gt; external)\n    inverted_map = None\n    if node_id_map is not None:\n        # Validate for duplicate values before inverting\n        # This will raise bidict.ValueDuplicationError if there are duplicates\n        inverted_map = bidict.bidict(node_id_map).inverse\n        self._next_external_id = max(node_id_map.keys(), default=0) + 1\n    else:\n        self._next_external_id = 0\n\n    MappedGraphMixin.__init__(self, inverted_map)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph(rx_graph)","title":"<code>rx_graph</code>","text":"(<code>PyDiGraph | None</code>, default:                   <code>None</code> )           \u2013            <p>The rustworkx graph to index.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph(node_id_map)","title":"<code>node_id_map</code>","text":"(<code>dict[int, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>A map of external ids (arbitrary) to rx graph ids (0 to N-1), must be provided if <code>rx_graph</code> is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attr_keys","title":"edge_attr_keys  <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attr_keys","title":"node_attr_keys  <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping","title":"_add_id_mapping","text":"<pre><code>_add_id_mapping(local_id: int, external_id: int) -&gt; None\n</code></pre> <p>Add a new ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mapping(self, local_id: int, external_id: int) -&gt; None:\n    \"\"\"\n    Add a new ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID\n    external_id : int\n        External node ID\n    \"\"\"\n    try:\n        self._local_to_external.put(local_id, external_id)\n    except bidict.ValueDuplicationError as e:\n        # Convert ValueDuplicationError to KeyDuplicationError since from user perspective\n        # the external_id (their \"key\"/index) is what's being duplicated\n        raise bidict.KeyDuplicationError(e.args[0]) from e\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>)           \u2013            <p>Local node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>)           \u2013            <p>External node ID</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mappings","title":"_add_id_mappings","text":"<pre><code>_add_id_mappings(\n    mappings: Sequence[tuple[int, int]],\n) -&gt; None\n</code></pre> <p>Add multiple ID mappings at once.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _add_id_mappings(self, mappings: Sequence[tuple[int, int]]) -&gt; None:\n    \"\"\"\n    Add multiple ID mappings at once.\n\n    Parameters\n    ----------\n    mappings : Sequence[tuple[int, int]]\n        Sequence of (local_id, external_id) pairs\n    \"\"\"\n    self._local_to_external.putall(mappings)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._add_id_mappings(mappings)","title":"<code>mappings</code>","text":"(<code>Sequence[tuple[int, int]]</code>)           \u2013            <p>Sequence of (local_id, external_id) pairs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_external_ids","title":"_get_external_ids","text":"<pre><code>_get_external_ids() -&gt; list[int]\n</code></pre> <p>Get all external IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all external node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_external_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all external IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all external node IDs\n    \"\"\"\n    return list(self._local_to_external.values())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_local_ids","title":"_get_local_ids","text":"<pre><code>_get_local_ids() -&gt; list[int]\n</code></pre> <p>Get all local IDs in the mapping.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all local node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _get_local_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get all local IDs in the mapping.\n\n    Returns\n    -------\n    list[int]\n        List of all local node IDs\n    \"\"\"\n    return list(self._local_to_external.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._get_next_available_external_id","title":"_get_next_available_external_id","text":"<pre><code>_get_next_available_external_id() -&gt; int\n</code></pre> <p>Get the next available external ID in O(1) time using an internal counter.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next available external ID.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _get_next_available_external_id(self) -&gt; int:\n    \"\"\"\n    Get the next available external ID in O(1) time using an internal counter.\n\n    Returns\n    -------\n    int\n        The next available external ID.\n    \"\"\"\n    next_id = self._next_external_id\n    self._next_external_id += 1\n    return next_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external","title":"_map_df_to_external","text":"<pre><code>_map_df_to_external(\n    df: DataFrame, columns: Sequence[str]\n) -&gt; pl.DataFrame\n</code></pre> <p>Transform node IDs in DataFrame columns from local to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with transformed node IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_df_to_external(self, df: pl.DataFrame, columns: Sequence[str]) -&gt; pl.DataFrame:\n    \"\"\"\n    Transform node IDs in DataFrame columns from local to external coordinates.\n\n    Parameters\n    ----------\n    df : pl.DataFrame\n        DataFrame containing node IDs to transform\n    columns : Sequence[str]\n        Column names containing node IDs to transform\n\n    Returns\n    -------\n    pl.DataFrame\n        DataFrame with transformed node IDs\n    \"\"\"\n    for col in columns:\n        if col in df.columns:\n            df = df.with_columns(\n                pl.col(col).map_elements(self._local_to_external.__getitem__, return_dtype=pl.Int64).alias(col)\n            )\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_df_to_external(columns)","title":"<code>columns</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>Column names containing node IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_external","title":"_map_to_external","text":"<pre><code>_map_to_external(local_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_external(local_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_external(local_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_external(\n    local_ids: int | Sequence[int] | None,\n) -&gt; int | list[int] | None\n</code></pre> <p>Transform local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>External IDs corresponding to the local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_external(self, local_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : int | Sequence[int] | None\n        Local IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        External IDs corresponding to the local IDs\n    \"\"\"\n    if local_ids is None:\n        return None\n    if isinstance(local_ids, int):\n        return self._local_to_external[local_ids]\n    return [self._local_to_external[lid] for lid in local_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>Local IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_local","title":"_map_to_local","text":"<pre><code>_map_to_local(external_ids: None) -&gt; None\n</code></pre><pre><code>_map_to_local(external_ids: int) -&gt; int\n</code></pre><pre><code>_map_to_local(external_ids: Sequence[int]) -&gt; list[int]\n</code></pre> <pre><code>_map_to_local(\n    external_ids: int | Sequence[int] | None,\n) -&gt; int | list[int] | None\n</code></pre> <p>Transform external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | list[int] | None</code>           \u2013            <p>Local IDs corresponding to the external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _map_to_local(self, external_ids: int | Sequence[int] | None) -&gt; int | list[int] | None:\n    \"\"\"\n    Transform external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : int | Sequence[int] | None\n        External IDs to transform\n\n    Returns\n    -------\n    int | list[int] | None\n        Local IDs corresponding to the external IDs\n    \"\"\"\n    if external_ids is None:\n        return None\n    if isinstance(external_ids, int):\n        return self._external_to_local[external_ids]\n    return [self._external_to_local[eid] for eid in external_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>int | Sequence[int] | None</code>)           \u2013            <p>External IDs to transform</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping","title":"_remove_id_mapping","text":"<pre><code>_remove_id_mapping(\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an ID mapping.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _remove_id_mapping(\n    self,\n    *,\n    local_id: int | None = None,\n    external_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an ID mapping.\n\n    Parameters\n    ----------\n    local_id : int\n        Local node ID to remove from mapping\n    external_id : int\n        External node ID to remove from mapping\n    \"\"\"\n    if local_id is not None:\n        del self._local_to_external[local_id]\n    elif external_id is not None:\n        del self._external_to_local[external_id]\n    else:\n        raise ValueError(\"Either local_id or external_id must be provided\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping(local_id)","title":"<code>local_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Local node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._remove_id_mapping(external_id)","title":"<code>external_id</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>External node ID to remove from mapping</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    # TODO: fix this, too many back and forth between world and graph ids within FilterRX\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    rx_graph, node_map = super()._rx_subgraph_with_nodemap(node_ids)\n    node_map = {k: self._map_to_external(v) for k, v in node_map.items()}\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys() and ref_key != DEFAULT_ATTR_KEYS.NODE_ID:\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_external","title":"_vectorized_map_to_external","text":"<pre><code>_vectorized_map_to_external(\n    local_ids: ndarray | Sequence[int],\n) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of local IDs to external coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of external IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_external(self, local_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of local IDs to external coordinates.\n\n    Parameters\n    ----------\n    local_ids : np.ndarray | Sequence[int]\n        Array or sequence of local IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of external IDs\n    \"\"\"\n    vec_map = np.vectorize(self._local_to_external.__getitem__, otypes=[int])\n    return vec_map(np.asarray(local_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_external(local_ids)","title":"<code>local_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of local IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_local","title":"_vectorized_map_to_local","text":"<pre><code>_vectorized_map_to_local(\n    external_ids: ndarray | Sequence[int],\n) -&gt; np.ndarray\n</code></pre> <p>Vectorized transformation of external IDs to local coordinates.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of local IDs</p> </li> </ul> Source code in <code>src/tracksdata/graph/_mapped_graph_mixin.py</code> <pre><code>def _vectorized_map_to_local(self, external_ids: np.ndarray | Sequence[int]) -&gt; np.ndarray:\n    \"\"\"\n    Vectorized transformation of external IDs to local coordinates.\n\n    Parameters\n    ----------\n    external_ids : np.ndarray | Sequence[int]\n        Array or sequence of external IDs\n\n    Returns\n    -------\n    np.ndarray\n        Array of local IDs\n    \"\"\"\n    vec_map = np.vectorize(self._external_to_local.__getitem__, otypes=[int])\n    return vec_map(np.asarray(external_ids, dtype=int))\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph._vectorized_map_to_local(external_ids)","title":"<code>external_ids</code>","text":"(<code>ndarray | Sequence[int]</code>)           \u2013            <p>Array or sequence of external IDs</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The edge id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The source node id.\n    target_id : int\n        The target node id.\n    attrs : dict[str, Any]\n        The attributes of the edge.\n    validate_keys : bool\n        Whether to validate the keys of the attributes.\n\n    Returns\n    -------\n    int\n        The edge id.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().add_edge(source_id, target_id, attrs, validate_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The source node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The target node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to validate the keys of the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key","title":"add_edge_attr_key","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing edges for the new attribute key.\n    \"\"\"\n    if key in self.edge_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._edge_attr_keys.append(key)\n    for _, _, edge_attr in self.rx_graph.weighted_edge_list():\n        edge_attr[key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_edge_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing edges for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node","title":"add_node","text":"<pre><code>add_node(\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int\n</code></pre> <p>Add a node to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The index of the node.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node.\n    validate_keys : bool\n        Whether to validate the keys of the attributes.\n    index : int | None\n        The index of the node. If None, the next available index will be used\n        to avoid conflicts with existing node indices.\n\n    Returns\n    -------\n    int\n        The index of the node.\n    \"\"\"\n    with self.node_added.blocked():\n        node_id = super().add_node(attrs, validate_keys)\n\n    if index is None:\n        index = self._get_next_available_external_id()\n    else:\n        # Update counter if explicit index is higher to avoid future collisions\n        self._next_external_id = max(self._next_external_id, index + 1)\n    # Add mapping using mixin\n    self._add_id_mapping(node_id, index)\n    self.node_added.emit_fast(index)\n    return index\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to validate the keys of the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The index of the node. If None, the next available index will be used to avoid conflicts with existing node indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key","title":"add_node_attr_key","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing nodes for the new attribute key.\n    \"\"\"\n    if key in self.node_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._node_attr_keys.append(key)\n    rx_graph = self.rx_graph\n    for node_id in rx_graph.node_indices():\n        rx_graph[node_id][key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_node_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing nodes for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add an overlap to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The overlap id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_overlap(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Add an overlap to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The source node id.\n    target_id : int\n        The target node id.\n\n    Returns\n    -------\n    int\n        The overlap id.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The source node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.add_overlap(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The target node id.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    cache_key = (frame_attr_key, bbox_attr_key)\n    if not hasattr(self, \"_bbox_spatial_filter_cache\") or clear_cache:\n        self._bbox_spatial_filter_cache: dict[tuple[str | None, str], BBoxSpatialFilter] = {}\n\n    if cache_key not in self._bbox_spatial_filter_cache:\n        self._bbox_spatial_filter_cache[cache_key] = BBoxSpatialFilter(\n            self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key\n        )\n    return self._bbox_spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bbox_spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: bool = False\n) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_edges(self, edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # saving for historical reasons, iterating over edges is faster than using rx.add_edges_from\n    # edges_data = [(d.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE), d.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET), d) for d in edges]\n    # indices = self.rx_graph.add_edges_from(edges_data)\n    # for i, d in zip(indices, edges, strict=True):\n    #     d[DEFAULT_ATTR_KEYS.EDGE_ID] = i\n    # return indices\n    return super().bulk_add_edges(edges, return_ids=return_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Add multiple nodes to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The indices of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Add multiple nodes to the graph.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The attributes of the nodes.\n    indices : list[int] | None\n        The indices of the nodes. If None, all nodes will get auto-generated indices.\n        If provided, must have same length as nodes and all indices must be specified.\n\n    Returns\n    -------\n    list[int]\n        The indices of the nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    with self.node_added.blocked():\n        graph_ids = super().bulk_add_nodes(nodes)\n\n    if indices is None:\n        # All nodes get auto-generated indices\n        indices = [self._get_next_available_external_id() for _ in nodes]\n    else:\n        # All indices are explicitly provided\n        if len(indices) != len(nodes):\n            raise ValueError(f\"Length of indices ({len(indices)}) must match nodes ({len(nodes)})\")\n\n        # Update counter to be after the highest explicit index\n        self._next_external_id = max(self._next_external_id, max(indices) + 1)\n\n    self._add_id_mappings(list(zip(graph_ids, indices, strict=True)))\n\n    if is_signal_on(self.node_added):\n        for index in indices:\n            self.node_added.emit_fast(index)\n\n    return indices\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The indices of the nodes. If None, all nodes will get auto-generated indices. If provided, must have same length as nodes and all indices must be specified.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(\n    permanent_node_ids: Sequence[int],\n) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    all_node_ids = np.asarray(self.node_ids())\n    selected_nodes_mask = np.isin(all_node_ids, permanent_node_ids)\n    missing_node_ids = all_node_ids[~selected_nodes_mask]\n\n    # must block multigraphs to avoid edge duplication\n    rx_graph = rx.PyDiGraph(multigraph=False)\n    new_indices = rx_graph.add_nodes_from(self.rx_graph.nodes())\n    rx_graph.add_edges_from(self.rx_graph.weighted_edge_list())\n\n    for node_id in missing_node_ids:\n        rx_graph.remove_node_retain_edges(\n            node_id,\n            use_outgoing=True,\n            condition=lambda *args: True,\n        )\n\n    node_map_to_root = dict(\n        zip(\n            np.asarray(new_indices)[selected_nodes_mask].tolist(),\n            permanent_node_ids,\n            strict=True,\n        )\n    )\n\n    # I'm a bit concerned with the internal booking of indices of rustworkx\n    # so I'm adding this sanity check\n    assert len(node_map_to_root) == rx_graph.num_nodes()\n\n    graph_view = GraphView(rx_graph, node_map_to_root=node_map_to_root, root=self)\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs","title":"edge_attrs","text":"<pre><code>edge_attrs(\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the edge attributes of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The edge attributes of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the edge attributes of the graph.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attributes to include in the subgraph.\n    unpack : bool\n        Whether to unpack the attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        The edge attributes of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids()\n    df = super().filter(node_ids=node_ids).edge_attrs(attr_keys=attr_keys, unpack=unpack)\n    df = self._map_df_to_external(df, [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET])\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    source_id = self._map_to_local(source_id)\n    target_id = self._map_to_local(target_id)\n    return super().edge_id(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.edge_ids","title":"edge_ids","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.edge_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. tracklet_ids : np.ndarray | None     Track ids of the nodes if available. tracklet_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    tracklet_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    tracklet_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        tracklet_ids=tracklet_ids,\n        tracklet_id_graph=tracklet_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> <li> <code>geff_metadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The geff metadata of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    geff_read_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `geff.read` function.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    geff_metadata : GeffMetadata\n        The geff metadata of the graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    if geff_read_kwargs is None:\n        geff_read_kwargs = {}\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, geff_metadata = geff.read(geff_store, backend=\"rustworkx\", **geff_read_kwargs)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    node_id_map = rx_graph.attrs[\"to_rx_id_map\"]\n    rx_graph.attrs = {\"geff\": rx_graph.attrs, **rx_graph.attrs[\"extra\"].pop(\"tracksdata\", {})}\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=node_id_map,\n        **kwargs,\n    )\n\n    if DEFAULT_ATTR_KEYS.MASK in indexed_graph.node_attr_keys:\n        from tracksdata.nodes._mask import Mask\n\n        # unsafe operation, changing graph content inplace\n        for node_attr in indexed_graph.rx_graph.nodes():\n            node_attr[DEFAULT_ATTR_KEYS.MASK] = Mask(\n                node_attr[DEFAULT_ATTR_KEYS.MASK].astype(bool),\n                bbox=node_attr[DEFAULT_ATTR_KEYS.BBOX],\n            )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph, geff_metadata\n\n    return cls.from_other(indexed_graph, **kwargs), geff_metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff(geff_read_kwargs)","title":"<code>geff_read_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>geff.read</code> function.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            first_value = node_attrs[col].first()\n            graph.add_node_attr_key(col, infer_default_value(first_value))\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    try:\n        source_id = self._map_to_local(source_id)\n    except KeyError:\n        LOG.warning(f\"`source_id` {source_id} not found in index map.\")\n        return False\n\n    try:\n        target_id = self._map_to_local(target_id)\n    except KeyError:\n        LOG.warning(f\"`target_id` {target_id} not found in index map.\")\n        return False\n\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the in degree of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int] | int</code>           \u2013            <p>The in degree of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in degree of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[int] | int\n        The in degree of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    return super().in_degree(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.in_degree(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match","title":"match","text":"<pre><code>match(\n    other: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs","title":"node_attrs","text":"<pre><code>node_attrs(\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the node attributes of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>The node attributes of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the node attributes of the graph.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attributes to include in the subgraph.\n    unpack : bool\n        Whether to unpack the attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        The node attributes of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids()\n    df = super()._node_attrs_from_node_ids(node_ids=node_ids, attr_keys=attr_keys, unpack=unpack)\n    df = self._map_df_to_external(df, [DEFAULT_ATTR_KEYS.NODE_ID])\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack the attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the node ids of the graph.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The node ids of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the node ids of the graph.\n\n    Returns\n    -------\n    list[int]\n        The node ids of the graph.\n    \"\"\"\n    return self._get_external_ids()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the out degree of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int] | int</code>           \u2013            <p>The out degree of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out degree of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[int] | int\n        The out degree of the graph.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    return super().out_degree(node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.out_degree(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def overlaps(self, node_ids: list[int] | int | None = None) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps of the graph.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps of the graph.\n    \"\"\"\n    try:\n        node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    except KeyError:\n        LOG.warning(f\"`node_ids` {node_ids} not found in index map.\")\n        return []\n    overlaps = super().overlaps(node_ids)\n    # Convert each pair of node IDs in the overlaps list\n    if len(overlaps) &gt; 0:\n        overlaps = self._vectorized_map_to_external(np.asarray(overlaps)).tolist()\n    return overlaps\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only predecessor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.predecessor_indices,\n        node_ids,\n        attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.predecessors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only predecessor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.remove_edge","title":"remove_edge","text":"<pre><code>remove_edge(\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an edge by endpoints (external IDs) or by edge_id.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_edge(\n    self,\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an edge by endpoints (external IDs) or by edge_id.\n    \"\"\"\n    if edge_id is not None:\n        return super().remove_edge(edge_id=edge_id)\n    if source_id is None or target_id is None:\n        raise ValueError(\"Provide either edge_id or both source_id and target_id.\")\n    try:\n        local_source = self._map_to_local(source_id)\n        local_target = self._map_to_local(target_id)\n    except KeyError as e:\n        raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\") from e\n    try:\n        return super().remove_edge(local_source, local_target)\n    except ValueError as e:\n        raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\") from e\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    Parameters\n    ----------\n    node_id : int\n        The external ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self._external_to_local:\n        raise ValueError(f\"Node {node_id} does not exist in the graph.\")\n\n    local_node_id = self._map_to_local(node_id)\n\n    self.node_removed.emit_fast(node_id)\n    with self.node_removed.blocked():\n        super().remove_node(local_node_id)\n\n    self._remove_id_mapping(external_id=node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The external ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(\n    attr_keys: list[str] | None = None,\n    clear_cache: bool = False,\n) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None, clear_cache: bool = False) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    cache_key = None if attr_keys is None else tuple(attr_keys)\n    if not hasattr(self, \"_spatial_filter_cache\") or clear_cache:\n        self._spatial_filter_cache: dict[tuple[str, ...] | None, SpatialFilter] = {}\n\n    if cache_key not in self._spatial_filter_cache:\n        self._spatial_filter_cache[cache_key] = SpatialFilter(self, attr_keys=attr_keys)\n\n    return self._spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors","title":"successors","text":"<pre><code>successors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only successor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.successor_indices,\n        node_ids,\n        attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.successors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only successor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary","title":"summary","text":"<pre><code>summary(\n    attrs_stats: bool = False, print_summary: bool = True\n) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--parameters","title":"Parameters","text":"<p>output_dir : str | Path     The directory to save the graph to. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_tracklet_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        The directory to save the graph to.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_tracklet_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        tracklet_id_key=tracklet_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: geff.GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: tracklet_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n    node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy()\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACKLET_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACKLET_ID,\n            }\n        else:\n            track_node_props = None\n\n        node_props_metadata = {\n            k: PropMetadata(\n                identifier=k,\n                dtype=polars_dtype_to_numpy_dtype(v.dtype) if k != DEFAULT_ATTR_KEYS.MASK else np.uint64,\n                varlength=k == DEFAULT_ATTR_KEYS.MASK,\n            )\n            for k, v in node_attrs.to_dict().items()\n        }\n        edge_props_metadata = {\n            k: PropMetadata(identifier=k, dtype=polars_dtype_to_numpy_dtype(v.dtype))\n            for k, v in edge_attrs.to_dict().items()\n        }\n\n        td_metadata = self.metadata.copy()\n        td_metadata.pop(\"geff\", None)  # avoid geff being written multiple times\n\n        geff_metadata = geff.GeffMetadata(\n            directed=True,\n            axes=axes,\n            node_props_metadata=node_props_metadata,\n            edge_props_metadata=edge_props_metadata,\n            track_node_props=track_node_props,\n            extra={\n                \"tracksdata\": td_metadata,\n            },\n        )\n\n    node_dict = {\n        k: {\"values\": column_to_numpy(v), \"missing\": None}\n        for k, v in node_attrs.to_dict().items()\n        if k != DEFAULT_ATTR_KEYS.MASK\n    }\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_dict[DEFAULT_ATTR_KEYS.MASK] = construct_var_len_props(\n            [mask.mask.astype(np.uint64) for mask in node_attrs[DEFAULT_ATTR_KEYS.MASK]]\n        )\n\n    edge_dict = {k: {\"values\": column_to_numpy(v), \"missing\": None} for k, v in edge_attrs.to_dict().items()}\n\n    write_arrays(\n        geff_store,\n        node_ids=node_ids.astype(np.uint64),\n        node_props=node_dict,\n        edge_ids=edge_ids.astype(np.uint64),\n        edge_props=edge_dict,\n        metadata=geff_metadata,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: tracklet_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_traccuracy_graph","title":"to_traccuracy_graph","text":"<pre><code>to_traccuracy_graph(\n    array_view_kwargs: dict[str, Any] | None = None,\n) -&gt; TrackingGraph\n</code></pre> <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TrackingGraph</code>           \u2013            <p>A traccuracy graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_traccuracy_graph(self, array_view_kwargs: dict[str, Any] | None = None) -&gt; \"TrackingGraph\":\n    \"\"\"\n    Convert the graph to a `traccuracy.TrackingGraph`.\n\n    Parameters\n    ----------\n    array_view_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `GraphArrayView` constructor used to create the segmentation.\n\n    Returns\n    -------\n    TrackingGraph\n        A traccuracy graph.\n    \"\"\"\n    from tracksdata.metrics._traccuracy import to_traccuracy_graph\n\n    return to_traccuracy_graph(self, array_view_kwargs=array_view_kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.to_traccuracy_graph(array_view_kwargs)","title":"<code>array_view_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>GraphArrayView</code> constructor used to create the segmentation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    tracklet_id_key : str\n        The key of the track id attribute.\n    ignore_tracklet_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n    from tracksdata.functional._edges import join_node_attrs_to_edges\n\n    if tracklet_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{tracklet_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, tracklet_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_tracklet_id is not None:\n        nodes_df = nodes_df.filter(pl.col(tracklet_id_key) != ignore_tracklet_id)\n\n    track_ids = nodes_df[tracklet_id_key].unique().to_list()\n    tracklet_graph = rx.PyDiGraph()\n\n    rx_ids = np.asarray(tracklet_graph.add_nodes_from(track_ids), dtype=int)\n    track_id_to_rx_id = dict(zip(track_ids, rx_ids, strict=True))\n\n    src_col = f\"source_{tracklet_id_key}\"\n    tgt_col = f\"target_{tracklet_id_key}\"\n\n    edges_df = (\n        join_node_attrs_to_edges(\n            nodes_df,\n            edges_df,\n            how=\"right\",\n        )\n        .filter(pl.col(src_col) != pl.col(tgt_col))\n        .with_columns(\n            pl.col(src_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"source_rx_id\"),\n            pl.col(tgt_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"target_rx_id\"),\n        )\n    )\n\n    tracklet_graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[src_col].to_list(), edges_df[tgt_col].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return tracklet_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph(tracklet_id_key)","title":"<code>tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_graph(ignore_tracklet_id)","title":"<code>ignore_tracklet_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_nodes","title":"tracklet_nodes","text":"<pre><code>tracklet_nodes(seeds: list[int] | None) -&gt; list[int]\n</code></pre> <p>Compute the non-branching tracklets around the provided seed node_ids.</p> <p>Walks forward to successors only through nodes with exactly one successor, and backward to predecessors that also have out_degree == 1, until closure.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>Sorted unique node IDs forming the closure.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_nodes(self, seeds: list[int] | None) -&gt; list[int]:\n    \"\"\"\n    Compute the non-branching tracklets around the provided seed node_ids.\n\n    Walks forward to successors only through nodes with exactly one successor,\n    and backward to predecessors that also have out_degree == 1, until closure.\n\n    Parameters\n    ----------\n    seeds : list[int]\n        Seed node IDs where to start the closure.\n\n    Returns\n    -------\n    list[int]\n        Sorted unique node IDs forming the closure.\n    \"\"\"\n    # NOTE: if this function becomes a bottleneck in the future it might be worth having\n    # a specialized version per backend\n    if seeds is None or len(seeds) == 0:\n        return []\n\n    track_node_ids: set[int] = set()\n    active_ids: set[int] = set(seeds)\n\n    while len(active_ids) &gt; 0:\n        track_node_ids.update(active_ids)\n\n        # Successors: only nodes with exactly one successor\n        succ_map = self.successors(node_ids=list(active_ids))\n        successors = [int(nodes[0]) for nodes in succ_map.values() if len(nodes) == 1]\n\n        # Predecessors: only nodes with exactly one predecessor and predecessor out_degree == 1\n        pred_map = self.predecessors(node_ids=list(active_ids))\n        predecessors = [int(nodes[0]) for nodes in pred_map.values() if len(nodes) == 1]\n\n        if len(predecessors) &gt; 0:\n            out_degrees = self.out_degree(predecessors)\n            if isinstance(out_degrees, int):\n                out_degrees = [out_degrees]\n            predecessors = [node for node, degree in zip(predecessors, out_degrees, strict=True) if degree == 1]\n\n        active_ids = (set(successors) | set(predecessors)) - track_node_ids\n\n    return sorted(track_node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.tracklet_nodes(seeds)","title":"<code>seeds</code>","text":"(<code>list[int]</code>)           \u2013            <p>Seed node IDs where to start the closure.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs","title":"update_edge_attrs","text":"<pre><code>update_edge_attrs(\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n    if edge_ids is None:\n        edge_ids = self.edge_ids()\n\n    size = len(edge_ids)\n    for key, value in attrs.items():\n        if key not in self.edge_attr_keys:\n            raise ValueError(f\"Edge attribute key '{key}' not found in graph. Expected '{self.edge_attr_keys}'\")\n\n        if np.isscalar(value):\n            attrs[key] = [value] * size\n\n        elif len(attrs[key]) != size:\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {size}, got {len(attrs[key])}\")\n\n    edge_map = self._graph.edge_index_map()\n\n    for i, edge_id in enumerate(edge_ids):\n        edge_attr = edge_map[edge_id][2]  # 0=source, 1=target, 2=attributes\n        for key, value in attrs.items():\n            edge_attr[key] = value[i]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the node attributes of the graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the node attributes of the graph.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The node ids to update.\n    \"\"\"\n    node_ids = self._get_local_ids() if node_ids is None else self._map_to_local(node_ids)\n    super().update_node_attrs(attrs=attrs, node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.IndexedRXGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph","title":"RustWorkXGraph","text":"<pre><code>RustWorkXGraph(rx_graph: PyDiGraph | None = None)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <pre><code>\n              flowchart TD\n              tracksdata.graph.RustWorkXGraph[RustWorkXGraph]\n              tracksdata.graph._base_graph.BaseGraph[BaseGraph]\n\n                              tracksdata.graph._base_graph.BaseGraph --&gt; tracksdata.graph.RustWorkXGraph\n                \n\n\n              click tracksdata.graph.RustWorkXGraph href \"\" \"tracksdata.graph.RustWorkXGraph\"\n              click tracksdata.graph._base_graph.BaseGraph href \"\" \"tracksdata.graph._base_graph.BaseGraph\"\n            </code></pre> <p>High-performance in-memory graph implementation using rustworkx.</p> <p>RustWorkXGraph provides a fast, memory-efficient graph backend built on rustworkx (a Rust-based graph library). It stores nodes and edges in memory with their attributes, making it suitable for moderate-sized graphs that fit in RAM. This implementation offers excellent performance for graph algorithms and is the recommended choice for most tracking applications.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--parameters","title":"Parameters","text":"<p>rx_graph : rx.PyDiGraph | None, optional     An existing rustworkx directed graph to wrap. If None, creates a new     empty graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--attributes","title":"Attributes","text":"<p>rx_graph : rx.PyDiGraph     The underlying rustworkx directed graph object. _time_to_nodes : dict[int, list[int]]     Mapping from time points to lists of node IDs at that time. _node_attr_keys : list[str]     List of available node attribute keys. _edge_attr_keys : list[str]     List of available edge attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--see-also","title":"See Also","text":"<p>SQLGraph:     Database-backed graph implementation for larger datasets.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph--examples","title":"Examples","text":"<p>Create an empty graph:</p> <pre><code>from tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(source_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Filter nodes by attributes:</p> <pre><code>from tracksdata.attrs import NodeAttr\n\nnode_ids = graph.filter(NodeAttr(\"t\") == 0).node_ids()\n</code></pre> <p>Create subgraphs:</p> <pre><code>subgraph = graph.filter(NodeAttr(\"t\") == 0).subgraph()\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_edge_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_node_attr_key</code>             \u2013              <p>Add a new attribute key to the graph.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>contract_nodes</code>             \u2013              <p>Contract the graph to only include the given <code>permanent_node_ids</code>.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_attrs</code>             \u2013              <p>Get the attributes of the edges as a polars DataFrame.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>edge_ids</code>             \u2013              <p>Get the IDs of all edges in the graph.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_attrs</code>             \u2013              <p>Get the attributes of the nodes as a polars DataFrame.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessors of a list of nodes.</p> </li> <li> <code>remove_edge</code>             \u2013              <p>Remove an edge by ID or by endpoints.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the sucessors of a list of nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>time_points</code>             \u2013              <p>Get the unique time points in the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>to_traccuracy_graph</code>             \u2013              <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>tracklet_nodes</code>             \u2013              <p>Compute the non-branching tracklets around the provided seed node_ids.</p> </li> <li> <code>update_edge_attrs</code>             \u2013              <p>Update the attributes of the edges.</p> </li> <li> <code>update_node_attrs</code>             \u2013              <p>Update the attributes of the nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the edges.</p> </li> <li> <code>node_attr_keys</code>               (<code>list[str]</code>)           \u2013            <p>Get the keys of the attributes of the nodes.</p> </li> <li> <code>num_edges</code>               (<code>int</code>)           \u2013            <p>The number of edges in the graph.</p> </li> <li> <code>num_nodes</code>               (<code>int</code>)           \u2013            <p>The number of nodes in the graph.</p> </li> <li> <code>supports_custom_indices</code>               (<code>bool</code>)           \u2013            <p>Whether the graph backend supports custom indices.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def __init__(self, rx_graph: rx.PyDiGraph | None = None) -&gt; None:\n    super().__init__()\n\n    self._time_to_nodes: dict[int, list[int]] = {}\n    self._node_attr_keys: list[str] = []\n    self._edge_attr_keys: list[str] = []\n    self._overlaps: list[list[int, 2]] = []\n\n    if rx_graph is None:\n        self._graph = rx.PyDiGraph(attrs={})\n        self._node_attr_keys.append(DEFAULT_ATTR_KEYS.NODE_ID)\n        self._node_attr_keys.append(DEFAULT_ATTR_KEYS.T)\n\n    else:\n        self._graph = rx_graph\n\n        if self._graph.attrs is None:\n            self._graph.attrs = {}\n\n        elif not isinstance(self._graph.attrs, dict):\n            LOG.warning(\n                \"previous attribute %s will be added to key 'old_attrs' of `graph.metadata`\",\n                self._graph.attrs,\n            )\n            self._graph.attrs = {\n                \"old_attrs\": self._graph.attrs,\n            }\n\n        unique_node_attr_keys = set()\n        unique_edge_attr_keys = set()\n\n        for node_id in self._graph.node_indices():\n            node_attrs = self._graph[node_id]\n            try:\n                t = node_attrs[DEFAULT_ATTR_KEYS.T]\n            except KeyError as e:\n                raise ValueError(\n                    f\"Node attributes must have a '{DEFAULT_ATTR_KEYS.T}' key. Got {node_attrs.keys()}\"\n                ) from e\n\n            self._time_to_nodes.setdefault(int(t), []).append(node_id)\n\n            unique_node_attr_keys.update(node_attrs.keys())\n\n        edge_idx_map = self._graph.edge_index_map()\n        for edge_idx, (_, _, attr) in edge_idx_map.items():\n            unique_edge_attr_keys.update(attr.keys())\n            attr[DEFAULT_ATTR_KEYS.EDGE_ID] = edge_idx\n\n        self._node_attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, *unique_node_attr_keys]\n        self._edge_attr_keys = list(unique_edge_attr_keys)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attr_keys","title":"edge_attr_keys  <code>property</code>","text":"<pre><code>edge_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attr_keys","title":"node_attr_keys  <code>property</code>","text":"<pre><code>node_attr_keys: list[str]\n</code></pre> <p>Get the keys of the attributes of the nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_edges","title":"num_edges  <code>property</code>","text":"<pre><code>num_edges: int\n</code></pre> <p>The number of edges in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.num_nodes","title":"num_nodes  <code>property</code>","text":"<pre><code>num_nodes: int\n</code></pre> <p>The number of nodes in the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.supports_custom_indices","title":"supports_custom_indices  <code>property</code>","text":"<pre><code>supports_custom_indices: bool\n</code></pre> <p>Whether the graph backend supports custom indices.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs","title":"_filter_nodes_by_attrs","text":"<pre><code>_filter_nodes_by_attrs(\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Filter nodes by attributes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the filtered nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _filter_nodes_by_attrs(\n    self,\n    *attrs: AttrComparison,\n    node_ids: Sequence[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Filter nodes by attributes.\n\n    Parameters\n    ----------\n    *attrs : AttrComparison\n        The attributes to filter by, for example:\n    node_ids : list[int] | None\n        The IDs of the nodes to include in the filter.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the filtered nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    node_map = None\n    # entire graph\n    attrs, time = _pop_time_eq(attrs)\n    selected_nodes = None\n\n    if time is not None:\n        selected_nodes = self._time_to_nodes.get(time, [])\n\n        if node_ids is not None:\n            selected_nodes = np.intersect1d(selected_nodes, node_ids).tolist()\n\n        if len(attrs) == 0:\n            return selected_nodes\n\n    elif node_ids is not None:\n        selected_nodes = node_ids\n\n    if selected_nodes is not None:\n        # subgraph of selected nodes\n        rx_graph, node_map = rx_graph.subgraph_with_nodemap(selected_nodes)\n\n    _filter_func = _create_filter_func(attrs)\n\n    if node_map is None:\n        return list(rx_graph.filter_nodes(_filter_func))\n    else:\n        return [node_map[n] for n in rx_graph.filter_nodes(_filter_func)]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs(*attrs)","title":"<code>*attrs</code>","text":"(<code>AttrComparison</code>, default:                   <code>()</code> )           \u2013            <p>The attributes to filter by, for example:</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._filter_nodes_by_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to include in the filter. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(\n    neighbors_func: Callable[[PyDiGraph, int], NodeIndices],\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessors or sucessors of a list of nodes. See more information below.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    neighbors_func: Callable[[rx.PyDiGraph, int], rx.NodeIndices],\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessors or sucessors of a list of nodes.\n    See more information below.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    rx_graph = self.rx_graph\n    if not return_attrs and attr_keys is not None:\n        LOG.warning(\"attr_keys is ignored when return_attrs is False.\")\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n    valid_schema = None\n    neighbors: dict[int, list[int]] | dict[int, pl.DataFrame] = {}\n    for node_id in node_ids:\n        neighbors_indices = neighbors_func(rx_graph, node_id)\n        if not return_attrs:\n            neighbors[node_id] = [int(idx) for idx in neighbors_indices]\n        else:\n            neighbors_data: list[dict[str, Any]] = [rx_graph[i] for i in neighbors_indices]\n\n            if attr_keys is not None:\n                neighbors_data = [\n                    {k: neigh_attr[k] for k in attr_keys if k != DEFAULT_ATTR_KEYS.NODE_ID}\n                    for neigh_attr in neighbors_data\n                ]\n\n            if len(neighbors_data) &gt; 0:\n                df = pl.DataFrame(neighbors_data)\n                if attr_keys is None or DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n                    df = df.with_columns(\n                        pl.Series(DEFAULT_ATTR_KEYS.NODE_ID, np.asarray(neighbors_indices, dtype=int)),\n                    )\n                neighbors[node_id] = df\n                valid_schema = neighbors[node_id].schema\n\n    if not return_attrs:\n        default_value = []\n    elif valid_schema is None:\n        default_value = pl.DataFrame()\n    else:\n        default_value = pl.DataFrame(schema=valid_schema)\n\n    if single_node:\n        return neighbors.get(node_ids[0], default_value)\n    else:\n        for node_id in node_ids:\n            neighbors.setdefault(node_id, default_value)\n\n        return neighbors\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids","title":"_node_attrs_from_node_ids","text":"<pre><code>_node_attrs_from_node_ids(\n    *,\n    node_ids: list[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a polars DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>A polars DataFrame with the attributes of the nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _node_attrs_from_node_ids(\n    self,\n    *,\n    node_ids: list[int] | None = None,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a polars DataFrame.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the attributesfor.\n        If None, all nodes are used.\n    attr_keys : Sequence[str] | None\n        The attribute keys to get.\n        If None, all the attributes of the first node are used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n\n    Returns\n    -------\n    pl.DataFrame\n        A polars DataFrame with the attributes of the nodes.\n    \"\"\"\n    rx_graph = self.rx_graph\n    # If no node_ids provided, use all nodes\n    if node_ids is None:\n        node_ids = list(rx_graph.node_indices())\n\n    if attr_keys is None:\n        attr_keys = self.node_attr_keys\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    if len(node_ids) == 0:\n        return pl.DataFrame({key: [] for key in attr_keys})\n\n    # making them unique\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    # Create columns directly instead of building intermediate dictionaries\n    columns = {key: [] for key in attr_keys}\n\n    if DEFAULT_ATTR_KEYS.NODE_ID in attr_keys:\n        columns[DEFAULT_ATTR_KEYS.NODE_ID] = np.asarray(node_ids, dtype=int)\n        attr_keys.remove(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    # Build columns in a vectorized way\n    for node_id in node_ids:\n        node_data = rx_graph[node_id]\n        for key in attr_keys:\n            columns[key].append(node_data[key])\n\n    for key in attr_keys:\n        columns[key] = np.asarray(columns[key])\n\n    # Create DataFrame and set node_id as index in one shot\n    df = pl.DataFrame(columns)\n\n    if unpack:\n        df = unpack_array_attrs(df)\n\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the attributesfor. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all the attributes of the first node are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._node_attrs_from_node_ids(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._rx_subgraph_with_nodemap","title":"_rx_subgraph_with_nodemap","text":"<pre><code>_rx_subgraph_with_nodemap(\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]\n</code></pre> <p>Get a subgraph of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PyDiGraph, NodeMap]</code>           \u2013            <p>The subgraph and the node map.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def _rx_subgraph_with_nodemap(\n    self,\n    node_ids: Sequence[int] | None = None,\n) -&gt; tuple[rx.PyDiGraph, rx.NodeMap]:\n    \"\"\"\n    Get a subgraph of the graph.\n\n    Parameters\n    ----------\n    node_ids : Sequence[int] | None\n        The node ids to include in the subgraph.\n\n    Returns\n    -------\n    tuple[rx.PyDiGraph, rx.NodeMap]\n        The subgraph and the node map.\n    \"\"\"\n    rx_graph, node_map = self.rx_graph.subgraph_with_nodemap(node_ids)\n    return rx_graph, node_map\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._rx_subgraph_with_nodemap(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The node ids to include in the subgraph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys() and ref_key != DEFAULT_ATTR_KEYS.NODE_ID:\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        The attributes of the edge to be added.\n        The keys of the attributes will be used as the attributes of the edge.\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n    edge_id = self.rx_graph.add_edge(source_id, target_id, attrs)\n    attrs[DEFAULT_ATTR_KEYS.EDGE_ID] = edge_id\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the edge to be added. The keys of the attributes will be used as the attributes of the edge.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key","title":"add_edge_attr_key","text":"<pre><code>add_edge_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing edges will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_edge_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing edges will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing edges for the new attribute key.\n    \"\"\"\n    if key in self.edge_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._edge_attr_keys.append(key)\n    for _, _, edge_attr in self.rx_graph.weighted_edge_list():\n        edge_attr[key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_edge_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing edges for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node","title":"add_node","text":"<pre><code>add_node(\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Parameters\n    ----------\n    attrs : Any\n        The attributes of the node to be added, must have a \"t\" key.\n        The keys of the attributes will be used as the attributes of the node.\n        For example:\n        ```python\n        graph.add_node(dict(t=0, label=\"A\", intensity=100))\n        ```\n    validate_keys : bool\n        Whether to check if the attributes keys are valid.\n        If False, the attributes keys will not be checked,\n        useful to speed up the operation when doing bulk insertions.\n    index : int | None\n        Optional node index. RustWorkXGraph does not support custom indices\n        and will raise an error if this parameter is provided.\n    \"\"\"\n    if index is not None:\n        raise ValueError(\"RustWorkXGraph does not support custom node indices. Use IndexedRXGraph instead.\")\n\n    # avoiding copying attributes on purpose, it could be a problem in the future\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    node_id = self.rx_graph.add_node(attrs)\n    self._time_to_nodes.setdefault(attrs[\"t\"], []).append(node_id)\n    self.node_added.emit_fast(node_id)\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>Any</code>)           \u2013            <p>The attributes of the node to be added, must have a \"t\" key. The keys of the attributes will be used as the attributes of the node. For example: <pre><code>graph.add_node(dict(t=0, label=\"A\", intensity=100))\n</code></pre></p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attributes keys are valid. If False, the attributes keys will not be checked, useful to speed up the operation when doing bulk insertions.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional node index. RustWorkXGraph does not support custom indices and will raise an error if this parameter is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key","title":"add_node_attr_key","text":"<pre><code>add_node_attr_key(key: str, default_value: Any) -&gt; None\n</code></pre> <p>Add a new attribute key to the graph. All existing nodes will have the default value for the new attribute key.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_node_attr_key(self, key: str, default_value: Any) -&gt; None:\n    \"\"\"\n    Add a new attribute key to the graph.\n    All existing nodes will have the default value for the new attribute key.\n\n    Parameters\n    ----------\n    key : str\n        The key of the new attribute.\n    default_value : Any\n        The default value for existing nodes for the new attribute key.\n    \"\"\"\n    if key in self.node_attr_keys:\n        raise ValueError(f\"Attribute key {key} already exists\")\n\n    self._node_attr_keys.append(key)\n    rx_graph = self.rx_graph\n    for node_id in rx_graph.node_indices():\n        rx_graph[node_id][key] = default_value\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the new attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_node_attr_key(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>)           \u2013            <p>The default value for existing nodes for the new attribute key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the added overlap.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    self._overlaps.append([source_id, target_id])\n    return len(self._overlaps) - 1\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.add_overlap(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    cache_key = (frame_attr_key, bbox_attr_key)\n    if not hasattr(self, \"_bbox_spatial_filter_cache\") or clear_cache:\n        self._bbox_spatial_filter_cache: dict[tuple[str | None, str], BBoxSpatialFilter] = {}\n\n    if cache_key not in self._bbox_spatial_filter_cache:\n        self._bbox_spatial_filter_cache[cache_key] = BBoxSpatialFilter(\n            self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key\n        )\n    return self._bbox_spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bbox_spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: bool = False\n) -&gt; list[int] | None\n</code></pre> <p>Faster method to add multiple edges to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int] | None</code>           \u2013            <p>The IDs of the added edges.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_edges(self, edges: list[dict[str, Any]], return_ids: bool = False) -&gt; list[int] | None:\n    \"\"\"\n    Faster method to add multiple edges to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        The data of the edges to be added.\n        The keys of the data will be used as the attributes of the edges.\n        Must have \"source_id\" and \"target_id\" keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Returns\n    -------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    # saving for historical reasons, iterating over edges is faster than using rx.add_edges_from\n    # edges_data = [(d.pop(DEFAULT_ATTR_KEYS.EDGE_SOURCE), d.pop(DEFAULT_ATTR_KEYS.EDGE_TARGET), d) for d in edges]\n    # indices = self.rx_graph.add_edges_from(edges_data)\n    # for i, d in zip(indices, edges, strict=True):\n    #     d[DEFAULT_ATTR_KEYS.EDGE_ID] = i\n    # return indices\n    return super().bulk_add_edges(edges, return_ids=return_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the edges to be added. The keys of the data will be used as the attributes of the edges. Must have \"source_id\" and \"target_id\" keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Faster method to add multiple nodes to the graph with less overhead and fewer checks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def bulk_add_nodes(self, nodes: list[dict[str, Any]], indices: list[int] | None = None) -&gt; list[int]:\n    \"\"\"\n    Faster method to add multiple nodes to the graph with less overhead and fewer checks.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        The data of the nodes to be added.\n        The keys of the data will be used as the attributes of the nodes.\n        Must have \"t\" key.\n    indices : list[int] | None\n        Optional list of node indices. RustWorkXGraph does not support custom indices\n        and will raise an error if this parameter is provided.\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if indices is not None:\n        raise ValueError(\"RustWorkXGraph does not support custom node indices. Use IndexedRXGraph instead.\")\n\n    node_indices = list(self.rx_graph.add_nodes_from(nodes))\n    for node, index in zip(nodes, node_indices, strict=True):\n        self._time_to_nodes.setdefault(node[\"t\"], []).append(index)\n\n    # checking if it has connections to reduce overhead\n    if is_signal_on(self.node_added):\n        for node_id in node_indices:\n            self.node_added.emit_fast(node_id)\n\n    return node_indices\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>The data of the nodes to be added. The keys of the data will be used as the attributes of the nodes. Must have \"t\" key.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of node indices. RustWorkXGraph does not support custom indices and will raise an error if this parameter is provided.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.BaseGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    for source_id, target_id in overlaps:\n        self.add_overlap(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes","title":"contract_nodes","text":"<pre><code>contract_nodes(\n    permanent_node_ids: Sequence[int],\n) -&gt; GraphView\n</code></pre> <p>Contract the graph to only include the given <code>permanent_node_ids</code>. Predecessor and sucessors of removed nodes are connected during contraction.</p> <p>Example:</p> <pre><code>graph TD\n    A((t=0)) --&gt; B((t=1))\n    A --&gt; C((t=1))\n    B --&gt; D((t=2))\n    C --&gt; E((t=2))\n    C --&gt; F((t=2))</code></pre> <p>After contraction only keeping nodes in <code>t=0</code> and <code>t=2</code>: <pre><code>graph TD\n    A((t=0)) --&gt; B((t=2))\n    A --&gt; C((t=2))\n    A --&gt; D((t=2))</code></pre></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>GraphView</code>           \u2013            <p>A view of the contracted graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def contract_nodes(\n    self,\n    permanent_node_ids: Sequence[int],\n) -&gt; \"GraphView\":\n    \"\"\"\n    Contract the graph to only include the given `permanent_node_ids`.\n    Predecessor and sucessors of removed nodes are connected during contraction.\n\n    Example:\n\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=1))\n        A --&gt; C((t=1))\n        B --&gt; D((t=2))\n        C --&gt; E((t=2))\n        C --&gt; F((t=2))\n    ```\n\n    After contraction only keeping nodes in `t=0` and `t=2`:\n    ```mermaid\n    graph TD\n        A((t=0)) --&gt; B((t=2))\n        A --&gt; C((t=2))\n        A --&gt; D((t=2))\n    ```\n\n    Parameters\n    ----------\n    permanent_node_ids : Sequence[int]\n        The node ids to keep in the contracted graph.\n\n    Returns\n    -------\n    GraphView\n        A view of the contracted graph.\n    \"\"\"\n    from tracksdata.graph._graph_view import GraphView\n\n    all_node_ids = np.asarray(self.node_ids())\n    selected_nodes_mask = np.isin(all_node_ids, permanent_node_ids)\n    missing_node_ids = all_node_ids[~selected_nodes_mask]\n\n    # must block multigraphs to avoid edge duplication\n    rx_graph = rx.PyDiGraph(multigraph=False)\n    new_indices = rx_graph.add_nodes_from(self.rx_graph.nodes())\n    rx_graph.add_edges_from(self.rx_graph.weighted_edge_list())\n\n    for node_id in missing_node_ids:\n        rx_graph.remove_node_retain_edges(\n            node_id,\n            use_outgoing=True,\n            condition=lambda *args: True,\n        )\n\n    node_map_to_root = dict(\n        zip(\n            np.asarray(new_indices)[selected_nodes_mask].tolist(),\n            permanent_node_ids,\n            strict=True,\n        )\n    )\n\n    # I'm a bit concerned with the internal booking of indices of rustworkx\n    # so I'm adding this sanity check\n    assert len(node_map_to_root) == rx_graph.num_nodes()\n\n    graph_view = GraphView(rx_graph, node_map_to_root=node_map_to_root, root=self)\n\n    return graph_view\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.contract_nodes(permanent_node_ids)","title":"<code>permanent_node_ids</code>","text":"(<code>Sequence[int]</code>)           \u2013            <p>The node ids to keep in the contracted graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs","title":"edge_attrs","text":"<pre><code>edge_attrs(\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the edges as a polars DataFrame.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the edges as a polars DataFrame.\n\n    Parameters\n    ----------\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to get.\n        If None, all attributesare used.\n    unpack : bool\n        Whether to unpack array attributesinto multiple scalar attributes.\n    \"\"\"\n    if attr_keys is None:\n        attr_keys = self.edge_attr_keys\n\n    attr_keys = [DEFAULT_ATTR_KEYS.EDGE_ID, *attr_keys]\n    attr_keys = list(dict.fromkeys(attr_keys))\n\n    rx_graph = self.rx_graph\n\n    edge_map = rx_graph.edge_index_map()\n    if len(edge_map) == 0:\n        return pl.DataFrame(\n            {\n                key: []\n                for key in [\n                    *attr_keys,\n                    DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n                    DEFAULT_ATTR_KEYS.EDGE_TARGET,\n                ]\n            }\n        )\n\n    source, target, data = zip(*edge_map.values(), strict=False)\n\n    columns = {key: [] for key in attr_keys}\n\n    for row in data:\n        for key in attr_keys:\n            columns[key].append(row[key])\n\n    columns[DEFAULT_ATTR_KEYS.EDGE_SOURCE] = source\n    columns[DEFAULT_ATTR_KEYS.EDGE_TARGET] = target\n\n    columns = {k: np.asarray(v) for k, v in columns.items()}\n\n    df = pl.DataFrame(columns)\n    if unpack:\n        df = unpack_array_attrs(df)\n    return df\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to get. If None, all attributesare used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_attrs(unpack)","title":"<code>unpack</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to unpack array attributesinto multiple scalar attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    return self.rx_graph.get_edge_data(source_id, target_id)[DEFAULT_ATTR_KEYS.EDGE_ID]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.edge_ids","title":"edge_ids","text":"<pre><code>edge_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all edges in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def edge_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all edges in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.edge_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. tracklet_ids : np.ndarray | None     Track ids of the nodes if available. tracklet_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    tracklet_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    tracklet_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        tracklet_ids=tracklet_ids,\n        tracklet_id_graph=tracklet_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> <li> <code>geff_metadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The geff metadata of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    geff_read_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `geff.read` function.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    geff_metadata : GeffMetadata\n        The geff metadata of the graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    if geff_read_kwargs is None:\n        geff_read_kwargs = {}\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, geff_metadata = geff.read(geff_store, backend=\"rustworkx\", **geff_read_kwargs)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    node_id_map = rx_graph.attrs[\"to_rx_id_map\"]\n    rx_graph.attrs = {\"geff\": rx_graph.attrs, **rx_graph.attrs[\"extra\"].pop(\"tracksdata\", {})}\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=node_id_map,\n        **kwargs,\n    )\n\n    if DEFAULT_ATTR_KEYS.MASK in indexed_graph.node_attr_keys:\n        from tracksdata.nodes._mask import Mask\n\n        # unsafe operation, changing graph content inplace\n        for node_attr in indexed_graph.rx_graph.nodes():\n            node_attr[DEFAULT_ATTR_KEYS.MASK] = Mask(\n                node_attr[DEFAULT_ATTR_KEYS.MASK].astype(bool),\n                bbox=node_attr[DEFAULT_ATTR_KEYS.BBOX],\n            )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph, geff_metadata\n\n    return cls.from_other(indexed_graph, **kwargs), geff_metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff(geff_read_kwargs)","title":"<code>geff_read_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>geff.read</code> function.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            first_value = node_attrs[col].first()\n            graph.add_node_attr_key(col, infer_default_value(first_value))\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    return self.rx_graph.has_edge(source_id, target_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the graph has any overlaps, False otherwise.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n\n    Returns\n    -------\n    bool\n        True if the graph has any overlaps, False otherwise.\n    \"\"\"\n    return len(self.overlaps()) &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.in_degree(node_ids)\n    return [rx_graph.in_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match","title":"match","text":"<pre><code>match(\n    other: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_attrs","title":"node_attrs","text":"<pre><code>node_attrs(\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame\n</code></pre> <p>Get the attributes of the nodes as a polars DataFrame.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_attrs(\n    self,\n    *,\n    attr_keys: Sequence[str] | str | None = None,\n    unpack: bool = False,\n) -&gt; pl.DataFrame:\n    \"\"\"\n    Get the attributes of the nodes as a polars DataFrame.\n    \"\"\"\n    return self._node_attrs_from_node_ids(attr_keys=attr_keys, unpack=unpack)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n    \"\"\"\n    return [int(i) for i in self.rx_graph.node_indices()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n    rx_graph = self.rx_graph\n    if isinstance(node_ids, int):\n        return rx_graph.out_degree(node_ids)\n    return [rx_graph.out_degree(node_id) for node_id in node_ids]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>. If <code>node_ids</code> is None, all nodes are used.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int, 2]]</code>           \u2013            <p>The overlaps between the nodes in <code>node_ids</code>.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    If `node_ids` is None, all nodes are used.\n\n    Parameters\n    ----------\n    node_ids : list[int] | None\n        The IDs of the nodes to get the overlaps for.\n        If None, all nodes are used.\n\n    Returns\n    -------\n    list[list[int, 2]]\n        The overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if len(self._overlaps) == 0:\n        return []\n\n    if node_ids is None:\n        return self._overlaps\n\n    node_ids = np.asarray(node_ids, dtype=int)\n    overlaps_arr = np.asarray(self._overlaps, dtype=int)\n\n    is_in_source = np.isin(overlaps_arr[:, 0], node_ids)\n    is_in_target = np.isin(overlaps_arr[:, 1], node_ids)\n    return overlaps_arr[is_in_source &amp; is_in_target].tolist()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.overlaps(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to get the overlaps for. If None, all nodes are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the predecessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only predecessor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.predecessor_indices,\n        node_ids,\n        attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.predecessors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only predecessor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.remove_edge","title":"remove_edge","text":"<pre><code>remove_edge(\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an edge by ID or by endpoints.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_edge(\n    self,\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an edge by ID or by endpoints.\n    \"\"\"\n    if edge_id is None:\n        if source_id is None or target_id is None:\n            raise ValueError(\"Provide either edge_id or both source_id and target_id.\")\n        try:\n            self.rx_graph.remove_edge(source_id, target_id)\n        except rx.NoEdgeBetweenNodes as e:\n            raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\") from e\n    else:\n        edge_map = self.rx_graph.edge_index_map()\n        if edge_id not in edge_map:\n            raise ValueError(f\"Edge {edge_id} does not exist in the graph.\")\n        src, tgt, _ = edge_map[edge_id]\n        self.rx_graph.remove_edge(src, tgt)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges). Also updates the time_to_nodes mapping.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges). Also updates the time_to_nodes mapping.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    if node_id not in self.rx_graph.node_indices():\n        raise ValueError(f\"Node {node_id} does not exist in the graph.\")\n\n    self.node_removed.emit_fast(node_id)\n\n    # Get the time value before removing the node\n    t = self.rx_graph[node_id][\"t\"]\n\n    # Remove the node from the graph (this also removes all connected edges)\n    self.rx_graph.remove_node(node_id)\n\n    # Update the time_to_nodes mapping\n    self._time_to_nodes[t].remove(node_id)\n    # Clean up empty time entries\n    if not self._time_to_nodes[t]:\n        del self._time_to_nodes[t]\n\n    # Remove from overlaps if present\n    if self._overlaps is not None:\n        self._overlaps = [overlap for overlap in self._overlaps if node_id != overlap[0] and node_id != overlap[1]]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(\n    attr_keys: list[str] | None = None,\n    clear_cache: bool = False,\n) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None, clear_cache: bool = False) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    cache_key = None if attr_keys is None else tuple(attr_keys)\n    if not hasattr(self, \"_spatial_filter_cache\") or clear_cache:\n        self._spatial_filter_cache: dict[tuple[str, ...] | None, SpatialFilter] = {}\n\n    if cache_key not in self._spatial_filter_cache:\n        self._spatial_filter_cache[cache_key] = SpatialFilter(self, attr_keys=attr_keys)\n\n    return self._spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors","title":"successors","text":"<pre><code>successors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the sucessors of a list of nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the sucessors of a list of nodes.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get the sucessors for.\n    attr_keys : Sequence[str] | str | None\n        The attribute keys to retrieve when ``return_attrs`` is True.\n        If None, all attributes are included.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only successor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n    return self._get_neighbors(\n        rx.PyDiGraph.successor_indices,\n        node_ids,\n        attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get the sucessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve when <code>return_attrs</code> is True. If None, all attributes are included.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.successors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only successor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary","title":"summary","text":"<pre><code>summary(\n    attrs_stats: bool = False, print_summary: bool = True\n) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.time_points","title":"time_points","text":"<pre><code>time_points() -&gt; list[int]\n</code></pre> <p>Get the unique time points in the graph.</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def time_points(self) -&gt; list[int]:\n    \"\"\"\n    Get the unique time points in the graph.\n    \"\"\"\n    return list(self._time_to_nodes.keys())\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--parameters","title":"Parameters","text":"<p>output_dir : str | Path     The directory to save the graph to. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_tracklet_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        The directory to save the graph to.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_tracklet_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        tracklet_id_key=tracklet_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: geff.GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: tracklet_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n    node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy()\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACKLET_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACKLET_ID,\n            }\n        else:\n            track_node_props = None\n\n        node_props_metadata = {\n            k: PropMetadata(\n                identifier=k,\n                dtype=polars_dtype_to_numpy_dtype(v.dtype) if k != DEFAULT_ATTR_KEYS.MASK else np.uint64,\n                varlength=k == DEFAULT_ATTR_KEYS.MASK,\n            )\n            for k, v in node_attrs.to_dict().items()\n        }\n        edge_props_metadata = {\n            k: PropMetadata(identifier=k, dtype=polars_dtype_to_numpy_dtype(v.dtype))\n            for k, v in edge_attrs.to_dict().items()\n        }\n\n        td_metadata = self.metadata.copy()\n        td_metadata.pop(\"geff\", None)  # avoid geff being written multiple times\n\n        geff_metadata = geff.GeffMetadata(\n            directed=True,\n            axes=axes,\n            node_props_metadata=node_props_metadata,\n            edge_props_metadata=edge_props_metadata,\n            track_node_props=track_node_props,\n            extra={\n                \"tracksdata\": td_metadata,\n            },\n        )\n\n    node_dict = {\n        k: {\"values\": column_to_numpy(v), \"missing\": None}\n        for k, v in node_attrs.to_dict().items()\n        if k != DEFAULT_ATTR_KEYS.MASK\n    }\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_dict[DEFAULT_ATTR_KEYS.MASK] = construct_var_len_props(\n            [mask.mask.astype(np.uint64) for mask in node_attrs[DEFAULT_ATTR_KEYS.MASK]]\n        )\n\n    edge_dict = {k: {\"values\": column_to_numpy(v), \"missing\": None} for k, v in edge_attrs.to_dict().items()}\n\n    write_arrays(\n        geff_store,\n        node_ids=node_ids.astype(np.uint64),\n        node_props=node_dict,\n        edge_ids=edge_ids.astype(np.uint64),\n        edge_props=edge_dict,\n        metadata=geff_metadata,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: tracklet_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_traccuracy_graph","title":"to_traccuracy_graph","text":"<pre><code>to_traccuracy_graph(\n    array_view_kwargs: dict[str, Any] | None = None,\n) -&gt; TrackingGraph\n</code></pre> <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TrackingGraph</code>           \u2013            <p>A traccuracy graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_traccuracy_graph(self, array_view_kwargs: dict[str, Any] | None = None) -&gt; \"TrackingGraph\":\n    \"\"\"\n    Convert the graph to a `traccuracy.TrackingGraph`.\n\n    Parameters\n    ----------\n    array_view_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `GraphArrayView` constructor used to create the segmentation.\n\n    Returns\n    -------\n    TrackingGraph\n        A traccuracy graph.\n    \"\"\"\n    from tracksdata.metrics._traccuracy import to_traccuracy_graph\n\n    return to_traccuracy_graph(self, array_view_kwargs=array_view_kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.to_traccuracy_graph(array_view_kwargs)","title":"<code>array_view_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>GraphArrayView</code> constructor used to create the segmentation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> See Also <p>rx_digraph_to_napari_dict:     Convert a tracklet graph to a napari-ready dictionary.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    tracklet_id_key : str\n        The key of the track id attribute.\n    ignore_tracklet_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n\n    See Also\n    --------\n    [rx_digraph_to_napari_dict][tracksdata.functional.rx_digraph_to_napari_dict]:\n        Convert a tracklet graph to a napari-ready dictionary.\n    \"\"\"\n    from tracksdata.functional._edges import join_node_attrs_to_edges\n\n    if tracklet_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{tracklet_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    nodes_df = self.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, tracklet_id_key])\n    edges_df = self.edge_attrs(attr_keys=[])\n\n    if ignore_tracklet_id is not None:\n        nodes_df = nodes_df.filter(pl.col(tracklet_id_key) != ignore_tracklet_id)\n\n    track_ids = nodes_df[tracklet_id_key].unique().to_list()\n    tracklet_graph = rx.PyDiGraph()\n\n    rx_ids = np.asarray(tracklet_graph.add_nodes_from(track_ids), dtype=int)\n    track_id_to_rx_id = dict(zip(track_ids, rx_ids, strict=True))\n\n    src_col = f\"source_{tracklet_id_key}\"\n    tgt_col = f\"target_{tracklet_id_key}\"\n\n    edges_df = (\n        join_node_attrs_to_edges(\n            nodes_df,\n            edges_df,\n            how=\"right\",\n        )\n        .filter(pl.col(src_col) != pl.col(tgt_col))\n        .with_columns(\n            pl.col(src_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"source_rx_id\"),\n            pl.col(tgt_col)\n            .map_elements(track_id_to_rx_id.__getitem__, return_dtype=pl.Int64)\n            .alias(\"target_rx_id\"),\n        )\n    )\n\n    tracklet_graph.add_edges_from(\n        zip(\n            edges_df[\"source_rx_id\"].to_list(),\n            edges_df[\"target_rx_id\"].to_list(),\n            zip(edges_df[src_col].to_list(), edges_df[tgt_col].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return tracklet_graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph(tracklet_id_key)","title":"<code>tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_graph(ignore_tracklet_id)","title":"<code>ignore_tracklet_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_nodes","title":"tracklet_nodes","text":"<pre><code>tracklet_nodes(seeds: list[int] | None) -&gt; list[int]\n</code></pre> <p>Compute the non-branching tracklets around the provided seed node_ids.</p> <p>Walks forward to successors only through nodes with exactly one successor, and backward to predecessors that also have out_degree == 1, until closure.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>Sorted unique node IDs forming the closure.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_nodes(self, seeds: list[int] | None) -&gt; list[int]:\n    \"\"\"\n    Compute the non-branching tracklets around the provided seed node_ids.\n\n    Walks forward to successors only through nodes with exactly one successor,\n    and backward to predecessors that also have out_degree == 1, until closure.\n\n    Parameters\n    ----------\n    seeds : list[int]\n        Seed node IDs where to start the closure.\n\n    Returns\n    -------\n    list[int]\n        Sorted unique node IDs forming the closure.\n    \"\"\"\n    # NOTE: if this function becomes a bottleneck in the future it might be worth having\n    # a specialized version per backend\n    if seeds is None or len(seeds) == 0:\n        return []\n\n    track_node_ids: set[int] = set()\n    active_ids: set[int] = set(seeds)\n\n    while len(active_ids) &gt; 0:\n        track_node_ids.update(active_ids)\n\n        # Successors: only nodes with exactly one successor\n        succ_map = self.successors(node_ids=list(active_ids))\n        successors = [int(nodes[0]) for nodes in succ_map.values() if len(nodes) == 1]\n\n        # Predecessors: only nodes with exactly one predecessor and predecessor out_degree == 1\n        pred_map = self.predecessors(node_ids=list(active_ids))\n        predecessors = [int(nodes[0]) for nodes in pred_map.values() if len(nodes) == 1]\n\n        if len(predecessors) &gt; 0:\n            out_degrees = self.out_degree(predecessors)\n            if isinstance(out_degrees, int):\n                out_degrees = [out_degrees]\n            predecessors = [node for node, degree in zip(predecessors, out_degrees, strict=True) if degree == 1]\n\n        active_ids = (set(successors) | set(predecessors)) - track_node_ids\n\n    return sorted(track_node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.tracklet_nodes(seeds)","title":"<code>seeds</code>","text":"(<code>list[int]</code>)           \u2013            <p>Seed node IDs where to start the closure.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs","title":"update_edge_attrs","text":"<pre><code>update_edge_attrs(\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the attributes of the edges.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_edge_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    edge_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the edges.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        Attributes to be updated.\n    edge_ids : Sequence[int] | None\n        The IDs of the edges to update or None to update all edges.\n    \"\"\"\n    if edge_ids is None:\n        edge_ids = self.edge_ids()\n\n    size = len(edge_ids)\n    for key, value in attrs.items():\n        if key not in self.edge_attr_keys:\n            raise ValueError(f\"Edge attribute key '{key}' not found in graph. Expected '{self.edge_attr_keys}'\")\n\n        if np.isscalar(value):\n            attrs[key] = [value] * size\n\n        elif len(attrs[key]) != size:\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {size}, got {len(attrs[key])}\")\n\n    edge_map = self._graph.edge_index_map()\n\n    for i, edge_id in enumerate(edge_ids):\n        edge_attr = edge_map[edge_id][2]  # 0=source, 1=target, 2=attributes\n        for key, value in attrs.items():\n            edge_attr[key] = value[i]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Attributes to be updated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_edge_attrs(edge_ids)","title":"<code>edge_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the edges to update or None to update all edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs","title":"update_node_attrs","text":"<pre><code>update_node_attrs(\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None\n</code></pre> <p>Update the attributes of the nodes.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_rustworkx_graph.py</code> <pre><code>def update_node_attrs(\n    self,\n    *,\n    attrs: dict[str, Any],\n    node_ids: Sequence[int] | None = None,\n) -&gt; None:\n    \"\"\"\n    Update the attributes of the nodes.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to update.\n    node_ids : Sequence[int] | None\n        The IDs of the nodes to update or None to update all nodes.\n    \"\"\"\n    if node_ids is None:\n        node_ids = self.node_ids()\n\n    for key, value in attrs.items():\n        if key not in self.node_attr_keys:\n            raise ValueError(f\"Node attribute key '{key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n        if not np.isscalar(value) and len(attrs[key]) != len(node_ids):\n            raise ValueError(f\"Attribute '{key}' has wrong size. Expected {len(node_ids)}, got {len(attrs[key])}\")\n\n    for key, value in attrs.items():\n        if np.isscalar(value):\n            value = [value] * len(node_ids)\n\n        for node_id, v in zip(node_ids, value, strict=False):\n            self._graph[node_id][key] = v\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to update.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.RustWorkXGraph.update_node_attrs(node_ids)","title":"<code>node_ids</code>","text":"(<code>Sequence[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The IDs of the nodes to update or None to update all nodes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph","title":"SQLGraph","text":"<pre><code>SQLGraph(\n    drivername: str,\n    database: str,\n    username: str | None = None,\n    password: str | None = None,\n    host: str | None = None,\n    port: int | None = None,\n    engine_kwargs: dict[str, Any] | None = None,\n    overwrite: bool = False,\n)\n</code></pre> <p>               Bases: <code>BaseGraph</code></p> <pre><code>\n              flowchart TD\n              tracksdata.graph.SQLGraph[SQLGraph]\n              tracksdata.graph._base_graph.BaseGraph[BaseGraph]\n\n                              tracksdata.graph._base_graph.BaseGraph --&gt; tracksdata.graph.SQLGraph\n                \n\n\n              click tracksdata.graph.SQLGraph href \"\" \"tracksdata.graph.SQLGraph\"\n              click tracksdata.graph._base_graph.BaseGraph href \"\" \"tracksdata.graph._base_graph.BaseGraph\"\n            </code></pre> <p>SQL-based graph implementation using SQLAlchemy ORM.</p> <p>Provides persistent storage and efficient querying of large graphs with support for dynamic schema modification and various database backends. Node IDs are automatically generated based on time to ensure uniqueness across time points.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--parameters","title":"Parameters","text":"<p>drivername : str     The database driver name (e.g., 'sqlite', 'postgresql', 'mysql'). database : str     The database name or path. For SQLite, this is the file path. username : str, optional     Database username. Not required for SQLite. password : str, optional     Database password. Not required for SQLite. host : str, optional     Database host. Not required for SQLite. port : int, optional     Database port. Not required for SQLite. overwrite : bool, default False     If True, drop and recreate all tables. Use with caution as this     will delete all existing data.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--attributes","title":"Attributes","text":"<p>node_id_time_multiplier : int     Multiplier used to generate node IDs based on time (default: 1,000,000,000). Base : type[DeclarativeBase]     SQLAlchemy declarative base class for this graph instance. Node : type[DeclarativeBase]     SQLAlchemy model class for nodes. Edge : type[DeclarativeBase]     SQLAlchemy model class for edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--see-also","title":"See Also","text":"<p>RustWorkXGraph:     In memory Rustworkx-based graph implementation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph--examples","title":"Examples","text":"<p>Create an in-memory SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \":memory:\")\n</code></pre> <p>Create a persistent SQLite graph:</p> <pre><code>graph = SQLGraph(\"sqlite\", \"my_graph.db\")\n</code></pre> <p>Create a PostgreSQL graph:</p> <pre><code>graph = SQLGraph(\"postgresql\", \"tracking_db\", username=\"user\", password=\"pass\", host=\"localhost\", port=5432)\n</code></pre> <p>Add nodes and edges:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nedge_id = graph.add_edge(node_id, target_id, {\"weight\": 0.8})\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Helper method to interact with a single node.</p> </li> <li> <code>add_edge</code>             \u2013              <p>Add an edge to the graph.</p> </li> <li> <code>add_node</code>             \u2013              <p>Add a node to the graph at time t.</p> </li> <li> <code>add_overlap</code>             \u2013              <p>Add a new overlap to the graph.</p> </li> <li> <code>bbox_spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> </li> <li> <code>bulk_add_edges</code>             \u2013              <p>Add multiple edges to the graph efficiently.</p> </li> <li> <code>bulk_add_nodes</code>             \u2013              <p>Add multiple nodes to the graph efficiently.</p> </li> <li> <code>bulk_add_overlaps</code>             \u2013              <p>Add multiple overlaps to the graph.</p> </li> <li> <code>compute_overlaps</code>             \u2013              <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> </li> <li> <code>copy</code>             \u2013              <p>Create a copy of this graph.</p> </li> <li> <code>edge_id</code>             \u2013              <p>Return the edge id between two nodes.</p> </li> <li> <code>from_array</code>             \u2013              <p>Create a graph from a numpy array.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Create a graph from a CTC data directory.</p> </li> <li> <code>from_geff</code>             \u2013              <p>Create a graph from a geff data directory.</p> </li> <li> <code>from_other</code>             \u2013              <p>Create a graph from another graph.</p> </li> <li> <code>has_edge</code>             \u2013              <p>Check if the graph has an edge between two nodes.</p> </li> <li> <code>has_overlaps</code>             \u2013              <p>Check if the graph has any overlaps.</p> </li> <li> <code>in_degree</code>             \u2013              <p>Get the in-degree of a list of nodes.</p> </li> <li> <code>match</code>             \u2013              <p>Match the nodes of the graph to the nodes of another graph.</p> </li> <li> <code>node_ids</code>             \u2013              <p>Get the IDs of all nodes in the graph.</p> </li> <li> <code>out_degree</code>             \u2013              <p>Get the out-degree of a list of nodes.</p> </li> <li> <code>overlaps</code>             \u2013              <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> </li> <li> <code>predecessors</code>             \u2013              <p>Get the predecessor nodes of given nodes.</p> </li> <li> <code>remove_edge</code>             \u2013              <p>Remove an edge from the graph either by its ID or by its endpoints.</p> </li> <li> <code>remove_node</code>             \u2013              <p>Remove a node from the graph.</p> </li> <li> <code>spatial_filter</code>             \u2013              <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> </li> <li> <code>successors</code>             \u2013              <p>Get the successor nodes of given nodes.</p> </li> <li> <code>summary</code>             \u2013              <p>Print a summary of the graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save the graph to a CTC ground truth directory.</p> </li> <li> <code>to_geff</code>             \u2013              <p>Write the graph to a geff data directory.</p> </li> <li> <code>to_traccuracy_graph</code>             \u2013              <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> </li> <li> <code>tracklet_graph</code>             \u2013              <p>Create a compressed tracklet graph where each node is a tracklet</p> </li> <li> <code>tracklet_nodes</code>             \u2013              <p>Compute the non-branching tracklets around the provided seed node_ids.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def __init__(\n    self,\n    drivername: str,\n    database: str,\n    username: str | None = None,\n    password: str | None = None,\n    host: str | None = None,\n    port: int | None = None,\n    engine_kwargs: dict[str, Any] | None = None,\n    overwrite: bool = False,\n):\n    self._url = sa.engine.URL.create(\n        drivername,\n        username=username,\n        password=password,\n        host=host,\n        port=port,\n        database=database,\n    )\n    self._engine_kwargs = engine_kwargs if engine_kwargs is not None else {}\n    self._engine = sa.create_engine(self._url, **self._engine_kwargs)\n\n    # Create unique classes for this instance\n    self._define_schema(overwrite=overwrite)\n    self._boolean_columns: dict[str, SchemaDict] = {self.Node.__tablename__: {}, self.Edge.__tablename__: {}}\n    self._array_columns: dict[str, SchemaDict] = {self.Node.__tablename__: {}, self.Edge.__tablename__: {}}\n\n    if overwrite:\n        self.Base.metadata.drop_all(self._engine)\n\n    self.Base.metadata.create_all(self._engine)\n\n    self._max_id_per_time = {}\n    self._update_max_id_per_time()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(node_id: int) -&gt; NodeInterface\n</code></pre> <p>Helper method to interact with a single node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NodeInterface</code>           \u2013            <p>A node interface for the given node id.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def __getitem__(self, node_id: int) -&gt; \"NodeInterface\":\n    \"\"\"\n    Helper method to interact with a single node.\n\n    Parameters\n    ----------\n    node_id : int\n        The id of the node to interact with.\n\n    Returns\n    -------\n    NodeInterface\n        A node interface for the given node id.\n    \"\"\"\n\n    if not isinstance(node_id, int):\n        raise ValueError(f\"graph index must be a integer, found '{node_id}' of type {type(node_id)}\")\n    return NodeInterface(self, node_id)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.__getitem__(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The id of the node to interact with.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._define_schema","title":"_define_schema","text":"<pre><code>_define_schema(overwrite: bool) -&gt; None\n</code></pre> <p>Define the database schema classes for this SQLGraph instance.</p> <p>Creates unique SQLAlchemy model classes for this graph instance to avoid conflicts between multiple SQLGraph instances.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _define_schema(self, overwrite: bool) -&gt; None:\n    \"\"\"\n    Define the database schema classes for this SQLGraph instance.\n\n    Creates unique SQLAlchemy model classes for this graph instance to\n    avoid conflicts between multiple SQLGraph instances.\n    \"\"\"\n    metadata = sa.MetaData()\n    metadata.reflect(bind=self._engine)\n\n    class Base(DeclarativeBase):\n        pass\n\n    if len(metadata.tables) &gt; 0 and not overwrite:\n        for table in metadata.tables.values():\n            self._restore_pickled_column_types(table)\n        for table_name, table in metadata.tables.items():\n            cls = type(\n                table_name,\n                (Base,),\n                {\n                    \"__table__\": table,\n                    \"__tablename__\": table_name,\n                },\n            )\n            setattr(self, table_name, cls)\n        self.Base = Base\n        return\n\n    class Node(Base):\n        __tablename__ = \"Node\"\n\n        # Use node_id as sole primary key for simpler updates\n        node_id = sa.Column(sa.BigInteger, primary_key=True, unique=True)\n\n        # Add t as a regular column\n        # NOTE might want to use as index for fast time-based queries\n        t = sa.Column(sa.Integer, nullable=False)\n\n    node_tb_name = Node.__tablename__\n\n    class Edge(Base):\n        __tablename__ = \"Edge\"\n        edge_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"), index=True)\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"), index=True)\n\n    class Overlap(Base):\n        __tablename__ = \"Overlap\"\n        overlap_id = sa.Column(sa.Integer, primary_key=True, unique=True, autoincrement=True)\n        source_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"), index=True)\n        target_id = sa.Column(sa.BigInteger, sa.ForeignKey(f\"{node_tb_name}.node_id\"), index=True)\n\n    class Metadata(Base):\n        __tablename__ = \"Metadata\"\n        key = sa.Column(sa.String, primary_key=True)\n        value = sa.Column(sa.JSON)\n\n    # Assign to instance variables\n    self.Base = Base\n    self.Node = Node\n    self.Edge = Edge\n    self.Overlap = Overlap\n    self.Metadata = Metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors","title":"_get_neighbors","text":"<pre><code>_get_neighbors(\n    node_key: str,\n    neighbor_key: str,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessors or successors of nodes via database joins.</p> <p>Helper method used by sucessors() and predecessors() to efficiently query neighbor relationships through SQL joins.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list of neighbor node IDs for a single node or a dictionary mapping each node ID to its neighbor ID list.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _get_neighbors(\n    self,\n    node_key: str,\n    neighbor_key: str,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessors or successors of nodes via database joins.\n\n    Helper method used by sucessors() and predecessors() to efficiently\n    query neighbor relationships through SQL joins.\n\n    Parameters\n    ----------\n    node_key : str\n        The edge attribute key for the query node (e.g., \"source_id\").\n    neighbor_key : str\n        The edge attribute key for the neighbor node (e.g., \"target_id\").\n    node_ids : list[int] | int\n        The IDs of the nodes to get neighbors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for neighbor nodes when ``return_attrs`` is True.\n        If None, all attributes are retrieved.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only neighbor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of neighbor attributes. Otherwise returns a list\n        of neighbor node IDs for a single node or a dictionary mapping each node ID to its\n        neighbor ID list.\n    \"\"\"\n    single_node = False\n    if isinstance(node_ids, int):\n        node_ids = [node_ids]\n        single_node = True\n\n    if isinstance(attr_keys, str):\n        attr_keys = [attr_keys]\n\n    with Session(self._engine) as session:\n        if not return_attrs:\n            # only neighbor IDs\n            node_columns = [self.Node.node_id]\n            if attr_keys is not None:\n                LOG.warning(\"attr_keys is ignored when return_attrs is False.\")\n                attr_keys = None\n        elif attr_keys is None:\n            # all columns\n            node_columns = [self.Node]\n        else:\n            node_columns = [getattr(self.Node, key) for key in attr_keys]\n\n        query = session.query(getattr(self.Edge, node_key), *node_columns)\n        query = query.join(self.Edge, getattr(self.Edge, neighbor_key) == self.Node.node_id)\n        query = query.filter(getattr(self.Edge, node_key).in_(node_ids))\n\n        node_df = pl.read_database(\n            query.statement,\n            connection=session.connection(),\n            schema_overrides=self._polars_schema_override(self.Node),\n        )\n        node_df = unpickle_bytes_columns(node_df)\n        node_df = self._cast_array_columns(self.Node, node_df)\n\n    if single_node:\n        if not return_attrs:\n            return node_df[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        else:\n            return node_df\n    else:\n        neighbors_dict = {node_id: group for (node_id,), group in node_df.group_by(node_key)}\n        for node_id in node_ids:\n            neighbors_dict.setdefault(node_id, pl.DataFrame(schema=node_df.schema))\n        if not return_attrs:\n            return {node_id: df[DEFAULT_ATTR_KEYS.NODE_ID].to_list() for node_id, df in neighbors_dict.items()}\n        else:\n            return neighbors_dict\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the query node (e.g., \"source_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(neighbor_key)","title":"<code>neighbor_key</code>","text":"(<code>str</code>)           \u2013            <p>The edge attribute key for the neighbor node (e.g., \"target_id\").</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get neighbors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for neighbor nodes when <code>return_attrs</code> is True. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._get_neighbors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only neighbor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._update_max_id_per_time","title":"_update_max_id_per_time","text":"<pre><code>_update_max_id_per_time() -&gt; None\n</code></pre> <p>Update the maximum node ID for each time point.</p> <p>Scans the database to find the current maximum node ID for each time point and updates the internal cache to ensure newly created nodes have unique IDs.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def _update_max_id_per_time(self) -&gt; None:\n    \"\"\"\n    Update the maximum node ID for each time point.\n\n    Scans the database to find the current maximum node ID for each time\n    point and updates the internal cache to ensure newly created nodes\n    have unique IDs.\n    \"\"\"\n    with Session(self._engine) as session:\n        stmt = sa.select(self.Node.t, sa.func.max(self.Node.node_id)).group_by(self.Node.t)\n        self._max_id_per_time = {int(time): int(max_id) for time, max_id in session.execute(stmt).all()}\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes","title":"_validate_attributes  <code>staticmethod</code>","text":"<pre><code>_validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None\n</code></pre> <p>Validate the attributes of a node.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@staticmethod\ndef _validate_attributes(\n    attrs: dict[str, Any],\n    reference_keys: list[str],\n    mode: str,\n) -&gt; None:\n    \"\"\"\n    Validate the attributes of a node.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes to validate.\n    reference_keys : list[str]\n        The keys to validate against.\n    mode : str\n        The mode to validate against, for example \"node\" or \"edge\".\n    \"\"\"\n    for key in attrs.keys():\n        if key not in reference_keys:\n            raise ValueError(\n                f\"{mode} attribute key '{key}' not found in existing keys: \"\n                f\"'{reference_keys}'\\nInitialize with \"\n                f\"`graph.add_{mode}_attr_key(key, default_value)`\"\n            )\n\n    for ref_key in reference_keys:\n        if ref_key not in attrs.keys() and ref_key != DEFAULT_ATTR_KEYS.NODE_ID:\n            raise ValueError(\n                f\"Attribute '{ref_key}' not found in attrs: '{attrs.keys()}'\\nRequested keys: '{reference_keys}'\"\n            )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes to validate.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(reference_keys)","title":"<code>reference_keys</code>","text":"(<code>list[str]</code>)           \u2013            <p>The keys to validate against.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph._validate_attributes(mode)","title":"<code>mode</code>","text":"(<code>str</code>)           \u2013            <p>The mode to validate against, for example \"node\" or \"edge\".</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge","title":"add_edge","text":"<pre><code>add_edge(\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int\n</code></pre> <p>Add an edge to the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added edge.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys.</p> </li> </ul> <p>Examples:</p> <pre><code>edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\nedge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_edge(\n    self,\n    source_id: int,\n    target_id: int,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n) -&gt; int:\n    \"\"\"\n    Add an edge to the graph.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n    attrs : dict[str, Any]\n        Additional attributes for the edge (e.g., weight, distance).\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n\n    Returns\n    -------\n    int\n        The ID of the newly added edge.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys.\n\n    Examples\n    --------\n    ```python\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.8})\n    edge_id = graph.add_edge(node1_id, node2_id, {\"weight\": 0.9, \"distance\": 5.2, \"confidence\": 0.95})\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.edge_attr_keys, \"edge\")\n\n    if hasattr(source_id, \"item\"):\n        source_id = source_id.item()\n\n    if hasattr(target_id, \"item\"):\n        target_id = target_id.item()\n\n    edge = self.Edge(\n        source_id=source_id,\n        target_id=target_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(edge)\n        session.commit()\n        edge_id = edge.edge_id\n\n    return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(source_id)","title":"<code>source_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the source node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(target_id)","title":"<code>target_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>Additional attributes for the edge (e.g., weight, distance).</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_edge(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node","title":"add_node","text":"<pre><code>add_node(\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int\n</code></pre> <p>Add a node to the graph at time t.</p> <p>Node IDs are automatically generated based on the time point and the node_id_time_multiplier to ensure uniqueness across time points, unless an explicit index is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The ID of the newly added node.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If validate_keys is True and the attributes contain invalid keys, or if the \"t\" key is missing.</p> </li> </ul> <p>Examples:</p> <pre><code>node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\nnode_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\nnode_id = graph.add_node({\"t\": 0, \"x\": 20.0, \"y\": 30.0}, index=12345)\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_node(\n    self,\n    attrs: dict[str, Any],\n    validate_keys: bool = True,\n    index: int | None = None,\n) -&gt; int:\n    \"\"\"\n    Add a node to the graph at time t.\n\n    Node IDs are automatically generated based on the time point and\n    the node_id_time_multiplier to ensure uniqueness across time points,\n    unless an explicit index is provided.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node to be added. Must contain a \"t\" key\n        specifying the time point. Additional keys will be stored as\n        node attributes.\n    validate_keys : bool, default True\n        Whether to check if the attribute keys are valid against the\n        current schema. If False, validation is skipped for performance.\n    index : int | None, default None\n        Optional specific node ID to use. If provided, this will be used\n        as the node_id instead of the auto-generated value.\n\n    Returns\n    -------\n    int\n        The ID of the newly added node.\n\n    Raises\n    ------\n    ValueError\n        If validate_keys is True and the attributes contain invalid keys,\n        or if the \"t\" key is missing.\n\n    Examples\n    --------\n    ```python\n    node_id = graph.add_node({\"t\": 0, \"x\": 10.5, \"y\": 20.3})\n    node_id = graph.add_node({\"t\": 1, \"x\": 15.2, \"y\": 25.8, \"intensity\": 150.0})\n    node_id = graph.add_node({\"t\": 0, \"x\": 20.0, \"y\": 30.0}, index=12345)\n    ```\n    \"\"\"\n    if validate_keys:\n        self._validate_attributes(attrs, self.node_attr_keys, \"node\")\n\n        if \"t\" not in attrs:\n            raise ValueError(f\"Node attributes must have a 't' key. Got {attrs.keys()}\")\n\n    time = attrs[\"t\"]\n\n    if index is None:\n        default_node_id = (time * self.node_id_time_multiplier) - 1\n        node_id = self._max_id_per_time.get(time, default_node_id) + 1\n    else:\n        node_id = index\n\n    node = self.Node(\n        node_id=node_id,\n        **attrs,\n    )\n\n    with Session(self._engine) as session:\n        session.add(node)\n        session.commit()\n\n    # Update max_id tracking only if using auto-generated IDs\n    if index is None:\n        self._max_id_per_time[time] = node_id\n\n    self.node_added.emit_fast(node_id)\n\n    return node_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node to be added. Must contain a \"t\" key specifying the time point. Additional keys will be stored as node attributes.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(validate_keys)","title":"<code>validate_keys</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to check if the attribute keys are valid against the current schema. If False, validation is skipped for performance.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_node(index)","title":"<code>index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional specific node ID to use. If provided, this will be used as the node_id instead of the auto-generated value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap","title":"add_overlap","text":"<pre><code>add_overlap(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Add a new overlap to the graph. Overlapping nodes are mutually exclusive.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--parameters","title":"Parameters","text":"<p>source_id : int     The ID of the source node. target_id : int     The ID of the target node.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.add_overlap--returns","title":"Returns","text":"<p>int     The ID of the added overlap.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def add_overlap(\n    self,\n    source_id: int,\n    target_id: int,\n) -&gt; int:\n    \"\"\"\n    Add a new overlap to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    source_id : int\n        The ID of the source node.\n    target_id : int\n        The ID of the target node.\n\n    Returns\n    -------\n    int\n        The ID of the added overlap.\n    \"\"\"\n    overlap = self.Overlap(\n        source_id=source_id,\n        target_id=target_id,\n    )\n    with Session(self._engine) as session:\n        session.add(overlap)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter","title":"bbox_spatial_filter","text":"<pre><code>bbox_spatial_filter(\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; BBoxSpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.</p> <p>This method creates a spatial index of graph nodes based on their bounding box coordinates, enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for bounding boxes:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n# Query nodes intersecting with region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.bbox_spatial_filter()\n# Uses default [\"t\", \"bbox\"]\n# Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>BBoxSpatialFilter:     The bounding box spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def bbox_spatial_filter(\n    self,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n    clear_cache: bool = False,\n) -&gt; \"BBoxSpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes using bounding boxes.\n\n    This method creates a spatial index of graph nodes based on their bounding box coordinates,\n    enabling efficient querying of nodes intersecting with spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    frame_attr_key : str | None\n        The attribute key for the frame (time) coordinate.\n        Default is `DEFAULT_ATTR_KEYS.T`.\n        If None it will only use the bounding box coordinates.\n    bbox_attr_key : str\n        The attribute key for the bounding box coordinates.\n        Defaults to `DEFAULT_ATTR_KEYS.BBOX`.\n        The bounding box coordinates should be in the format:\n        [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]\n        where each dimension has a min and max value.\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    BBoxSpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for bounding boxes:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter(frame_attr_key=None, box_attr_key=\"bbox\")\n    # Query nodes intersecting with region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.bbox_spatial_filter()\n    # Uses default [\"t\", \"bbox\"]\n    # Query nodes intersecting with time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [BBoxSpatialFilter][tracksdata.graph.filters.BBoxSpatialFilter]:\n        The bounding box spatial filter query class.\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import BBoxSpatialFilter\n\n    cache_key = (frame_attr_key, bbox_attr_key)\n    if not hasattr(self, \"_bbox_spatial_filter_cache\") or clear_cache:\n        self._bbox_spatial_filter_cache: dict[tuple[str | None, str], BBoxSpatialFilter] = {}\n\n    if cache_key not in self._bbox_spatial_filter_cache:\n        self._bbox_spatial_filter_cache[cache_key] = BBoxSpatialFilter(\n            self, frame_attr_key=frame_attr_key, bbox_attr_key=bbox_attr_key\n        )\n    return self._bbox_spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter(frame_attr_key)","title":"<code>frame_attr_key</code>","text":"(<code>str | None</code>, default:                   <code>T</code> )           \u2013            <p>The attribute key for the frame (time) coordinate. Default is <code>DEFAULT_ATTR_KEYS.T</code>. If None it will only use the bounding box coordinates.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter(bbox_attr_key)","title":"<code>bbox_attr_key</code>","text":"(<code>str</code>, default:                   <code>BBOX</code> )           \u2013            <p>The attribute key for the bounding box coordinates. Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>. The bounding box coordinates should be in the format: [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...] where each dimension has a min and max value.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bbox_spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges","title":"bulk_add_edges","text":"<pre><code>bulk_add_edges(\n    edges: list[dict[str, Any]], return_ids: bool = False\n) -&gt; list[int] | None\n</code></pre> <p>Add multiple edges to the graph efficiently.</p> <p>Provides better performance than calling add_edge multiple times by using SQLAlchemy's bulk insert functionality.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>edges = [\n    {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n    {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n]\ngraph.bulk_add_edges(edges)\n</code></pre> Return <p>list[int] | None     The IDs of the added edges.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_edges(\n    self,\n    edges: list[dict[str, Any]],\n    return_ids: bool = False,\n) -&gt; list[int] | None:\n    \"\"\"\n    Add multiple edges to the graph efficiently.\n\n    Provides better performance than calling add_edge multiple times by\n    using SQLAlchemy's bulk insert functionality.\n\n    Parameters\n    ----------\n    edges : list[dict[str, Any]]\n        List of edge attribute dictionaries. Each dictionary must contain\n        \"source_id\" and \"target_id\" keys, plus any additional feature keys.\n    return_ids : bool\n        Whether to return the IDs of the added edges.\n        If False, the edges are added and the method returns None.\n\n    Examples\n    --------\n    ```python\n    edges = [\n        {\"source_id\": 1, \"target_id\": 2, \"weight\": 0.8},\n        {\"source_id\": 2, \"target_id\": 3, \"weight\": 0.9\"},\n    ]\n    graph.bulk_add_edges(edges)\n    ```\n\n    Return\n    ------\n    list[int] | None\n        The IDs of the added edges.\n    \"\"\"\n    if len(edges) == 0:\n        if return_ids:\n            return []\n        return None\n\n    for edge in edges:\n        _data_numpy_to_native(edge)\n\n    if return_ids:\n        with Session(self._engine) as session:\n            result = session.execute(sa.insert(self.Edge).returning(self.Edge.edge_id), edges)\n            session.commit()\n            return list(result.scalars().all())\n\n    else:\n        self._chunked_sa_operation(Session.bulk_insert_mappings, self.Edge, edges)\n        return None\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(edges)","title":"<code>edges</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of edge attribute dictionaries. Each dictionary must contain \"source_id\" and \"target_id\" keys, plus any additional feature keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_edges(return_ids)","title":"<code>return_ids</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the IDs of the added edges. If False, the edges are added and the method returns None.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes","title":"bulk_add_nodes","text":"<pre><code>bulk_add_nodes(\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]\n</code></pre> <p>Add multiple nodes to the graph efficiently.</p> <p>Provides better performance than calling add_node multiple times by using SQLAlchemy's bulk insert functionality and reducing database transactions. Automatically assigns node IDs and handles time-based ID generation, or uses provided indices.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>nodes = [\n    {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n    {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n]\ngraph.bulk_add_nodes(nodes)\n\n# With specific indices\ngraph.bulk_add_nodes(nodes, indices=[1000, 2000])\n</code></pre> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The IDs of the added nodes.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_nodes(\n    self,\n    nodes: list[dict[str, Any]],\n    indices: list[int] | None = None,\n) -&gt; list[int]:\n    \"\"\"\n    Add multiple nodes to the graph efficiently.\n\n    Provides better performance than calling add_node multiple times by\n    using SQLAlchemy's bulk insert functionality and reducing database\n    transactions. Automatically assigns node IDs and handles time-based\n    ID generation, or uses provided indices.\n\n    Parameters\n    ----------\n    nodes : list[dict[str, Any]]\n        List of node attribute dictionaries. Each dictionary must contain\n        a \"t\" key and any additional attribute keys.\n    indices : list[int] | None, default None\n        Optional list of specific node IDs to use. If provided, must be\n        the same length as nodes. If None, IDs are auto-generated.\n\n    Examples\n    --------\n    ```python\n    nodes = [\n        {\"t\": 0, \"x\": 10, \"y\": 20, \"label\": \"A\"},\n        {\"t\": 0, \"x\": 15, \"y\": 25, \"label\": \"B\"},\n    ]\n    graph.bulk_add_nodes(nodes)\n\n    # With specific indices\n    graph.bulk_add_nodes(nodes, indices=[1000, 2000])\n    ```\n\n    Returns\n    -------\n    list[int]\n        The IDs of the added nodes.\n    \"\"\"\n    if len(nodes) == 0:\n        return []\n\n    self._validate_indices_length(nodes, indices)\n\n    node_ids = []\n    for i, node in enumerate(nodes):\n        time = node[\"t\"]\n\n        if indices is None:\n            default_node_id = (time * self.node_id_time_multiplier) - 1\n            node_id = self._max_id_per_time.get(time, default_node_id) + 1\n            # Update max_id tracking only for auto-generated IDs\n            self._max_id_per_time[time] = node_id\n        else:\n            node_id = indices[i]\n\n        node[DEFAULT_ATTR_KEYS.NODE_ID] = node_id\n        node_ids.append(node_id)\n\n    self._chunked_sa_operation(Session.bulk_insert_mappings, self.Node, nodes)\n\n    if is_signal_on(self.node_added):\n        for node_id in node_ids:\n            self.node_added.emit_fast(node_id)\n\n    return node_ids\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes(nodes)","title":"<code>nodes</code>","text":"(<code>list[dict[str, Any]]</code>)           \u2013            <p>List of node attribute dictionaries. Each dictionary must contain a \"t\" key and any additional attribute keys.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_nodes(indices)","title":"<code>indices</code>","text":"(<code>list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional list of specific node IDs to use. If provided, must be the same length as nodes. If None, IDs are auto-generated.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps","title":"bulk_add_overlaps","text":"<pre><code>bulk_add_overlaps(overlaps: list[list[int, 2]]) -&gt; None\n</code></pre> <p>Add multiple overlaps to the graph. Overlapping nodes are mutually exclusive.</p> <p>Parameters:</p> See Also <p>add_overlap:     Add a single overlap to the graph.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def bulk_add_overlaps(\n    self,\n    overlaps: list[list[int, 2]],\n) -&gt; None:\n    \"\"\"\n    Add multiple overlaps to the graph.\n    Overlapping nodes are mutually exclusive.\n\n    Parameters\n    ----------\n    overlaps : list[list[int, 2]]\n        The IDs of the nodes to add the overlaps for.\n\n    See Also\n    --------\n    [add_overlap][tracksdata.graph.SQLGraph.add_overlap]:\n        Add a single overlap to the graph.\n    \"\"\"\n    if hasattr(overlaps, \"tolist\"):\n        overlaps = overlaps.tolist()\n\n    overlaps = [{\"source_id\": source_id, \"target_id\": target_id} for source_id, target_id in overlaps]\n    self._chunked_sa_operation(Session.bulk_insert_mappings, self.Overlap, overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.bulk_add_overlaps(overlaps)","title":"<code>overlaps</code>","text":"(<code>list[list[int, 2]]</code>)           \u2013            <p>The IDs of the nodes to add the overlaps for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps","title":"compute_overlaps","text":"<pre><code>compute_overlaps(iou_threshold: float = 0.0) -&gt; None\n</code></pre> <p>Find overlapping nodes within each frame and add them their overlap relation into the graph.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>graph.set_overlaps(iou_threshold=0.5)\n</code></pre> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def compute_overlaps(self, iou_threshold: float = 0.0) -&gt; None:\n    \"\"\"\n    Find overlapping nodes within each frame and add them their overlap relation into the graph.\n\n    Parameters\n    ----------\n    iou_threshold : float\n        Nodes with an IoU greater than this threshold are considered overlapping.\n        If 0, all nodes are considered overlapping.\n\n    Examples\n    --------\n    ```python\n    graph.set_overlaps(iou_threshold=0.5)\n    ```\n    \"\"\"\n    if iou_threshold &lt; 0.0 or iou_threshold &gt; 1.0:\n        raise ValueError(\"iou_threshold must be between 0.0 and 1.0\")\n\n    def _estimate_overlaps(t: int) -&gt; list[list[int, 2]]:\n        node_attrs = self.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t).node_attrs(\n            attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, DEFAULT_ATTR_KEYS.MASK],\n        )\n        node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_list()\n        masks = node_attrs[DEFAULT_ATTR_KEYS.MASK].to_list()\n        overlaps = []\n        for i in range(len(masks)):\n            mask_i = masks[i]\n            for j in range(i + 1, len(masks)):\n                if mask_i.iou(masks[j]) &gt; iou_threshold:\n                    overlaps.append([node_ids[i], node_ids[j]])\n        return overlaps\n\n    for overlaps in multiprocessing_apply(\n        func=_estimate_overlaps,\n        sequence=self.time_points(),\n        desc=\"Setting overlaps\",\n    ):\n        self.bulk_add_overlaps(overlaps)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.compute_overlaps(iou_threshold)","title":"<code>iou_threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Nodes with an IoU greater than this threshold are considered overlapping. If 0, all nodes are considered overlapping.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.copy","title":"copy","text":"<pre><code>copy(**kwargs) -&gt; BaseGraph\n</code></pre> <p>Create a copy of this graph.</p> <p>Returns:</p> <ul> <li> <code>BaseGraph</code>           \u2013            <p>A new graph instance with the same nodes, edges, and attributes as this graph.</p> </li> <li> <code>**kwargs</code> (              <code>Any</code> )          \u2013            <p>Additional arguments to pass to the graph constructor.</p> </li> </ul> <p>Examples:</p> <pre><code>copied_graph = graph.copy()\n</code></pre> See Also <p>from_other:     Create a graph from another graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def copy(self, **kwargs) -&gt; \"BaseGraph\":\n    \"\"\"\n    Create a copy of this graph.\n\n    Returns\n    -------\n    BaseGraph\n        A new graph instance with the same nodes, edges, and attributes as this graph.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    copied_graph = graph.copy()\n    ```\n\n    See Also\n    --------\n    [from_other][tracksdata.graph.BaseGraph.from_other]:\n        Create a graph from another graph.\n    \"\"\"\n    return self.__class__.from_other(self, **kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.edge_id","title":"edge_id","text":"<pre><code>edge_id(source_id: int, target_id: int) -&gt; int\n</code></pre> <p>Return the edge id between two nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def edge_id(self, source_id: int, target_id: int) -&gt; int:\n    \"\"\"\n    Return the edge id between two nodes.\n    \"\"\"\n    with Session(self._engine) as session:\n        edge_id = (\n            session.query(self.Edge.edge_id)\n            .filter(self.Edge.source_id == source_id, self.Edge.target_id == target_id)\n            .scalar()\n        )\n        if edge_id is None:\n            raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\")\n        return edge_id\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array","title":"from_array  <code>classmethod</code>","text":"<pre><code>from_array(\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T\n</code></pre> <p>Create a graph from a numpy array.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--parameters","title":"Parameters","text":"<p>positions : np.ndarray     (N, 4 or 3) dimensional array of positions.     Defined by (T, (Z), Y, X) coordinates. tracklet_ids : np.ndarray | None     Track ids of the nodes if available. tracklet_id_graph : dict[int, int] | None     Mapping of division as child track id (key) to parent track id (value) relationships. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_array--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the numpy array.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_array(\n    cls: type[T],\n    positions: ArrayLike,\n    tracklet_ids: ArrayLike | None = None,\n    tracklet_id_graph: dict[int, int] | None = None,\n    **kwargs,\n) -&gt; T:\n    \"\"\"\n    Create a graph from a numpy array.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (N, 4 or 3) dimensional array of positions.\n        Defined by (T, (Z), Y, X) coordinates.\n    tracklet_ids : np.ndarray | None\n        Track ids of the nodes if available.\n    tracklet_id_graph : dict[int, int] | None\n        Mapping of division as child track id (key) to parent track id (value) relationships.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the numpy array.\n    \"\"\"\n    from tracksdata.io._numpy_array import from_array\n\n    graph = cls(**kwargs)\n    from_array(\n        positions=np.asarray(positions),\n        graph=graph,\n        tracklet_ids=tracklet_ids,\n        tracklet_id_graph=tracklet_id_graph,\n    )\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc","title":"from_ctc  <code>classmethod</code>","text":"<pre><code>from_ctc(data_dir: str | Path, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from a CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--examples","title":"Examples","text":"<pre><code>graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--see-also","title":"See Also","text":"<p>from_ctc:     Load a CTC ground truth file into a graph.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the CTC data directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_ctc--see-also_1","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_ctc(cls: type[T], data_dir: str | Path, **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from a CTC data directory.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Examples\n    --------\n    ```python\n    graph = BaseGraph.from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\")\n    ```\n\n    See Also\n    --------\n    [from_ctc][tracksdata.io._ctc.from_ctc]:\n        Load a CTC ground truth file into a graph.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the CTC data directory.\n\n    See Also\n    --------\n    [to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import from_ctc\n\n    graph = cls(**kwargs)\n    from_ctc(data_dir, graph)\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff","title":"from_geff  <code>classmethod</code>","text":"<pre><code>from_geff(\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]\n</code></pre> <p>Create a graph from a geff data directory.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>The loaded graph.</p> </li> <li> <code>geff_metadata</code> (              <code>GeffMetadata</code> )          \u2013            <p>The geff metadata of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_geff(\n    cls: type[T],\n    geff_store: StoreLike,\n    geff_read_kwargs: dict[str, Any] | None = None,\n    **kwargs,\n) -&gt; tuple[T, GeffMetadata]:\n    \"\"\"\n    Create a graph from a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to read the graph from.\n    geff_read_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `geff.read` function.\n    **kwargs\n        Additional keyword arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    T\n        The loaded graph.\n    geff_metadata : GeffMetadata\n        The geff metadata of the graph.\n    \"\"\"\n    from tracksdata.graph import IndexedRXGraph\n\n    if geff_read_kwargs is None:\n        geff_read_kwargs = {}\n\n    # this performs a roundtrip with the rustworkx graph\n    rx_graph, geff_metadata = geff.read(geff_store, backend=\"rustworkx\", **geff_read_kwargs)\n\n    if not isinstance(rx_graph, rx.PyDiGraph):\n        LOG.warning(\"The graph is not a directed graph, converting to directed graph.\")\n        rx_graph = rx_graph.to_directed()\n\n    node_id_map = rx_graph.attrs[\"to_rx_id_map\"]\n    rx_graph.attrs = {\"geff\": rx_graph.attrs, **rx_graph.attrs[\"extra\"].pop(\"tracksdata\", {})}\n\n    indexed_graph = IndexedRXGraph(\n        rx_graph=rx_graph,\n        node_id_map=node_id_map,\n        **kwargs,\n    )\n\n    if DEFAULT_ATTR_KEYS.MASK in indexed_graph.node_attr_keys:\n        from tracksdata.nodes._mask import Mask\n\n        # unsafe operation, changing graph content inplace\n        for node_attr in indexed_graph.rx_graph.nodes():\n            node_attr[DEFAULT_ATTR_KEYS.MASK] = Mask(\n                node_attr[DEFAULT_ATTR_KEYS.MASK].astype(bool),\n                bbox=node_attr[DEFAULT_ATTR_KEYS.BBOX],\n            )\n\n    if cls == IndexedRXGraph:\n        return indexed_graph, geff_metadata\n\n    return cls.from_other(indexed_graph, **kwargs), geff_metadata\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to read the graph from.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff(geff_read_kwargs)","title":"<code>geff_read_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>geff.read</code> function.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_geff(**kwargs)","title":"<code>**kwargs</code>","text":"\u2013            <p>Additional keyword arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other","title":"from_other  <code>classmethod</code>","text":"<pre><code>from_other(other: BaseGraph, **kwargs) -&gt; T\n</code></pre> <p>Create a graph from another graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other--parameters","title":"Parameters","text":"<p>other : BaseGraph     The other graph to create a new graph from. **kwargs : Any     Additional arguments to pass to the graph constructor.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.from_other--returns","title":"Returns","text":"<p>BaseGraph     A graph with the nodes and edges from the other graph.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>@classmethod\ndef from_other(cls: type[T], other: \"BaseGraph\", **kwargs) -&gt; T:\n    \"\"\"\n    Create a graph from another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to create a new graph from.\n    **kwargs : Any\n        Additional arguments to pass to the graph constructor.\n\n    Returns\n    -------\n    BaseGraph\n        A graph with the nodes and edges from the other graph.\n    \"\"\"\n    # add node attributes\n    node_attrs = other.node_attrs()\n    other_node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID]\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    graph = cls(**kwargs)\n\n    for col in node_attrs.columns:\n        if col != DEFAULT_ATTR_KEYS.T:\n            first_value = node_attrs[col].first()\n            graph.add_node_attr_key(col, infer_default_value(first_value))\n\n    if graph.supports_custom_indices:\n        new_node_ids = graph.bulk_add_nodes(\n            list(node_attrs.rows(named=True)),\n            indices=other_node_ids.to_list(),\n        )\n    else:\n        new_node_ids = graph.bulk_add_nodes(list(node_attrs.rows(named=True)))\n        if other.supports_custom_indices:\n            LOG.warning(\n                f\"Other graph ({type(other).__name__}) supports custom indices, but this graph \"\n                f\"({type(graph).__name__}) does not, indexing automatically.\"\n            )\n\n    # mapping from old node ids to new node ids\n    node_map = dict(zip(other_node_ids, new_node_ids, strict=True))\n\n    # add edge attributes\n    edge_attrs = other.edge_attrs()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n\n    for col in edge_attrs.columns:\n        if col not in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]:\n            graph.add_edge_attr_key(col, edge_attrs[col].first())\n\n    edge_attrs = edge_attrs.with_columns(\n        edge_attrs[col].map_elements(node_map.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n    graph.bulk_add_edges(list(edge_attrs.rows(named=True)))\n\n    if other.has_overlaps():\n        overlaps = other.overlaps()\n        overlaps = np.vectorize(node_map.get)(np.asarray(overlaps, dtype=int))\n        graph.bulk_add_overlaps(overlaps.tolist())\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.has_edge","title":"has_edge","text":"<pre><code>has_edge(source_id: int, target_id: int) -&gt; bool\n</code></pre> <p>Check if the graph has an edge between two nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def has_edge(self, source_id: int, target_id: int) -&gt; bool:\n    \"\"\"\n    Check if the graph has an edge between two nodes.\n    \"\"\"\n    with Session(self._engine) as session:\n        return (\n            session.query(self.Edge)\n            .filter(self.Edge.source_id == source_id, self.Edge.target_id == target_id)\n            .count()\n            &gt; 0\n        )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.has_overlaps","title":"has_overlaps","text":"<pre><code>has_overlaps() -&gt; bool\n</code></pre> <p>Check if the graph has any overlaps.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def has_overlaps(self) -&gt; bool:\n    \"\"\"\n    Check if the graph has any overlaps.\n    \"\"\"\n    with Session(self._engine) as session:\n        return session.query(self.Overlap).count() &gt; 0\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.in_degree","title":"in_degree","text":"<pre><code>in_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the in-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def in_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the in-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match","title":"match","text":"<pre><code>match(\n    other: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None\n</code></pre> <p>Match the nodes of the graph to the nodes of another graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def match(\n    self,\n    other: \"BaseGraph\",\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n) -&gt; None:\n    \"\"\"\n    Match the nodes of the graph to the nodes of another graph.\n\n    Parameters\n    ----------\n    other : BaseGraph\n        The other graph to match to.\n    matched_node_id_key : str\n        The key of the output value of the corresponding node ID in the other graph.\n    match_score_key : str\n        The key of the output value of the match score between matched nodes\n    matched_edge_mask_key : str\n        The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.\n    \"\"\"\n    from tracksdata.metrics._ctc_metrics import _matching_data\n\n    matching_data = _matching_data(\n        self,\n        other,\n        input_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        reference_graph_key=DEFAULT_ATTR_KEYS.NODE_ID,\n        optimal_matching=True,\n    )\n\n    if matched_node_id_key not in self.node_attr_keys:\n        self.add_node_attr_key(matched_node_id_key, -1)\n\n    if match_score_key not in self.node_attr_keys:\n        self.add_node_attr_key(match_score_key, 0.0)\n\n    if matched_edge_mask_key not in self.edge_attr_keys:\n        self.add_edge_attr_key(matched_edge_mask_key, False)\n\n    node_ids = functools.reduce(operator.iadd, matching_data[\"mapped_comp\"])\n    other_ids = functools.reduce(operator.iadd, matching_data[\"mapped_ref\"])\n    ious = functools.reduce(operator.iadd, matching_data[\"ious\"])\n\n    if len(node_ids) == 0:\n        LOG.warning(\"No matching nodes found.\")\n        return\n\n    self.update_node_attrs(\n        node_ids=node_ids,\n        attrs={matched_node_id_key: other_ids, match_score_key: ious},\n    )\n\n    other_to_node_ids = dict(zip(other_ids, node_ids, strict=True))\n\n    self_edges_df = self.edge_attrs(attr_keys=[])\n    other_edges_df = other.edge_attrs(attr_keys=[])\n\n    other_edges_df = other_edges_df.with_columns(\n        other_edges_df[col].map_elements(other_to_node_ids.get, return_dtype=pl.Int64).alias(col)\n        for col in [DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET]\n    )\n\n    edge_ids = self_edges_df.join(\n        other_edges_df,\n        on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        how=\"inner\",\n    )[DEFAULT_ATTR_KEYS.EDGE_ID]\n\n    if len(edge_ids) == 0:\n        LOG.warning(\"No matching edges found.\")\n        return\n\n    self.update_edge_attrs(\n        edge_ids=edge_ids,\n        attrs={matched_edge_mask_key: True},\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(other)","title":"<code>other</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The other graph to match to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the output value of the corresponding node ID in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the output value of the match score between matched nodes</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.match(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the output as a boolean value indicating if a corresponding edge exists in the other graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.node_ids","title":"node_ids","text":"<pre><code>node_ids() -&gt; list[int]\n</code></pre> <p>Get the IDs of all nodes in the graph.</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>List of all node IDs in the graph.</p> </li> </ul> <p>Examples:</p> <pre><code>all_nodes = graph.node_ids()\nprint(f\"Graph contains {len(all_nodes)} nodes\")\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def node_ids(self) -&gt; list[int]:\n    \"\"\"\n    Get the IDs of all nodes in the graph.\n\n    Returns\n    -------\n    list[int]\n        List of all node IDs in the graph.\n\n    Examples\n    --------\n    ```python\n    all_nodes = graph.node_ids()\n    print(f\"Graph contains {len(all_nodes)} nodes\")\n    ```\n    \"\"\"\n    with Session(self._engine) as session:\n        return [i for (i,) in session.query(self.Node.node_id).all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.out_degree","title":"out_degree","text":"<pre><code>out_degree(\n    node_ids: list[int] | int | None = None,\n) -&gt; list[int] | int\n</code></pre> <p>Get the out-degree of a list of nodes.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def out_degree(self, node_ids: list[int] | int | None = None) -&gt; list[int] | int:\n    \"\"\"\n    Get the out-degree of a list of nodes.\n    \"\"\"\n    return self._get_degree(node_ids, DEFAULT_ATTR_KEYS.EDGE_SOURCE)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.overlaps","title":"overlaps","text":"<pre><code>overlaps(\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]\n</code></pre> <p>Get the overlaps between the nodes in <code>node_ids</code>.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def overlaps(\n    self,\n    node_ids: list[int] | None = None,\n) -&gt; list[list[int, 2]]:\n    \"\"\"\n    Get the overlaps between the nodes in `node_ids`.\n    \"\"\"\n    if hasattr(node_ids, \"tolist\"):\n        node_ids = node_ids.tolist()\n\n    with Session(self._engine) as session:\n        query = session.query(self.Overlap.source_id, self.Overlap.target_id)\n\n        if node_ids is not None:\n            query = query.filter(\n                self.Overlap.source_id.in_(node_ids),\n                self.Overlap.target_id.in_(node_ids),\n            )\n\n        return [[source_id, target_id] for source_id, target_id in query.all()]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors","title":"predecessors","text":"<pre><code>predecessors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the predecessor nodes of given nodes.</p> <p>Predecessors are nodes that are sources of edges targeting the given nodes (incoming edges). Uses efficient SQL joins to retrieve predecessor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of predecessor attributes. Otherwise returns a list of predecessor node IDs for a single node or a dictionary mapping each node ID to its predecessor ID list.</p> </li> </ul> <p>Examples:</p> <pre><code>predecessors_df = graph.predecessors(node_id, return_attrs=True)\npredecessors_dict = graph.predecessors([node1, node2, node3], return_attrs=True)\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def predecessors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the predecessor nodes of given nodes.\n\n    Predecessors are nodes that are sources of edges targeting the\n    given nodes (incoming edges). Uses efficient SQL joins to retrieve\n    predecessor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get predecessors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for predecessor nodes when ``return_attrs`` is True.\n        If None, all attributes are retrieved.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only predecessor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of predecessor attributes. Otherwise returns a list\n        of predecessor node IDs for a single node or a dictionary mapping each node ID to its\n        predecessor ID list.\n\n    Examples\n    --------\n    ```python\n    predecessors_df = graph.predecessors(node_id, return_attrs=True)\n    predecessors_dict = graph.predecessors([node1, node2, node3], return_attrs=True)\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get predecessors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for predecessor nodes when <code>return_attrs</code> is True. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.predecessors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only predecessor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.remove_edge","title":"remove_edge","text":"<pre><code>remove_edge(\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None\n</code></pre> <p>Remove an edge from the graph either by its ID or by its endpoints.</p> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def remove_edge(\n    self,\n    source_id: int | None = None,\n    target_id: int | None = None,\n    *,\n    edge_id: int | None = None,\n) -&gt; None:\n    \"\"\"\n    Remove an edge from the graph either by its ID or by its endpoints.\n    \"\"\"\n    with Session(self._engine) as session:\n        if edge_id is None:\n            if source_id is None or target_id is None:\n                raise ValueError(\"Provide either edge_id or both source_id and target_id.\")\n            deleted = (\n                session.query(self.Edge)\n                .filter(self.Edge.source_id == source_id, self.Edge.target_id == target_id)\n                .delete()\n            )\n            if not deleted:\n                raise ValueError(f\"Edge {source_id}-&gt;{target_id} does not exist in the graph.\")\n        else:\n            deleted = session.query(self.Edge).filter(self.Edge.edge_id == edge_id).delete()\n            if not deleted:\n                raise ValueError(f\"Edge {edge_id} does not exist in the graph.\")\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.remove_node","title":"remove_node","text":"<pre><code>remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the graph.</p> <p>This method removes the specified node and all edges connected to it (both incoming and outgoing edges). Also removes any overlaps involving this node.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the node_id does not exist in the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the graph.\n\n    This method removes the specified node and all edges connected to it\n    (both incoming and outgoing edges). Also removes any overlaps\n    involving this node.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n\n    Raises\n    ------\n    ValueError\n        If the node_id does not exist in the graph.\n    \"\"\"\n    self.node_removed.emit_fast(node_id)\n\n    with Session(self._engine) as session:\n        # Check if the node exists\n        node = session.query(self.Node).filter(self.Node.node_id == node_id).first()\n        if node is None:\n            raise ValueError(f\"Node {node_id} does not exist in the graph.\")\n\n        # Remove all edges where this node is source or target\n        session.query(self.Edge).filter(\n            sa.or_(self.Edge.source_id == node_id, self.Edge.target_id == node_id)\n        ).delete()\n\n        # Remove all overlaps involving this node\n        session.query(self.Overlap).filter(\n            sa.or_(self.Overlap.source_id == node_id, self.Overlap.target_id == node_id)\n        ).delete()\n\n        # Remove the node itself\n        session.delete(node)\n        session.commit()\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.spatial_filter","title":"spatial_filter","text":"<pre><code>spatial_filter(\n    attr_keys: list[str] | None = None,\n    clear_cache: bool = False,\n) -&gt; SpatialFilter\n</code></pre> <p>Create a spatial filter for efficient spatial queries of graph nodes.</p> <p>This method creates a spatial index of graph nodes based on their spatial coordinates, enabling efficient querying of nodes within spatial regions of interest (ROI).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SpatialFilter</code>           \u2013            <p>A spatial filter object that can be used to query nodes within spatial regions using slice notation.</p> </li> </ul> <p>Examples:</p> <p>Create a 2D spatial filter for image coordinates:</p> <pre><code>spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n# Query nodes in region y=[10, 50), x=[20, 60)\nsubgraph = spatial_filter[10:50, 20:60].subgraph()\n</code></pre> <p>Create a 4D spatiotemporal filter:</p> <pre><code>spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n# Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\nnodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n</code></pre> See Also <p>SpatialFilter:     The point spatial filter query class.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def spatial_filter(self, attr_keys: list[str] | None = None, clear_cache: bool = False) -&gt; \"SpatialFilter\":\n    \"\"\"\n    Create a spatial filter for efficient spatial queries of graph nodes.\n\n    This method creates a spatial index of graph nodes based on their spatial coordinates,\n    enabling efficient querying of nodes within spatial regions of interest (ROI).\n\n    Parameters\n    ----------\n    attr_keys : list[str] | None, optional\n        List of attribute keys to use as spatial coordinates. If None, defaults to\n        [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.\n        Common combinations include:\n        - 2D: [\"y\", \"x\"]\n        - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"]\n        - 4D: [\"t\", \"z\", \"y\", \"x\"]\n    clear_cache : bool\n        Whether to clear the spatial filter cache before creating a new filter.\n        Default is False.\n\n    Returns\n    -------\n    SpatialFilter\n        A spatial filter object that can be used to query nodes within spatial regions\n        using slice notation.\n\n    Examples\n    --------\n    Create a 2D spatial filter for image coordinates:\n\n    ```python\n    spatial_filter = graph.spatial_filter(attr_keys=[\"y\", \"x\"])\n    # Query nodes in region y=[10, 50), x=[20, 60)\n    subgraph = spatial_filter[10:50, 20:60].subgraph()\n    ```\n\n    Create a 4D spatiotemporal filter:\n\n    ```python\n    spatial_filter = graph.spatial_filter()  # Uses default [\"t\", \"z\", \"y\", \"x\"]\n    # Query nodes in time=[0, 10), z=[0, 5), y=[10, 50), x=[20, 60)\n    nodes_in_roi = spatial_filter[0:10, 0:5, 10:50, 20:60].node_attrs()\n    ```\n\n    See Also\n    --------\n    [SpatialFilter][tracksdata.graph.filters.SpatialFilter]:\n        The point spatial filter query class.\n\n    \"\"\"\n    from tracksdata.graph.filters._spatial_filter import SpatialFilter\n\n    cache_key = None if attr_keys is None else tuple(attr_keys)\n    if not hasattr(self, \"_spatial_filter_cache\") or clear_cache:\n        self._spatial_filter_cache: dict[tuple[str, ...] | None, SpatialFilter] = {}\n\n    if cache_key not in self._spatial_filter_cache:\n        self._spatial_filter_cache[cache_key] = SpatialFilter(self, attr_keys=attr_keys)\n\n    return self._spatial_filter_cache[cache_key]\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.spatial_filter(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute keys to use as spatial coordinates. If None, defaults to [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph. Common combinations include: - 2D: [\"y\", \"x\"] - 3D: [\"z\", \"y\", \"x\"] or [\"t\", \"y\", \"x\"] - 4D: [\"t\", \"z\", \"y\", \"x\"]</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.spatial_filter(clear_cache)","title":"<code>clear_cache</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to clear the spatial filter cache before creating a new filter. Default is False.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors","title":"successors","text":"<pre><code>successors(\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; (\n    dict[int, pl.DataFrame]\n    | pl.DataFrame\n    | dict[int, list[int]]\n    | list[int]\n)\n</code></pre> <p>Get the successor nodes of given nodes.</p> <p>Successors are nodes that are targets of edges originating from the given nodes (outgoing edges). Uses efficient SQL joins to retrieve successor information with their attributes in a single query.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[int, DataFrame] | DataFrame | dict[int, list[int]] | list[int]</code>           \u2013            <p>When <code>return_attrs</code> is True, returns a DataFrame for a single node or a dictionary mapping each node ID to a DataFrame of successor attributes. Otherwise returns a list of successor node IDs for a single node or a dictionary mapping each node ID to its successor ID list.</p> </li> </ul> <p>Examples:</p> <pre><code>successors_df = graph.sucessors(node_id, return_attrs=True)\nsuccessors_dict = graph.sucessors([node1, node2, node3], return_attrs=True)\n</code></pre> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def successors(\n    self,\n    node_ids: list[int] | int,\n    attr_keys: Sequence[str] | str | None = None,\n    *,\n    return_attrs: bool = False,\n) -&gt; dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]:\n    \"\"\"\n    Get the successor nodes of given nodes.\n\n    Successors are nodes that are targets of edges originating from the\n    given nodes (outgoing edges). Uses efficient SQL joins to retrieve\n    successor information with their attributes in a single query.\n\n    Parameters\n    ----------\n    node_ids : list[int] | int\n        The IDs of the nodes to get successors for.\n    attr_keys : Sequence[str] | str | None, optional\n        The attribute keys to retrieve for successor nodes when ``return_attrs`` is True.\n        If None, all attributes are retrieved.\n    return_attrs : bool, default False\n        Whether to return the attributes DataFrame. When False only successor\n        node IDs are returned.\n\n    Returns\n    -------\n    dict[int, pl.DataFrame] | pl.DataFrame | dict[int, list[int]] | list[int]\n        When ``return_attrs`` is True, returns a DataFrame for a single node or a dictionary\n        mapping each node ID to a DataFrame of successor attributes. Otherwise returns a list\n        of successor node IDs for a single node or a dictionary mapping each node ID to its\n        successor ID list.\n\n    Examples\n    --------\n    ```python\n    successors_df = graph.sucessors(node_id, return_attrs=True)\n    successors_dict = graph.sucessors([node1, node2, node3], return_attrs=True)\n    ```\n    \"\"\"\n    return self._get_neighbors(\n        node_key=DEFAULT_ATTR_KEYS.EDGE_SOURCE,\n        neighbor_key=DEFAULT_ATTR_KEYS.EDGE_TARGET,\n        node_ids=node_ids,\n        attr_keys=attr_keys,\n        return_attrs=return_attrs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(node_ids)","title":"<code>node_ids</code>","text":"(<code>list[int] | int</code>)           \u2013            <p>The IDs of the nodes to get successors for.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The attribute keys to retrieve for successor nodes when <code>return_attrs</code> is True. If None, all attributes are retrieved.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.successors(return_attrs)","title":"<code>return_attrs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to return the attributes DataFrame. When False only successor node IDs are returned.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary","title":"summary","text":"<pre><code>summary(\n    attrs_stats: bool = False, print_summary: bool = True\n) -&gt; str\n</code></pre> <p>Print a summary of the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string with the summary of the graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def summary(\n    self,\n    attrs_stats: bool = False,\n    print_summary: bool = True,\n) -&gt; str:\n    \"\"\"\n    Print a summary of the graph.\n\n    Parameters\n    ----------\n    attrs_stats : bool\n        If true it will print statistics about the attributes of the nodes and edges.\n    print_summary : bool\n        If true it will print the summary of the graph.\n\n    Returns\n    -------\n    str\n        A string with the summary of the graph.\n    \"\"\"\n    summary = \"\"\n\n    summary += \"Graph summary:\\n\"\n    summary += f\"Number of nodes: {self.num_nodes}\\n\"\n    summary += f\"Number of edges: {self.num_edges}\\n\"\n    summary += f\"Number of overlaps: {len(self.overlaps())}\\n\"\n\n    time_points = self.time_points()\n    summary += f\"Number of distinct time points: {len(time_points)}\\n\"\n    if len(time_points) &gt; 0:\n        summary += f\"Start time: {min(time_points)}\\n\"\n        summary += f\"End time: {max(time_points)}\\n\"\n    else:\n        summary += \"No time points found.\\n\"\n\n    if attrs_stats:\n        nodes_attrs = self.node_attrs()\n        edges_attrs = self.edge_attrs()\n        summary += \"\\nNodes attributes:\\n\"\n        summary += str(nodes_attrs.describe())\n        summary += \"\\nEdges attributes:\\n\"\n        summary += str(edges_attrs.describe())\n\n    if print_summary:\n        print(summary)\n\n    return summary\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary(attrs_stats)","title":"<code>attrs_stats</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true it will print statistics about the attributes of the nodes and edges.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.summary(print_summary)","title":"<code>print_summary</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true it will print the summary of the graph.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save the graph to a CTC ground truth directory.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--parameters","title":"Parameters","text":"<p>output_dir : str | Path     The directory to save the graph to. shape : tuple[int, ...]     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--examples","title":"Examples","text":"<pre><code># ...\nsolution_graph = solver.solve(graph)\nsolution_graph.assign_tracklet_ids()\nsolution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_ctc--see-also","title":"See Also","text":"<p>to_ctc:     Save a graph to a CTC ground truth directory.</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_ctc(\n    self,\n    output_dir: str | Path,\n    *,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save the graph to a CTC ground truth directory.\n\n    Parameters\n    ----------\n    output_dir : str | Path\n        The directory to save the graph to.\n    shape : tuple[int, ...]\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    Examples\n    --------\n    ```python\n    # ...\n    solution_graph = solver.solve(graph)\n    solution_graph.assign_tracklet_ids()\n    solution_graph.to_ctc(shape=(10, 100, 100), output_dir=\"01_RES\")\n    ```\n\n    See Also\n    --------\n    [to_ctc][tracksdata.io.to_ctc]:\n        Save a graph to a CTC ground truth directory.\n    \"\"\"\n    from tracksdata.io._ctc import to_ctc\n\n    to_ctc(\n        graph=self,\n        shape=shape,\n        output_dir=output_dir,\n        tracklet_id_key=tracklet_id_key,\n        overwrite=overwrite,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff","title":"to_geff","text":"<pre><code>to_geff(\n    geff_store: StoreLike,\n    geff_metadata: GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None\n</code></pre> <p>Write the graph to a geff data directory.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_geff(\n    self,\n    geff_store: StoreLike,\n    geff_metadata: geff.GeffMetadata | None = None,\n    zarr_format: Literal[2, 3] = 3,\n) -&gt; None:\n    \"\"\"\n    Write the graph to a geff data directory.\n\n    Parameters\n    ----------\n    geff_store : StoreLike\n        The store or path to the geff data directory to write the graph to.\n    geff_metadata : GeffMetadata | None\n        The geff metadata to write to the graph.\n        It automatically generates the metadata with:\n        - axes: time (t) and spatial axes ((z), y, x)\n        - tracklet node property: tracklet_id\n    zarr_format : Literal[2, 3]\n        The zarr format to write the graph to.\n        Defaults to 3.\n    \"\"\"\n\n    node_attrs = self.node_attrs()\n    node_ids = node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy()\n    node_attrs = node_attrs.drop(DEFAULT_ATTR_KEYS.NODE_ID)\n\n    edge_attrs = self.edge_attrs().drop(DEFAULT_ATTR_KEYS.EDGE_ID)\n    edge_ids = edge_attrs.select(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET).to_numpy()\n    edge_attrs = edge_attrs.drop(DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET)\n\n    if geff_metadata is None:\n        axes = [Axis(name=DEFAULT_ATTR_KEYS.T, type=\"time\")]\n        axes.extend([Axis(name=c, type=\"space\") for c in (\"z\", \"y\", \"x\") if c in node_attrs.columns])\n\n        if DEFAULT_ATTR_KEYS.TRACKLET_ID in node_attrs.columns:\n            track_node_props = {\n                \"tracklet\": DEFAULT_ATTR_KEYS.TRACKLET_ID,\n            }\n        else:\n            track_node_props = None\n\n        node_props_metadata = {\n            k: PropMetadata(\n                identifier=k,\n                dtype=polars_dtype_to_numpy_dtype(v.dtype) if k != DEFAULT_ATTR_KEYS.MASK else np.uint64,\n                varlength=k == DEFAULT_ATTR_KEYS.MASK,\n            )\n            for k, v in node_attrs.to_dict().items()\n        }\n        edge_props_metadata = {\n            k: PropMetadata(identifier=k, dtype=polars_dtype_to_numpy_dtype(v.dtype))\n            for k, v in edge_attrs.to_dict().items()\n        }\n\n        td_metadata = self.metadata.copy()\n        td_metadata.pop(\"geff\", None)  # avoid geff being written multiple times\n\n        geff_metadata = geff.GeffMetadata(\n            directed=True,\n            axes=axes,\n            node_props_metadata=node_props_metadata,\n            edge_props_metadata=edge_props_metadata,\n            track_node_props=track_node_props,\n            extra={\n                \"tracksdata\": td_metadata,\n            },\n        )\n\n    node_dict = {\n        k: {\"values\": column_to_numpy(v), \"missing\": None}\n        for k, v in node_attrs.to_dict().items()\n        if k != DEFAULT_ATTR_KEYS.MASK\n    }\n\n    if DEFAULT_ATTR_KEYS.MASK in node_attrs.columns:\n        node_dict[DEFAULT_ATTR_KEYS.MASK] = construct_var_len_props(\n            [mask.mask.astype(np.uint64) for mask in node_attrs[DEFAULT_ATTR_KEYS.MASK]]\n        )\n\n    edge_dict = {k: {\"values\": column_to_numpy(v), \"missing\": None} for k, v in edge_attrs.to_dict().items()}\n\n    write_arrays(\n        geff_store,\n        node_ids=node_ids.astype(np.uint64),\n        node_props=node_dict,\n        edge_ids=edge_ids.astype(np.uint64),\n        edge_props=edge_dict,\n        metadata=geff_metadata,\n        zarr_format=zarr_format,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(geff_store)","title":"<code>geff_store</code>","text":"(<code>StoreLike</code>)           \u2013            <p>The store or path to the geff data directory to write the graph to.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(geff_metadata)","title":"<code>geff_metadata</code>","text":"(<code>GeffMetadata | None</code>, default:                   <code>None</code> )           \u2013            <p>The geff metadata to write to the graph. It automatically generates the metadata with: - axes: time (t) and spatial axes ((z), y, x) - tracklet node property: tracklet_id</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_geff(zarr_format)","title":"<code>zarr_format</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The zarr format to write the graph to. Defaults to 3.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_traccuracy_graph","title":"to_traccuracy_graph","text":"<pre><code>to_traccuracy_graph(\n    array_view_kwargs: dict[str, Any] | None = None,\n) -&gt; TrackingGraph\n</code></pre> <p>Convert the graph to a <code>traccuracy.TrackingGraph</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TrackingGraph</code>           \u2013            <p>A traccuracy graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def to_traccuracy_graph(self, array_view_kwargs: dict[str, Any] | None = None) -&gt; \"TrackingGraph\":\n    \"\"\"\n    Convert the graph to a `traccuracy.TrackingGraph`.\n\n    Parameters\n    ----------\n    array_view_kwargs : dict[str, Any] | None\n        Additional keyword arguments to pass to the `GraphArrayView` constructor used to create the segmentation.\n\n    Returns\n    -------\n    TrackingGraph\n        A traccuracy graph.\n    \"\"\"\n    from tracksdata.metrics._traccuracy import to_traccuracy_graph\n\n    return to_traccuracy_graph(self, array_view_kwargs=array_view_kwargs)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.to_traccuracy_graph(array_view_kwargs)","title":"<code>array_view_kwargs</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to pass to the <code>GraphArrayView</code> constructor used to create the segmentation.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph","title":"tracklet_graph","text":"<pre><code>tracklet_graph(\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph\n</code></pre> <p>Create a compressed tracklet graph where each node is a tracklet and each edge is a transition between tracklets.</p> <p>IMPORTANT: rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values. And edge values are the tuple of source and target tracklet ids.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>PyDiGraph</code>           \u2013            <p>A compressed tracklet graph.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_sql_graph.py</code> <pre><code>def tracklet_graph(\n    self,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    ignore_tracklet_id: int | None = None,\n) -&gt; rx.PyDiGraph:\n    \"\"\"\n    Create a compressed tracklet graph where each node is a tracklet\n    and each edge is a transition between tracklets.\n\n    IMPORTANT:\n    rx.PyDiGraph does not allow arbitrary indices, so we use the tracklet ids as node values.\n    And edge values are the tuple of source and target tracklet ids.\n\n    Parameters\n    ----------\n    tracklet_id_key : str\n        The key of the track id attribute.\n    ignore_tracklet_id : int | None\n        The track id to ignore. If None, all track ids are used.\n\n    Returns\n    -------\n    rx.PyDiGraph\n        A compressed tracklet graph.\n    \"\"\"\n\n    if tracklet_id_key not in self.node_attr_keys:\n        raise ValueError(f\"Track id key '{tracklet_id_key}' not found in graph. Expected '{self.node_attr_keys}'\")\n\n    with Session(self._engine) as session:\n        node_query = sa.select(getattr(self.Node, tracklet_id_key)).distinct()\n\n        SourceNode = aliased(self.Node)\n        TargetNode = aliased(self.Node)\n\n        edge_query = (\n            sa.select(\n                getattr(self.Edge, DEFAULT_ATTR_KEYS.EDGE_SOURCE),\n                getattr(self.Edge, DEFAULT_ATTR_KEYS.EDGE_TARGET),\n            )\n            .join(\n                SourceNode,\n                SourceNode.node_id == self.Edge.source_id,\n            )\n            .join(\n                TargetNode,\n                TargetNode.node_id == self.Edge.target_id,\n            )\n            .filter(\n                getattr(SourceNode, tracklet_id_key) != getattr(TargetNode, tracklet_id_key),\n            )\n        )\n\n        if ignore_tracklet_id is not None:\n            node_query = node_query.filter(getattr(self.Node, tracklet_id_key) != ignore_tracklet_id)\n            edge_query = edge_query.filter(\n                getattr(SourceNode, tracklet_id_key) != ignore_tracklet_id,\n                getattr(TargetNode, tracklet_id_key) != ignore_tracklet_id,\n            )\n\n        edge_query = edge_query.with_only_columns(\n            getattr(SourceNode, tracklet_id_key).label(\"source_tracklet_id\"),\n            getattr(TargetNode, tracklet_id_key).label(\"target_tracklet_id\"),\n        )\n\n        nodes_df = pl.read_database(\n            self._raw_query(node_query),\n            connection=session.connection(),\n        )\n\n        edges_df = pl.read_database(\n            self._raw_query(edge_query),\n            connection=session.connection(),\n        )\n\n    graph = rx.PyDiGraph()\n    tracklet_ids = nodes_df[tracklet_id_key].to_list()\n    tracklet_id_to_rx = dict(zip(tracklet_ids, graph.add_nodes_from(tracklet_ids), strict=False))\n    graph.add_edges_from(\n        zip(\n            edges_df[\"source_tracklet_id\"].map_elements(tracklet_id_to_rx.__getitem__, return_dtype=int).to_list(),\n            edges_df[\"target_tracklet_id\"].map_elements(tracklet_id_to_rx.__getitem__, return_dtype=int).to_list(),\n            zip(edges_df[\"source_tracklet_id\"].to_list(), edges_df[\"target_tracklet_id\"].to_list(), strict=False),\n            strict=True,\n        )\n    )\n\n    return graph\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph(tracklet_id_key)","title":"<code>tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>The key of the track id attribute.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_graph(ignore_tracklet_id)","title":"<code>ignore_tracklet_id</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The track id to ignore. If None, all track ids are used.</p>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_nodes","title":"tracklet_nodes","text":"<pre><code>tracklet_nodes(seeds: list[int] | None) -&gt; list[int]\n</code></pre> <p>Compute the non-branching tracklets around the provided seed node_ids.</p> <p>Walks forward to successors only through nodes with exactly one successor, and backward to predecessors that also have out_degree == 1, until closure.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>Sorted unique node IDs forming the closure.</p> </li> </ul> Source code in <code>src/tracksdata/graph/_base_graph.py</code> <pre><code>def tracklet_nodes(self, seeds: list[int] | None) -&gt; list[int]:\n    \"\"\"\n    Compute the non-branching tracklets around the provided seed node_ids.\n\n    Walks forward to successors only through nodes with exactly one successor,\n    and backward to predecessors that also have out_degree == 1, until closure.\n\n    Parameters\n    ----------\n    seeds : list[int]\n        Seed node IDs where to start the closure.\n\n    Returns\n    -------\n    list[int]\n        Sorted unique node IDs forming the closure.\n    \"\"\"\n    # NOTE: if this function becomes a bottleneck in the future it might be worth having\n    # a specialized version per backend\n    if seeds is None or len(seeds) == 0:\n        return []\n\n    track_node_ids: set[int] = set()\n    active_ids: set[int] = set(seeds)\n\n    while len(active_ids) &gt; 0:\n        track_node_ids.update(active_ids)\n\n        # Successors: only nodes with exactly one successor\n        succ_map = self.successors(node_ids=list(active_ids))\n        successors = [int(nodes[0]) for nodes in succ_map.values() if len(nodes) == 1]\n\n        # Predecessors: only nodes with exactly one predecessor and predecessor out_degree == 1\n        pred_map = self.predecessors(node_ids=list(active_ids))\n        predecessors = [int(nodes[0]) for nodes in pred_map.values() if len(nodes) == 1]\n\n        if len(predecessors) &gt; 0:\n            out_degrees = self.out_degree(predecessors)\n            if isinstance(out_degrees, int):\n                out_degrees = [out_degrees]\n            predecessors = [node for node, degree in zip(predecessors, out_degrees, strict=True) if degree == 1]\n\n        active_ids = (set(successors) | set(predecessors)) - track_node_ids\n\n    return sorted(track_node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/#tracksdata.graph.SQLGraph.tracklet_nodes(seeds)","title":"<code>seeds</code>","text":"(<code>list[int]</code>)           \u2013            <p>Seed node IDs where to start the closure.</p>"},{"location":"reference/tracksdata/graph/filters/","title":"filters","text":""},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters","title":"tracksdata.graph.filters","text":"<p>Classes:</p> <ul> <li> <code>BBoxSpatialFilter</code>           \u2013            <p>Spatial filter for bounding box queries on graph nodes.</p> </li> <li> <code>SpatialFilter</code>           \u2013            <p>Spatial filtering for graph nodes using spatial indexing.</p> </li> </ul>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter","title":"BBoxSpatialFilter","text":"<pre><code>BBoxSpatialFilter(\n    graph: BaseGraph,\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n)\n</code></pre> <p>Spatial filter for bounding box queries on graph nodes.</p> <p>This filter allows querying nodes within a bounding box defined by minimum and maximum coordinates for each spatial dimension.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph containing nodes with spatial coordinates. frame_attr_key : str | None, optional     The attribute key representing the frame or time dimension.     Default is None.     If None it will only use the bounding box coordinates. bbox_attr_key : str, optional     The attribute key representing the bounding box coordinates.     Defaults to <code>DEFAULT_ATTR_KEYS.BBOX</code>.     The bounding box coordinates should be in the format:     [min_x, min_y, min_z, ..., max_x, max_y, max_z, ...]     where each dimension has a min and max value.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Query nodes that overlaps with a spatial region of interest.</p> </li> </ul> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __init__(\n    self,\n    graph: \"BaseGraph\",\n    frame_attr_key: str | None = DEFAULT_ATTR_KEYS.T,\n    bbox_attr_key: str = DEFAULT_ATTR_KEYS.BBOX,\n) -&gt; None:\n    from spatial_graph import PointRTree\n\n    self._graph = graph\n    self._frame_attr_key = frame_attr_key\n    self._bbox_attr_key = bbox_attr_key\n\n    if frame_attr_key is None:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, bbox_attr_key]\n    else:\n        attr_keys = [DEFAULT_ATTR_KEYS.NODE_ID, frame_attr_key, bbox_attr_key]\n    nodes_df = graph.node_attrs(attr_keys=attr_keys)\n    node_ids = np.ascontiguousarray(nodes_df[DEFAULT_ATTR_KEYS.NODE_ID].to_numpy(), dtype=np.int64).copy()\n\n    if nodes_df.is_empty():\n        self._node_rtree = None\n    else:\n        bboxes = self._bboxes_to_array(nodes_df[bbox_attr_key])\n        if bboxes.shape[1] % 2 != 0:\n            raise ValueError(f\"Bounding box coordinates must have even number of dimensions, got {bboxes.shape[1]}\")\n        num_dims = bboxes.shape[1] // 2\n\n        if frame_attr_key is None:\n            self._ndims = num_dims\n            positions_min = np.ascontiguousarray(bboxes[:, :num_dims], dtype=np.float32)\n            positions_max = np.ascontiguousarray(bboxes[:, num_dims:], dtype=np.float32)\n        else:\n            frames = nodes_df[frame_attr_key].to_numpy()\n            self._ndims = num_dims + 1  # +1 for the frame dimension\n            positions_min = np.ascontiguousarray(\n                np.hstack((frames[:, np.newaxis], bboxes[:, :num_dims])), dtype=np.float32\n            )\n            positions_max = np.ascontiguousarray(\n                np.hstack((frames[:, np.newaxis], bboxes[:, num_dims:])), dtype=np.float32\n            )\n        self._node_rtree = PointRTree(\n            item_dtype=\"int64\",\n            coord_dtype=\"float32\",\n            dims=self._ndims,\n        )\n        self._node_rtree.insert_bb_items(node_ids, positions_min, positions_max)\n\n    # setup signal connections\n    self._graph.node_added.connect(self._add_node)\n    self._graph.node_removed.connect(self._remove_node)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(keys: tuple[slice, ...]) -&gt; BaseFilter\n</code></pre> <p>Query nodes that overlaps with a spatial region of interest.</p> <p>Uses spatial indexing to efficiently find nodes whose bounding boxes fall within the specified bounds for each spatial dimension.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter containing only nodes and their edges that fall within the spatial ROI.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of slices doesn't match the number of coordinate dimensions.</p> </li> </ul> <p>Examples:</p> <pre><code># For 2D spatial filter with the bounding boxes\n# overlapping with the region [10, 20] x [50, 60]\nspatial_filter = BBoxSpatialFilter(graph, bbox_attr_key=\"bbox\")\nfilter = spatial_filter[10:50, 20:60]\n\n# For 4D spatial filter with the t in [0, 10] and\n# bounding boxes overlapping with the region [0, 5] x [10, 50] x [20, 60]\nspatial_filter = BBoxSpatialFilter(graph, frame_attr_key=\"t\", bbox_attr_key=\"bbox\")\nsubgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n</code></pre> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __getitem__(self, keys: tuple[slice, ...]) -&gt; \"BaseFilter\":\n    \"\"\"\n    Query nodes that overlaps with a spatial region of interest.\n\n    Uses spatial indexing to efficiently find nodes whose bounding boxes fall within\n    the specified bounds for each spatial dimension.\n\n    Parameters\n    ----------\n    keys : tuple[slice, ...]\n        Tuple of slices defining the spatial bounds for each coordinate dimension.\n        Must match the number of coordinate dimensions specified in attr_keys.\n        Each slice defines [start, stop] bounds for that dimension.\n\n    Returns\n    -------\n    BaseFilter\n        A filter containing only nodes and their edges that fall within the spatial ROI.\n\n    Raises\n    ------\n    ValueError\n        If the number of slices doesn't match the number of coordinate dimensions.\n\n    Examples\n    --------\n    ```python\n    # For 2D spatial filter with the bounding boxes\n    # overlapping with the region [10, 20] x [50, 60]\n    spatial_filter = BBoxSpatialFilter(graph, bbox_attr_key=\"bbox\")\n    filter = spatial_filter[10:50, 20:60]\n\n    # For 4D spatial filter with the t in [0, 10] and\n    # bounding boxes overlapping with the region [0, 5] x [10, 50] x [20, 60]\n    spatial_filter = BBoxSpatialFilter(graph, frame_attr_key=\"t\", bbox_attr_key=\"bbox\")\n    subgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n    ```\n    \"\"\"\n\n    if self._node_rtree is None:\n        return self._graph.filter(node_ids=[])\n\n    for key in keys:\n        if key.start is None or key.stop is None:\n            raise ValueError(f\"Slice {key} must have start and stop\")\n\n    if len(keys) != self._ndims:\n        raise ValueError(f\"Expected {self._ndims} keys, got {len(keys)}\")\n\n    node_ids = self._node_rtree.search(\n        *(\n            np.stack(\n                [[s.start, s.stop] for s in keys],\n                axis=1,\n                dtype=np.float32,\n            )\n        )\n    )\n    return self._graph.filter(node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter.__getitem__(keys)","title":"<code>keys</code>","text":"(<code>tuple[slice, ...]</code>)           \u2013            <p>Tuple of slices defining the spatial bounds for each coordinate dimension. Must match the number of coordinate dimensions specified in attr_keys. Each slice defines [start, stop] bounds for that dimension.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._add_node","title":"_add_node","text":"<pre><code>_add_node(node_id: int) -&gt; None\n</code></pre> <p>Add a node to the spatial filter.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def _add_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Add a node to the spatial filter.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to add.\n    \"\"\"\n    from spatial_graph import PointRTree\n\n    if self._node_rtree is None:\n        if self._graph.num_nodes &gt; 0:\n            nodes_df = self._graph.node_attrs()\n            bboxes = self._bboxes_to_array(nodes_df[self._bbox_attr_key])\n            num_dims = bboxes.shape[1] // 2\n\n            if self._frame_attr_key is None:\n                self._ndims = num_dims\n            else:\n                self._ndims = num_dims + 1  # +1 for the frame dimension\n\n            self._node_rtree = PointRTree(\n                item_dtype=\"int64\",\n                coord_dtype=\"float32\",\n                dims=self._ndims,\n            )\n        else:\n            raise ValueError(\"Spatial filter is not initialized\")\n\n    attrs = self._graph[node_id].to_dict()\n    positions_min, positions_max = self._attrs_to_bb_window(attrs)\n\n    self._node_rtree.insert_bb_items(\n        np.atleast_1d(node_id).astype(np.int64),\n        positions_min,\n        positions_max,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._add_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to add.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._attrs_to_bb_window","title":"_attrs_to_bb_window","text":"<pre><code>_attrs_to_bb_window(\n    attrs: dict[str, Any],\n) -&gt; tuple[np.ndarray, np.ndarray]\n</code></pre> <p>Convert attributes to bounding box window.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[ndarray, ndarray]</code>           \u2013            <p>The minimum and maximum bounding box window.</p> </li> </ul> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def _attrs_to_bb_window(self, attrs: dict[str, Any]) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Convert attributes to bounding box window.\n\n    Parameters\n    ----------\n    attrs : dict[str, Any]\n        The attributes of the node to convert to a bounding box window.\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray]\n        The minimum and maximum bounding box window.\n    \"\"\"\n    bbox = attrs[self._bbox_attr_key]\n    pos_size = len(bbox) // 2\n    positions_min = bbox[:pos_size]\n    positions_max = bbox[pos_size:]\n\n    if self._frame_attr_key is not None:\n        positions_min = np.hstack((np.atleast_1d(attrs[self._frame_attr_key]), positions_min))\n        positions_max = np.hstack((np.atleast_1d(attrs[self._frame_attr_key]), positions_max))\n\n    positions_min = np.ascontiguousarray([positions_min], dtype=np.float32)\n    positions_max = np.ascontiguousarray([positions_max], dtype=np.float32)\n\n    return positions_min, positions_max\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._attrs_to_bb_window(attrs)","title":"<code>attrs</code>","text":"(<code>dict[str, Any]</code>)           \u2013            <p>The attributes of the node to convert to a bounding box window.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._bboxes_to_array","title":"_bboxes_to_array  <code>staticmethod</code>","text":"<pre><code>_bboxes_to_array(bbox_series: Series) -&gt; np.ndarray\n</code></pre> <p>Normalize bbox data to a 2D numpy array regardless of the polars dtype.</p> <p>Polars <code>List</code> columns produce a 1D object array from <code>to_numpy()</code>, which makes downstream shape checks fail. Converting via <code>to_list()</code> ensures we always have a dense 2D array of shape (N, 2*dims).</p> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>@staticmethod\ndef _bboxes_to_array(bbox_series: pl.Series) -&gt; np.ndarray:\n    \"\"\"\n    Normalize bbox data to a 2D numpy array regardless of the polars dtype.\n\n    Polars `List` columns produce a 1D object array from `to_numpy()`, which\n    makes downstream shape checks fail. Converting via `to_list()` ensures\n    we always have a dense 2D array of shape (N, 2*dims).\n    \"\"\"\n    # XXX This is a temporary workaround until metadata stores the correct dtype.\n    dim = len(bbox_series[0]) if len(bbox_series) &gt; 0 else None\n    if dim is None:\n        return np.empty((0, 0))\n    else:\n        return bbox_series.cast(pl.Array(pl.Int64, dim)).to_numpy()\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._remove_node","title":"_remove_node","text":"<pre><code>_remove_node(node_id: int) -&gt; None\n</code></pre> <p>Remove a node from the spatial filter.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def _remove_node(self, node_id: int) -&gt; None:\n    \"\"\"\n    Remove a node from the spatial filter.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to remove.\n    \"\"\"\n    if self._node_rtree is None:\n        raise ValueError(\"Spatial filter is not initialized\")\n\n    attrs = self._graph[node_id].to_dict()\n    positions_min, positions_max = self._attrs_to_bb_window(attrs)\n\n    self._node_rtree.delete_items(\n        np.atleast_1d(node_id).astype(np.int64),\n        positions_min,\n        positions_max,\n    )\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.BBoxSpatialFilter._remove_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to remove.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter","title":"SpatialFilter","text":"<pre><code>SpatialFilter(\n    graph: BaseGraph, attr_keys: list[str] | None = None\n)\n</code></pre> <p>Spatial filtering for graph nodes using spatial indexing.</p> <p>This filter creates a spatial index of graph nodes based on their spatial coordinates and allows efficient querying of nodes within spatial regions of interest (ROI).</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph containing nodes with spatial coordinates. attr_keys : list[str] | None, optional     List of attribute keys to use as spatial coordinates. If None, defaults to     [\"t\", \"z\", \"y\", \"x\"] filtered to only include keys present in the graph.</p>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter--examples","title":"Examples","text":"<pre><code>graph = RustWorkXGraph()\n# Add nodes with spatial coordinates\ngraph.add_node({\"t\": 0, \"y\": 10, \"x\": 20})\ngraph.add_node({\"t\": 1, \"y\": 30, \"x\": 40})\n\n# Create spatial filter with 2D coordinates\nspatial_filter = SpatialFilter(graph, attr_keys=[\"y\", \"x\"])\n\n# Query nodes in spatial region\nsubgraph = spatial_filter[0:50, 0:50]\n</code></pre> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>Query nodes within a spatial region of interest.</p> </li> </ul> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __init__(\n    self,\n    graph: \"BaseGraph\",\n    attr_keys: list[str] | None = None,\n) -&gt; None:\n    if attr_keys is None:\n        attr_keys = [\"t\", \"z\", \"y\", \"x\"]\n        valid_keys = set(graph.node_attr_keys)\n        attr_keys = list(filter(lambda x: x in valid_keys, attr_keys))\n\n    self._graph = graph\n\n    nodes_df = graph.node_attrs(attr_keys=[DEFAULT_ATTR_KEYS.NODE_ID, *attr_keys])\n    node_ids = nodes_df[DEFAULT_ATTR_KEYS.NODE_ID]\n\n    self._df_filter = DataFrameSpatialFilter(indices=node_ids, df=nodes_df.select(attr_keys))\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(keys: tuple[slice, ...]) -&gt; BaseFilter\n</code></pre> <p>Query nodes within a spatial region of interest.</p> <p>Uses spatial indexing to efficiently find nodes whose coordinates fall within the specified bounds for each spatial dimension.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>BaseFilter</code>           \u2013            <p>A filter containing only nodes and their edges that fall within the spatial ROI.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of slices doesn't match the number of coordinate dimensions.</p> </li> </ul> <p>Examples:</p> <pre><code># For 2D spatial filter with [\"y\", \"x\"] coordinates\nfilter = spatial_filter[10:50, 20:60]\n\n# For 4D spatial filter with [\"t\", \"z\", \"y\", \"x\"] coordinates\nsubgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n</code></pre> Source code in <code>src/tracksdata/graph/filters/_spatial_filter.py</code> <pre><code>def __getitem__(self, keys: tuple[slice, ...]) -&gt; \"BaseFilter\":\n    \"\"\"\n    Query nodes within a spatial region of interest.\n\n    Uses spatial indexing to efficiently find nodes whose coordinates fall within\n    the specified bounds for each spatial dimension.\n\n    Parameters\n    ----------\n    keys : tuple[slice, ...]\n        Tuple of slices defining the spatial bounds for each coordinate dimension.\n        Must match the number of coordinate dimensions specified in attr_keys.\n        Each slice defines [start, stop) bounds for that dimension.\n\n    Returns\n    -------\n    BaseFilter\n        A filter containing only nodes and their edges that fall within the spatial ROI.\n\n    Raises\n    ------\n    ValueError\n        If the number of slices doesn't match the number of coordinate dimensions.\n\n    Examples\n    --------\n    ```python\n    # For 2D spatial filter with [\"y\", \"x\"] coordinates\n    filter = spatial_filter[10:50, 20:60]\n\n    # For 4D spatial filter with [\"t\", \"z\", \"y\", \"x\"] coordinates\n    subgraph = spatial_filter[0:10, 0:5, 10:50, 20:60].subgraph()\n    ```\n    \"\"\"\n    node_ids = self._df_filter[keys]\n    return self._graph.filter(node_ids=node_ids)\n</code></pre>"},{"location":"reference/tracksdata/graph/filters/#tracksdata.graph.filters.SpatialFilter.__getitem__(keys)","title":"<code>keys</code>","text":"(<code>tuple[slice, ...]</code>)           \u2013            <p>Tuple of slices defining the spatial bounds for each coordinate dimension. Must match the number of coordinate dimensions specified in attr_keys. Each slice defines [start, stop) bounds for that dimension.</p>"},{"location":"reference/tracksdata/io/","title":"io","text":""},{"location":"reference/tracksdata/io/#tracksdata.io","title":"tracksdata.io","text":"<p>Input/output utilities for loading and saving tracking data in various formats.</p> <p>Functions:</p> <ul> <li> <code>compressed_tracks_table</code>             \u2013              <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> </li> <li> <code>from_ctc</code>             \u2013              <p>Load a CTC ground truth file into a graph.</p> </li> <li> <code>to_ctc</code>             \u2013              <p>Save a graph to a CTC data directory.</p> </li> </ul>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table","title":"compressed_tracks_table","text":"<pre><code>compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray\n</code></pre> <p>Compress the tracks of a graph into a (n, 4)-tabular format.</p> <p>Where - n is the number of tracks - 4 is the number of columns:     - tracklet_id: the track ID     - start: the start frame     - end: the end frame     - parent_tracklet_id: the parent track ID</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tracks</code> (              <code>ndarray</code> )          \u2013            <p>The compressed tracks.</p> </li> </ul> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def compressed_tracks_table(graph: BaseGraph) -&gt; np.ndarray:\n    \"\"\"\n    Compress the tracks of a graph into a (n, 4)-tabular format.\n\n    Where\n    - n is the number of tracks\n    - 4 is the number of columns:\n        - tracklet_id: the track ID\n        - start: the start frame\n        - end: the end frame\n        - parent_tracklet_id: the parent track ID\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to compress the tracks from.\n\n    Returns\n    -------\n    tracks : np.ndarray\n        The compressed tracks.\n    \"\"\"\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            DEFAULT_ATTR_KEYS.TRACKLET_ID,\n        ]\n    )\n\n    tracks_data = []\n    node_ids = []\n\n    for (tracklet_id,), group in nodes_df.group_by(DEFAULT_ATTR_KEYS.TRACKLET_ID):\n        start = group[DEFAULT_ATTR_KEYS.T].min()\n        end = group[DEFAULT_ATTR_KEYS.T].max()\n        tracks_data.append([tracklet_id, start, end, 0])\n        node_ids.append(group.filter(pl.col(DEFAULT_ATTR_KEYS.T) == start)[DEFAULT_ATTR_KEYS.NODE_ID].item())\n\n    parents = graph.predecessors(\n        node_ids,\n        attr_keys=[DEFAULT_ATTR_KEYS.TRACKLET_ID],\n        return_attrs=True,\n    )\n    for tracklet_id, node_id in zip(tracks_data, node_ids, strict=True):\n        df = parents[node_id]\n        if len(df) &gt; 0:\n            tracklet_id[3] = df[DEFAULT_ATTR_KEYS.TRACKLET_ID].item()\n\n    if len(tracks_data) == 0:\n        return np.empty((0, 4), dtype=int)\n\n    out_array = np.asarray(tracks_data, dtype=int)\n    out_array = out_array[np.argsort(out_array[:, 0])]\n\n    return out_array\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.compressed_tracks_table(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to compress the tracks from.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc","title":"from_ctc","text":"<pre><code>from_ctc(\n    data_dir: str | Path,\n    graph: BaseGraph,\n    region_props_kwargs: dict[str, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Load a CTC ground truth file into a graph. The resulting graph will have region properties attributes from a CTC data directory.</p> <p>Graph backend method API (e.g. <code>graph.from_ctc</code>) is preferred over this function.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--parameters","title":"Parameters","text":"<p>data_dir : str | Path     The path to the CTC data directory. graph : BaseGraph     The graph to load the CTC data into. region_props_kwargs : dict[str, Any]     Keyword arguments to pass to RegionPropsNodes.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--examples","title":"Examples","text":"<pre><code>from tracksdata.io import from_ctc\nfrom tracksdata.graph import RustWorkXGraph\n\ngraph = RustWorkXGraph()\nfrom_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.from_ctc--see-also","title":"See Also","text":"<p>BaseGraph.from_ctc:     Create a graph from a CTC data directory.</p> <p>RegionPropsNodes:     Operator to create nodes from label images.</p> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def from_ctc(\n    data_dir: str | Path,\n    graph: BaseGraph,\n    region_props_kwargs: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Load a CTC ground truth file into a graph.\n    The resulting graph will have region properties attributes from a CTC data directory.\n\n    Graph backend method API (e.g. `graph.from_ctc`) is preferred over this function.\n\n    Parameters\n    ----------\n    data_dir : str | Path\n        The path to the CTC data directory.\n    graph : BaseGraph\n        The graph to load the CTC data into.\n    region_props_kwargs : dict[str, Any]\n        Keyword arguments to pass to RegionPropsNodes.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.io import from_ctc\n    from tracksdata.graph import RustWorkXGraph\n\n    graph = RustWorkXGraph()\n    from_ctc(\"Fluo-N2DL-HeLa/01_GT/TRA\", graph)\n    ```\n\n    See Also\n    --------\n    [BaseGraph.from_ctc][tracksdata.graph.BaseGraph.from_ctc]:\n        Create a graph from a CTC data directory.\n\n    [RegionPropsNodes][tracksdata.nodes.RegionPropsNodes]:\n        Operator to create nodes from label images.\n\n    \"\"\"\n    data_dir = Path(data_dir)\n    if not data_dir.exists():\n        raise FileNotFoundError(f\"Data directory {data_dir} does not exist.\")\n\n    if region_props_kwargs is None:\n        region_props_kwargs = {}\n\n    if \"extra_properties\" not in region_props_kwargs:\n        region_props_kwargs[\"extra_properties\"] = [\"label\"]\n\n    elif \"label\" not in region_props_kwargs[\"extra_properties\"]:\n        region_props_kwargs[\"extra_properties\"].append(\"label\")\n\n    tracks_file_found = False\n    tracklet_id_graph = {}\n\n    for tracks_file in [\"man_track.txt\", \"res_track.txt\"]:\n        tracks_file_path = data_dir / tracks_file\n        if tracks_file_path.exists():\n            tracks_file_found = True\n            tracklet_id_graph = _load_tracks_file(tracks_file_path)\n            break\n\n    if not tracks_file_found:\n        LOG.warning(\n            f\"Tracks file {data_dir}/man_track.txt and {data_dir}/res_track.txt does not exist.\\n\"\n            \"Graph won't have edges.\"\n        )\n\n    labels = dask_imread(str(data_dir / \"*.tif\"), imread=tiff.imread)\n\n    region_props_nodes = RegionPropsNodes(**region_props_kwargs)\n    region_props_nodes.add_nodes(graph, labels=labels)\n\n    nodes_df = graph.node_attrs(\n        attr_keys=[\n            DEFAULT_ATTR_KEYS.NODE_ID,\n            DEFAULT_ATTR_KEYS.T,\n            \"label\",\n        ]\n    )\n\n    _add_edges_from_tracklet_ids(\n        graph,\n        nodes_df,\n        tracklet_id_graph,\n        \"label\",\n    )\n\n    # is duplicating an attribute that bad?\n    graph.add_node_attr_key(DEFAULT_ATTR_KEYS.TRACKLET_ID, -1)\n    graph.update_node_attrs(\n        node_ids=nodes_df[DEFAULT_ATTR_KEYS.NODE_ID].to_list(),\n        attrs={\n            DEFAULT_ATTR_KEYS.TRACKLET_ID: nodes_df[\"label\"].to_list(),\n        },\n    )\n</code></pre>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc","title":"to_ctc","text":"<pre><code>to_ctc(\n    graph: BaseGraph,\n    output_dir: str | Path,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None\n</code></pre> <p>Save a graph to a CTC data directory.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc--parameters","title":"Parameters","text":"<p>graph : BaseGraph     The graph to save. output_dir : str | Path     The directory to save the label images and the tracks graph to. shape : tuple[int, ...] | None, optional     The shape of the label images (T, (Z), Y, X).     If None, the shape is inferred from the graph metadata <code>shape</code> key. tracklet_id_key : str     The attribute key to use for the track IDs. overwrite : bool     Whether to overwrite the output directory if it exists.</p>"},{"location":"reference/tracksdata/io/#tracksdata.io.to_ctc--see-also","title":"See Also","text":"<p>BaseGraph.to_ctc:     Functional API to export into a CTC data directory.</p> Source code in <code>src/tracksdata/io/_ctc.py</code> <pre><code>def to_ctc(\n    graph: BaseGraph,\n    output_dir: str | Path,\n    shape: tuple[int, ...] | None = None,\n    tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"\n    Save a graph to a CTC data directory.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to save.\n    output_dir : str | Path\n        The directory to save the label images and the tracks graph to.\n    shape : tuple[int, ...] | None, optional\n        The shape of the label images (T, (Z), Y, X).\n        If None, the shape is inferred from the graph metadata `shape` key.\n    tracklet_id_key : str\n        The attribute key to use for the track IDs.\n    overwrite : bool\n        Whether to overwrite the output directory if it exists.\n\n    See Also\n    --------\n    [BaseGraph.to_ctc][tracksdata.graph.BaseGraph.to_ctc]:\n        Functional API to export into a CTC data directory.\n    \"\"\"\n    output_dir = Path(output_dir)\n    if output_dir.exists():\n        if overwrite:\n            shutil.rmtree(output_dir)\n        # and not empty\n        elif any(output_dir.iterdir()):\n            raise FileExistsError(f\"Output directory {output_dir} already exists.\")\n\n    output_dir = Path(output_dir)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    view = GraphArrayView(graph, shape=shape, attr_key=tracklet_id_key)\n\n    n_digits = max(len(str(view.shape[0])), 3)\n\n    tracks_table = compressed_tracks_table(graph)\n\n    np.savetxt(output_dir / \"res_track.txt\", tracks_table, fmt=\"%d\")\n\n    def _write_tiff(t: int) -&gt; None:\n        LOG.info(f\"Saving label image for time point {t}\")\n        tiff.imwrite(\n            output_dir / f\"mask{t:0{n_digits}d}.tif\",\n            view[t],\n            compression=\"LZW\",\n        )\n\n    list(\n        multiprocessing_apply(\n            _write_tiff,\n            range(view.shape[0]),\n            desc=\"Saving label images\",\n            sorted=False,\n        )\n    )\n</code></pre>"},{"location":"reference/tracksdata/metrics/","title":"metrics","text":""},{"location":"reference/tracksdata/metrics/#tracksdata.metrics","title":"tracksdata.metrics","text":"<p>Evaluation metrics for tracking performance, including the CTC benchmark metrics.</p> <p>If you use this module, please cite the respective papers of each metric, as described in here.</p> <p>Functions:</p> <ul> <li> <code>evaluate_ctc_metrics</code>             \u2013              <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> </li> <li> <code>visualize_matches</code>             \u2013              <p>Visualize the matches between the graph and the gt_graph.</p> </li> </ul>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics","title":"evaluate_ctc_metrics","text":"<pre><code>evaluate_ctc_metrics(\n    input_graph: RustWorkXGraph,\n    reference_graph: RustWorkXGraph,\n    input_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reference_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    input_reset: bool = True,\n    reference_reset: bool = False,\n    metrics: list[str] | None = None,\n) -&gt; dict[str, float]\n</code></pre> <p>Evaluate CTC metrics using <code>py-ctcmetrics</code> developed by Timo Kaiser.</p> <p>If you use this function, please cite the respective papers of each metric, as described in here.</p> <p>IMPORTANT: The <code>SEG</code> metric is computed from the TRA masks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>Dictionary with the results of the evaluated metrics.</p> </li> </ul> Source code in <code>src/tracksdata/metrics/_ctc_metrics.py</code> <pre><code>def evaluate_ctc_metrics(\n    input_graph: \"RustWorkXGraph\",\n    reference_graph: \"RustWorkXGraph\",\n    input_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    reference_tracklet_id_key: str = DEFAULT_ATTR_KEYS.TRACKLET_ID,\n    input_reset: bool = True,\n    reference_reset: bool = False,\n    metrics: list[str] | None = None,\n) -&gt; dict[str, float]:\n    \"\"\"\n    Evaluate CTC metrics using `py-ctcmetrics` developed by [Timo Kaiser](https://github.com/TimoK93).\n\n    If you use this function, please cite the respective papers of each metric, as described in\n    [here](https://github.com/CellTrackingChallenge/py-ctcmetrics?tab=readme-ov-file#acknowledgement-and-citations).\n\n    IMPORTANT: The `SEG` metric is computed from the TRA masks.\n\n    Parameters\n    ----------\n    input_graph : RustWorkXGraph\n        Input graph.\n    reference_graph : RustWorkXGraph\n        Reference graph.\n    input_tracklet_id_key : str, optional\n        Key to obtain the track id from the input graph.\n        If key does not exist, it will be created.\n    reference_tracklet_id_key : str, optional\n        Key to obtain the track id from the reference graph.\n        If key does not exist, it will be created.\n    input_reset : bool, optional\n        Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.\n    reference_reset : bool, optional\n        Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.\n    metrics : list[str] | None, optional\n        List of metrics to evaluate. If None, all metrics are evaluated.\n        Available metrics:\n        \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\",\n        \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"\n\n    Returns\n    -------\n    dict[str, float]\n        Dictionary with the results of the evaluated metrics.\n    \"\"\"\n    try:\n        from ctc_metrics.metrics import ALL_METRICS\n        from ctc_metrics.scripts.evaluate import calculate_metrics\n    except ImportError as e:\n        raise ImportError(\n            \"`py-ctcmetrics` is required to evaluate CTC metrics.\\nPlease install it with `pip install py-ctcmetrics`.\"\n        ) from e\n\n    if metrics is None:\n        metrics: list[str] = ALL_METRICS.copy()\n\n    if \"SEG\" in metrics:\n        LOG.warning(\"IMPORTANT! 'SEG' metric results are based on TRA masks, not the SEG masks.\")\n\n    if input_graph.num_nodes == 0:\n        LOG.warning(\"Input graph has no nodes, returning -1.0 for all metrics.\")\n        return dict.fromkeys(metrics, -1.0)\n\n    if input_reset or input_tracklet_id_key not in input_graph.node_attr_keys:\n        input_graph.assign_tracklet_ids(input_tracklet_id_key, reset=input_reset)\n\n    if reference_reset or reference_tracklet_id_key not in reference_graph.node_attr_keys:\n        reference_graph.assign_tracklet_ids(reference_tracklet_id_key, reset=reference_reset)\n\n    input_tracks, reference_tracks, matching_data = compute_ctc_metrics_data(\n        input_graph, reference_graph, input_tracklet_id_key, reference_tracklet_id_key\n    )\n\n    results = calculate_metrics(\n        comp_tracks=input_tracks,\n        ref_tracks=reference_tracks,\n        traj=matching_data,\n        segm=matching_data,\n        metrics=metrics,\n        is_valid=True,\n    )\n\n    results = {k: v.item() if hasattr(v, \"item\") else v for k, v in results.items()}\n\n    return results\n</code></pre>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_graph)","title":"<code>input_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Input graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_graph)","title":"<code>reference_graph</code>","text":"(<code>RustWorkXGraph</code>)           \u2013            <p>Reference graph.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_tracklet_id_key)","title":"<code>input_tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>Key to obtain the track id from the input graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_tracklet_id_key)","title":"<code>reference_tracklet_id_key</code>","text":"(<code>str</code>, default:                   <code>TRACKLET_ID</code> )           \u2013            <p>Key to obtain the track id from the reference graph. If key does not exist, it will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(input_reset)","title":"<code>input_reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset the track ids of the input graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(reference_reset)","title":"<code>reference_reset</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to reset the track ids of the reference graph. If True, the track ids will be reset to -1.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.evaluate_ctc_metrics(metrics)","title":"<code>metrics</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of metrics to evaluate. If None, all metrics are evaluated. Available metrics: \"CHOTA\", \"BC\", \"CT\", \"CCA\", \"TF\", \"TRA\", \"DET\", \"MOTA\", \"HOTA\", \"IDF1\", \"MTML\", \"FAF\", \"LNK\", \"OP_CTB\", \"OP_CSB\", \"BIO\", \"OP_CLB\"</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches","title":"visualize_matches","text":"<pre><code>visualize_matches(\n    input_graph: BaseGraph,\n    ref_graph: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n    viewer: Optional[Viewer] = None,\n    points_kwargs: dict | None = None,\n    vector_kwargs: dict | None = None,\n) -&gt; None\n</code></pre> <p>Visualize the matches between the graph and the gt_graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/metrics/_visualize.py</code> <pre><code>def visualize_matches(\n    input_graph: BaseGraph,\n    ref_graph: BaseGraph,\n    matched_node_id_key: str = DEFAULT_ATTR_KEYS.MATCHED_NODE_ID,\n    match_score_key: str = DEFAULT_ATTR_KEYS.MATCH_SCORE,\n    matched_edge_mask_key: str = DEFAULT_ATTR_KEYS.MATCHED_EDGE_MASK,\n    viewer: Optional[\"napari.Viewer\"] = None,\n    points_kwargs: dict | None = None,\n    vector_kwargs: dict | None = None,\n) -&gt; None:\n    \"\"\"\n    Visualize the matches between the graph and the gt_graph.\n\n    Parameters\n    ----------\n    input_graph : BaseGraph\n        The predicted graph to visualize.\n    ref_graph : BaseGraph\n        The reference (ground truth) graph to visualize.\n    matched_node_id_key : str, optional\n        The key of the attribute that contains the matched node IDs.\n        If not provided, the default key will be used.\n    match_score_key : str, optional\n        The key of the attribute that contains the match scores.\n        If not provided, the default key will be used.\n    matched_edge_mask_key : str, optional\n        The key of the attribute that contains the matched edge mask.\n        If not provided, the default key will be used.\n    viewer : napari.Viewer, optional\n        The napari viewer to use. If not provided, a new viewer will be created.\n    points_kwargs : dict, optional\n        Additional keyword arguments to the napari.Viewer.add_points method.\n    vector_kwargs : dict, optional\n        Additional keyword arguments to the napari.Viewer.add_vectors method.\n    \"\"\"\n    try:\n        import napari\n    except ImportError as e:\n        raise ImportError(\n            \"napari must be installed to use this function.\\nPlease install it with `pip install napari`.\",\n        ) from e\n\n    if viewer is None:\n        viewer = napari.Viewer()\n\n    if \"z\" in input_graph.node_attr_keys:\n        pos = [\"t\", \"z\", \"y\", \"x\"]\n    else:\n        pos = [\"t\", \"y\", \"x\"]\n\n    node_attrs = input_graph.node_attrs()\n    ref_node_attrs = ref_graph.node_attrs()\n\n    matched_points_kwargs = _add_matching_text_and_color(points_kwargs)\n    points_kwargs = _points_kwargs_defaults(points_kwargs)\n\n    layer = viewer.add_points(\n        node_attrs[pos],\n        name=\"predicted\",\n        properties={\n            \"matched_node_id\": node_attrs[matched_node_id_key],\n            \"match_score\": node_attrs[match_score_key],\n            \"matched\": node_attrs[matched_node_id_key] &gt;= 0,\n        },\n        **matched_points_kwargs,\n    )\n    layer.text.visible = False\n\n    matched_ref_mask = ref_node_attrs[DEFAULT_ATTR_KEYS.NODE_ID].is_in(node_attrs[matched_node_id_key].implode())\n    # matched_ref_node_attrs = ref_node_attrs.filter(matched_ref_mask)\n    unmatched_ref_node_attrs = ref_node_attrs.filter(~matched_ref_mask)\n\n    viewer.add_points(\n        unmatched_ref_node_attrs[pos],\n        name=\"missing objects\",\n        **points_kwargs,\n    )\n\n    edge_attrs = input_graph.edge_attrs(attr_keys=[matched_edge_mask_key])\n    source_pos = [f\"source_{p}\" for p in pos]\n    target_pos = [f\"target_{p}\" for p in pos]\n    source_matched_key = f\"source_{matched_node_id_key}\"\n    target_matched_key = f\"target_{matched_node_id_key}\"\n\n    edge_attrs = join_node_attrs_to_edges(\n        node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, matched_node_id_key, *pos),\n        edge_attrs,\n    )\n\n    # target positions is just the difference between source and target\n    # not the actual target position\n    edge_attrs[target_pos] = edge_attrs[target_pos] - edge_attrs[source_pos]\n\n    mask = edge_attrs[matched_edge_mask_key].to_numpy().astype(bool)\n\n    edge_arr = np.stack(\n        [\n            edge_attrs.select(*source_pos),\n            edge_attrs.select(*target_pos),\n        ],\n        axis=1,\n    )\n\n    matched_edge_arr = edge_arr[mask]\n    unmatched_edge_arr = edge_arr[~mask]\n\n    vector_kwargs = _vector_kwargs_defaults(vector_kwargs)\n\n    if matched_edge_arr.shape[0] &gt; 0:\n        viewer.add_vectors(\n            matched_edge_arr,\n            name=\"matched edges\",\n            edge_color=\"green\",\n            opacity=1,\n            **vector_kwargs,\n        )\n    else:\n        LOG.warning(\"No edges matched to the reference graph\")\n\n    if unmatched_edge_arr.shape[0] &gt; 0:\n        viewer.add_vectors(\n            unmatched_edge_arr,\n            name=\"unmatched input edges\",\n            edge_color=\"blue\",\n            opacity=0.2,\n            **vector_kwargs,\n        )\n    else:\n        LOG.warning(\"All edges matched to the reference graph\")\n\n    ref_edge_attrs = ref_graph.edge_attrs(attr_keys=[])\n\n    ref_edge_attrs = ref_edge_attrs.join(\n        edge_attrs.select(\n            matched_edge_mask_key,\n            source_matched_key,\n            target_matched_key,\n        ),\n        left_on=[DEFAULT_ATTR_KEYS.EDGE_SOURCE, DEFAULT_ATTR_KEYS.EDGE_TARGET],\n        right_on=[source_matched_key, target_matched_key],\n        how=\"left\",\n    )\n\n    unmatched_ref_edge_attrs = ref_edge_attrs.filter(ref_edge_attrs[matched_edge_mask_key].is_null())\n    unmatched_ref_edge_attrs = join_node_attrs_to_edges(\n        ref_node_attrs.select(DEFAULT_ATTR_KEYS.NODE_ID, *pos),\n        unmatched_ref_edge_attrs,\n    )\n\n    # same as above, target positions is just the difference between source and target\n    unmatched_ref_edge_attrs[target_pos] = unmatched_ref_edge_attrs[target_pos] - unmatched_ref_edge_attrs[source_pos]\n\n    unmatched_ref_edge_arr = np.stack(\n        [\n            unmatched_ref_edge_attrs.select(*source_pos),\n            unmatched_ref_edge_attrs.select(*target_pos),\n        ],\n        axis=1,\n    )\n\n    viewer.add_vectors(\n        unmatched_ref_edge_arr,\n        name=\"unmatched reference edges\",\n        edge_color=\"yellow\",\n        opacity=1,\n        **vector_kwargs,\n    )\n</code></pre>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(input_graph)","title":"<code>input_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The predicted graph to visualize.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(ref_graph)","title":"<code>ref_graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The reference (ground truth) graph to visualize.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(matched_node_id_key)","title":"<code>matched_node_id_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_NODE_ID</code> )           \u2013            <p>The key of the attribute that contains the matched node IDs. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(match_score_key)","title":"<code>match_score_key</code>","text":"(<code>str</code>, default:                   <code>MATCH_SCORE</code> )           \u2013            <p>The key of the attribute that contains the match scores. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(matched_edge_mask_key)","title":"<code>matched_edge_mask_key</code>","text":"(<code>str</code>, default:                   <code>MATCHED_EDGE_MASK</code> )           \u2013            <p>The key of the attribute that contains the matched edge mask. If not provided, the default key will be used.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(viewer)","title":"<code>viewer</code>","text":"(<code>Viewer</code>, default:                   <code>None</code> )           \u2013            <p>The napari viewer to use. If not provided, a new viewer will be created.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(points_kwargs)","title":"<code>points_kwargs</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to the napari.Viewer.add_points method.</p>"},{"location":"reference/tracksdata/metrics/#tracksdata.metrics.visualize_matches(vector_kwargs)","title":"<code>vector_kwargs</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>Additional keyword arguments to the napari.Viewer.add_vectors method.</p>"},{"location":"reference/tracksdata/nodes/","title":"nodes","text":""},{"location":"reference/tracksdata/nodes/#tracksdata.nodes","title":"tracksdata.nodes","text":"<p>Node operators for creating nodes and their respective attributes (e.g. masks) in a graph.</p> <p>Classes:</p> <ul> <li> <code>GenericFuncNodeAttrs</code>           \u2013            <p>Operator to apply a function to a node and insert the result as a new attribute.</p> </li> <li> <code>Mask</code>           \u2013            <p>Object used to store an individual segmentation mask of a single instance (object)</p> </li> <li> <code>MaskDiskAttrs</code>           \u2013            <p>Operator to create a disk mask for each node.</p> </li> <li> <code>RandomNodes</code>           \u2013            <p>Generate random node coordinates for testing and simulation purposes.</p> </li> <li> <code>RegionPropsNodes</code>           \u2013            <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> </li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs","title":"GenericFuncNodeAttrs","text":"<pre><code>GenericFuncNodeAttrs(\n    func: Callable[[T], R] | Callable[[list[T]], list[R]],\n    output_key: str,\n    default_value: Any = None,\n    attr_keys: Sequence[str] = (),\n    batch_size: int = 0,\n)\n</code></pre> <p>               Bases: <code>BaseNodeAttrsOperator</code></p> <pre><code>\n              flowchart TD\n              tracksdata.nodes.GenericFuncNodeAttrs[GenericFuncNodeAttrs]\n              tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator[BaseNodeAttrsOperator]\n\n                              tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator --&gt; tracksdata.nodes.GenericFuncNodeAttrs\n                \n\n\n              click tracksdata.nodes.GenericFuncNodeAttrs href \"\" \"tracksdata.nodes.GenericFuncNodeAttrs\"\n              click tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator href \"\" \"tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator\"\n            </code></pre> <p>Operator to apply a function to a node and insert the result as a new attribute.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, mask: Mask, t: int) -&gt; float:\n    cropped_frame = mask.crop(image)\n    valid_pixels = cropped_frame[mask.mask]\n    return np.median(valid_pixels) * t\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>With batching:</p> <pre><code>video = ...\ngraph = ...\n\n\ndef intensity_median_times_t(image: NDArray, masks: list[Mask], t: list[int]) -&gt; list[float]:\n    results = []\n    for i in range(len(masks)):\n        cropped_frame = masks[i].crop(image)\n        valid_pixels = cropped_frame[masks[i].mask]\n        value = np.median(valid_pixels) * t[i]\n        results.append(value)\n    return results\n\n\ncrop_attrs = GenericFuncNodeAttrs(\n    func=intensity_median,\n    output_key=\"intensity_median\",\n    attr_keys=[\"mask\", \"t\"],\n)\n\ncrop_attrs.add_node_attrs(graph, frames=video)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_node_attrs</code>             \u2013              <p>Add attributes to nodes of a graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def __init__(\n    self,\n    func: Callable[[T], R] | Callable[[list[T]], list[R]],\n    output_key: str,\n    default_value: Any = None,\n    attr_keys: Sequence[str] = (),\n    batch_size: int = 0,\n) -&gt; None:\n    super().__init__(output_key)\n    self.func = func\n    self.attr_keys = attr_keys\n    self.default_value = default_value\n    self.batch_size = batch_size\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(func)","title":"<code>func</code>","text":"(<code>Callable[[T], R] | Callable[[list[T]], list[R]]</code>)           \u2013            <p>Function to apply to the node. If <code>frames</code> is provided when calling <code>add_node_attrs</code>, the function must accept a single argument for the frame. Otherwise, the function must accept two arguments for the mask and the additional arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>)           \u2013            <p>Key of the new attribute to add.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            <p>Additional attributes to pass to the <code>func</code> as keyword arguments.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(default_value)","title":"<code>default_value</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Default value to use for the new attribute. TODO: this should be replaced by a more advanced typing that takes default values.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Batch size to use for the function. If 0, the function will be called for each node separately. If &gt; 0, the function will be called for each batch of nodes and return a list of results. The batch size is the number of nodes that will be passed to the function at once. Batch only contains nodes from the same time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, default_value=self.default_value)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time","title":"_node_attrs_per_time","text":"<pre><code>_node_attrs_per_time(\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _node_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add attributes for.\n    graph : BaseGraph\n        The graph to add attributes to.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that, when provided, `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    # Get node IDs for the specified time point\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if graph_filter.is_empty():\n        LOG.warning(f\"No nodes at time point {t}\")\n        return []\n\n    # Get attributes for these nodes\n    node_attrs = graph_filter.node_attrs(attr_keys=self.attr_keys)\n\n    args = []\n    if frames is not None:\n        args.append(np.asarray(frames[t]))\n\n    results = []\n    if self.batch_size &gt; 0:\n        size = len(node_attrs)\n        for i in range(0, size, self.batch_size):\n            batch_node_attrs = node_attrs.slice(i, self.batch_size)\n            batch_results = self.func(*args, **batch_node_attrs.to_dict())\n            results.extend(batch_results)\n\n    else:\n        for data_dict in node_attrs.rows(named=True):\n            result = self.func(*args, **data_dict)\n            results.append(result)\n\n    return graph_filter.node_ids(), {self.output_key: results}\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add attributes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs._node_attrs_per_time(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that, when provided, <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs","title":"add_node_attrs","text":"<pre><code>add_node_attrs(\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def add_node_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    super().add_node_attrs(graph, t=t, frames=frames)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.GenericFuncNodeAttrs.add_node_attrs(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask","title":"Mask","text":"<pre><code>Mask(mask: NDArray[bool_], bbox: ArrayLike)\n</code></pre> <p>Object used to store an individual segmentation mask of a single instance (object)</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask--parameters","title":"Parameters","text":"<p>mask : NDArray[np.bool_]     A binary indicating the pixels that are part of the object (e.g. cell, nucleus, etc.). bbox : np.ndarray     The bounding box of the region of interest with shape (2 * ndim,).     The first ndim elements are the start indices and the last ndim elements are the end indices.     Equivalent to slicing a numpy array with <code>[start:end]</code>. Examples</p> <pre><code>mask = Mask(mask=np.array([[True, False], [False, True]]), bbox=np.array([0, 0, 2, 2]))\n</code></pre> <p>Methods:</p> <ul> <li> <code>__isub__</code>             \u2013              <p>Compute the difference between two masks considering their bounding boxes location.</p> </li> <li> <code>__or__</code>             \u2013              <p>Compute the union mask between two masks considering their bounding boxes location.</p> </li> <li> <code>crop</code>             \u2013              <p>Crop the mask from an image.</p> </li> <li> <code>dilate</code>             \u2013              <p>Dilate the mask by a given radius inplace.</p> </li> <li> <code>from_coordinates</code>             \u2013              <p>Create a mask from a center and a radius.</p> </li> <li> <code>intersection</code>             \u2013              <p>Compute the intersection between two masks considering their bounding boxes location.</p> </li> <li> <code>iou</code>             \u2013              <p>Compute the Intersection over Union (IoU) between two masks</p> </li> <li> <code>mask_indices</code>             \u2013              <p>Get the indices of the pixels that are part of the object.</p> </li> <li> <code>move</code>             \u2013              <p>Move the mask by a given offset inplace.</p> </li> <li> <code>paint_buffer</code>             \u2013              <p>Paint object into a buffer.</p> </li> <li> <code>regionprops</code>             \u2013              <p>Compute scikit-image regionprops for this mask.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>int</code>)           \u2013            <p>Get the number of pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __init__(\n    self,\n    mask: NDArray[np.bool_],\n    bbox: ArrayLike,\n):\n    self._mask = mask\n    self.bbox = bbox\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.size","title":"size  <code>cached</code> <code>property</code>","text":"<pre><code>size: int\n</code></pre> <p>Get the number of pixels that are part of the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.__isub__","title":"__isub__","text":"<pre><code>__isub__(other: Mask) -&gt; Mask\n</code></pre> <p>Compute the difference between two masks considering their bounding boxes location.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __isub__(self, other: \"Mask\") -&gt; \"Mask\":\n    \"\"\"\n    Compute the difference between two masks considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the difference with.\n    \"\"\"\n    if self.intersection(other) == 0:\n        return self\n\n    other_slicing = []\n    self_slicing = []\n    for i in range(self._mask.ndim):\n        diff = self._bbox[i] - other._bbox[i]\n        if diff &gt; 0:\n            self_s = None\n            other_s = diff\n        else:\n            self_s = -diff\n            other_s = None\n\n        diff = self._bbox[i + self._mask.ndim] - other._bbox[i + other._mask.ndim]\n        if diff &gt; 0:\n            self_e = -diff\n            other_e = None\n        elif diff &lt; 0:\n            self_e = None\n            other_e = diff\n        else:\n            self_e = None\n            other_e = None\n\n        self_slicing.append(slice(self_s, self_e))\n        other_slicing.append(slice(other_s, other_e))\n\n    self_slicing = tuple(self_slicing)\n    other_slicing = tuple(other_slicing)\n\n    self._mask[self_slicing] &amp;= ~other._mask[other_slicing]\n    return self\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.__isub__(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the difference with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.__or__","title":"__or__","text":"<pre><code>__or__(other: Mask) -&gt; Mask\n</code></pre> <p>Compute the union mask between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Mask</code>           \u2013            <p>The union mask between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __or__(self, other: \"Mask\") -&gt; \"Mask\":\n    \"\"\"\n    Compute the union mask between two masks considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the union with.\n\n    Returns\n    -------\n    Mask\n        The union mask between the two masks.\n    \"\"\"\n    ndim = self._mask.ndim\n    other_ndim = other._mask.ndim\n    if ndim != other_ndim:\n        raise ValueError(f\"Cannot compute union between masks of different dimensions: {ndim} and {other_ndim}.\")\n\n    self_start = self._bbox[:ndim]\n    self_end = self._bbox[ndim:]\n    other_start = other._bbox[:ndim]\n    other_end = other._bbox[ndim:]\n\n    union_start = np.minimum(self_start, other_start)\n    union_end = np.maximum(self_end, other_end)\n    union_shape = union_end - union_start\n\n    union_mask = np.zeros(union_shape, dtype=np.bool_)\n\n    self_slice = tuple(\n        slice(start - base, end - base) for start, end, base in zip(self_start, self_end, union_start, strict=True)\n    )\n    other_slice = tuple(\n        slice(start - base, end - base)\n        for start, end, base in zip(other_start, other_end, union_start, strict=True)\n    )\n\n    union_mask[self_slice] |= self._mask\n    union_mask[other_slice] |= other._mask\n\n    return Mask(union_mask, np.concatenate([union_start, union_end]))\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.__or__(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the union with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask._crop_overhang","title":"_crop_overhang","text":"<pre><code>_crop_overhang(image_shape: tuple[int, ...]) -&gt; None\n</code></pre> <p>Crop regions of the mask that are outside the image. This is used to fix bounding box and mask after changes to the mask.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def _crop_overhang(self, image_shape: tuple[int, ...]) -&gt; None:\n    \"\"\"\n    Crop regions of the mask that are outside the image.\n    This is used to fix bounding box and mask after changes to the mask.\n\n    Parameters\n    ----------\n    image_shape : tuple[int, ...]\n        The shape of the image.\n    \"\"\"\n    left_overhang = np.maximum(0, -self._bbox[: self._mask.ndim])\n    self._bbox[: self._mask.ndim] += left_overhang\n\n    right_overhang = np.maximum(0, self._bbox[self._mask.ndim :] - image_shape)\n    self._bbox[self._mask.ndim :] -= right_overhang\n\n    slicing = tuple(slice(s, -e if e &gt; 0 else None) for s, e in zip(left_overhang, right_overhang, strict=True))\n    self._mask = self._mask[slicing]\n    self.bbox = self._bbox  # triggering bbox and mask shape check\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask._crop_overhang(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the image.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop","title":"crop","text":"<pre><code>crop(\n    image: NDArray, shape: tuple[int, ...] | None = None\n) -&gt; NDArray\n</code></pre> <p>Crop the mask from an image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NDArray</code>           \u2013            <p>The cropped image.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def crop(\n    self,\n    image: NDArray,\n    shape: tuple[int, ...] | None = None,\n) -&gt; NDArray:\n    \"\"\"\n    Crop the mask from an image.\n\n    Parameters\n    ----------\n    image : NDArray\n        The image to crop from.\n    shape : tuple[int, ...] | None\n        The shape of the cropped image. If None, the `bbox` will be used.\n\n    Returns\n    -------\n    NDArray\n        The cropped image.\n    \"\"\"\n    if shape is None:\n        ndim = self._mask.ndim\n        slicing = tuple(slice(self._bbox[i], self._bbox[i + ndim]) for i in range(ndim))\n\n    else:\n        center = (self._bbox[: self._mask.ndim] + self._bbox[self._mask.ndim :]) // 2\n        half_shape = np.asarray(shape) // 2\n        start = np.maximum(center - half_shape, 0)\n        end = np.minimum(center + shape - half_shape, image.shape)\n        slicing = tuple(slice(s, e) for s, e in zip(start, end, strict=True))\n\n    return image[slicing]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(image)","title":"<code>image</code>","text":"(<code>NDArray</code>)           \u2013            <p>The image to crop from.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.crop(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the cropped image. If None, the <code>bbox</code> will be used.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.dilate","title":"dilate","text":"<pre><code>dilate(\n    radius: int, image_shape: tuple[int, ...] | None = None\n) -&gt; None\n</code></pre> <p>Dilate the mask by a given radius inplace.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def dilate(self, radius: int, image_shape: tuple[int, ...] | None = None) -&gt; None:\n    \"\"\"\n    Dilate the mask by a given radius inplace.\n\n    Parameters\n    ----------\n    radius : int\n        The radius of the dilation.\n    image_shape : tuple[int, ...] | None\n        The shape of the image.\n        When provided handles regions outside the image.\n    \"\"\"\n    new_mask = np.pad(self.mask, radius, mode=\"constant\", constant_values=False)\n\n    morph.dilation(\n        new_mask,\n        _nd_sphere(radius, new_mask.ndim),\n        mode=\"constant\",\n        cval=False,\n        out=new_mask,\n    )\n    self._mask = new_mask\n    self._bbox[: self._mask.ndim] -= radius\n    self._bbox[self._mask.ndim :] += radius\n\n    if image_shape is not None:\n        self._crop_overhang(image_shape)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.dilate(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the dilation.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.dilate(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the image. When provided handles regions outside the image.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates","title":"from_coordinates  <code>classmethod</code>","text":"<pre><code>from_coordinates(\n    center: NDArray,\n    radius: int,\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; Mask\n</code></pre> <p>Create a mask from a center and a radius. Regions outside the image are cropped.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Mask</code>           \u2013            <p>The mask.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>@classmethod\ndef from_coordinates(\n    cls,\n    center: NDArray,\n    radius: int,\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; \"Mask\":\n    \"\"\"\n    Create a mask from a center and a radius.\n    Regions outside the image are cropped.\n\n    Parameters\n    ----------\n    center : NDArray\n        The center of the mask.\n    radius : int\n        The radius of the mask.\n    image_shape : tuple[int, ...] | None\n        The shape of the image.\n        When provided crops regions outside the image.\n\n    Returns\n    -------\n    Mask\n        The mask.\n    \"\"\"\n    mask = _nd_sphere(radius, len(center))\n    center = np.round(center).astype(int)\n\n    start = center - np.asarray(mask.shape) // 2\n    end = start + mask.shape\n\n    if image_shape is None:\n        bbox = np.concatenate([start, end])\n    else:\n        processed_start = np.maximum(start, 0)\n        processed_end = np.minimum(end, image_shape)\n\n        start_overhang = processed_start - start\n        end_overhang = end - processed_end\n\n        mask = mask[\n            tuple(slice(s, -e if e &gt; 0 else None) for s, e in zip(start_overhang, end_overhang, strict=True))\n        ]\n\n        bbox = np.concatenate([processed_start, processed_end])\n\n    return cls(mask, bbox)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(center)","title":"<code>center</code>","text":"(<code>NDArray</code>)           \u2013            <p>The center of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.from_coordinates(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>The shape of the image. When provided crops regions outside the image.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection","title":"intersection","text":"<pre><code>intersection(other: Mask) -&gt; float\n</code></pre> <p>Compute the intersection between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The intersection between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def intersection(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the intersection between two masks considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the intersection with.\n\n    Returns\n    -------\n    float\n        The intersection between the two masks.\n    \"\"\"\n    return fast_intersection_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.intersection(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the intersection with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou","title":"iou","text":"<pre><code>iou(other: Mask) -&gt; float\n</code></pre> <p>Compute the Intersection over Union (IoU) between two masks considering their bounding boxes location.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The IoU between the two masks.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def iou(self, other: \"Mask\") -&gt; float:\n    \"\"\"\n    Compute the Intersection over Union (IoU) between two masks\n    considering their bounding boxes location.\n\n    Parameters\n    ----------\n    other : Mask\n        The other mask to compute the IoU with.\n\n    Returns\n    -------\n    float\n        The IoU between the two masks.\n    \"\"\"\n    return fast_iou_with_bbox(self._bbox, other._bbox, self._mask, other._mask)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.iou(other)","title":"<code>other</code>","text":"(<code>Mask</code>)           \u2013            <p>The other mask to compute the IoU with.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices","title":"mask_indices","text":"<pre><code>mask_indices(\n    offset: NDArray[integer] | int = 0,\n) -&gt; tuple[NDArray[np.integer], ...]\n</code></pre> <p>Get the indices of the pixels that are part of the object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[NDArray[integer], ...]</code>           \u2013            <p>The indices of the pixels that are part of the object.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def mask_indices(\n    self,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; tuple[NDArray[np.integer], ...]:\n    \"\"\"\n    Get the indices of the pixels that are part of the object.\n\n    Parameters\n    ----------\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n\n    Returns\n    -------\n    tuple[NDArray[np.integer], ...]\n        The indices of the pixels that are part of the object.\n    \"\"\"\n    if isinstance(offset, int):\n        offset = np.full(self._mask.ndim, offset)\n\n    indices = list(np.nonzero(self._mask))\n\n    for i, index in enumerate(indices):\n        indices[i] = index + self._bbox[i] + offset[i]\n\n    return tuple(indices)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.mask_indices(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.move","title":"move","text":"<pre><code>move(\n    offset: NDArray[integer],\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; None\n</code></pre> <p>Move the mask by a given offset inplace.</p> <p>Parameters offset : NDArray[np.integer]     The offset to move the mask by. image_shape : tuple[int, ...] | None     The shape of the image.     When provided handles regions outside the image.</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def move(\n    self,\n    offset: NDArray[np.integer],\n    image_shape: tuple[int, ...] | None = None,\n) -&gt; None:\n    \"\"\"\n    Move the mask by a given offset inplace.\n\n    Parameters\n    offset : NDArray[np.integer]\n        The offset to move the mask by.\n    image_shape : tuple[int, ...] | None\n        The shape of the image.\n        When provided handles regions outside the image.\n    \"\"\"\n    self._bbox[: self._mask.ndim] += offset\n    self._bbox[self._mask.ndim :] += offset\n    if image_shape is not None:\n        self._crop_overhang(image_shape)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer","title":"paint_buffer","text":"<pre><code>paint_buffer(\n    buffer: ndarray,\n    value: int | float,\n    offset: NDArray[integer] | int = 0,\n) -&gt; None\n</code></pre> <p>Paint object into a buffer.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def paint_buffer(\n    self,\n    buffer: np.ndarray,\n    value: int | float,\n    offset: NDArray[np.integer] | int = 0,\n) -&gt; None:\n    \"\"\"\n    Paint object into a buffer.\n\n    Parameters\n    ----------\n    buffer : np.ndarray\n        The buffer to paint inplace.\n    value : int | float\n        The value to paint the object.\n    offset : NDArray[np.integer] | int, optional\n        The offset to add to the indices, should be used with bounding box information.\n    \"\"\"\n    if isinstance(offset, int):\n        offset = np.full(self._mask.ndim, offset)\n\n    window = tuple(\n        slice(i + o, j + o)\n        for i, j, o in zip(self._bbox[: self._mask.ndim], self._bbox[self._mask.ndim :], offset, strict=True)\n    )\n    buffer[window][self._mask] = value\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(buffer)","title":"<code>buffer</code>","text":"(<code>ndarray</code>)           \u2013            <p>The buffer to paint inplace.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(value)","title":"<code>value</code>","text":"(<code>int | float</code>)           \u2013            <p>The value to paint the object.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.paint_buffer(offset)","title":"<code>offset</code>","text":"(<code>NDArray[integer] | int</code>, default:                   <code>0</code> )           \u2013            <p>The offset to add to the indices, should be used with bounding box information.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.Mask.regionprops","title":"regionprops","text":"<pre><code>regionprops() -&gt; RegionProperties\n</code></pre> <p>Compute scikit-image regionprops for this mask.</p> <p>The computation is aware of the mask bounding box, so coordinate-based properties (e.g. centroid, coords) are returned in absolute image coordinates.</p> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def regionprops(self) -&gt; \"RegionProperties\":\n    \"\"\"\n    Compute scikit-image regionprops for this mask.\n\n    The computation is aware of the mask bounding box, so coordinate-based\n    properties (e.g. centroid, coords) are returned in absolute\n    image coordinates.\n    \"\"\"\n    props = regionprops(\n        self._mask.astype(np.uint16),\n        cache=True,\n        offset=tuple(self._bbox[: self._mask.ndim]),\n    )\n\n    if len(props) != 1:\n        raise ValueError(\"Expected a single region in mask to compute regionprops.\")\n\n    return props[0]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs","title":"MaskDiskAttrs","text":"<pre><code>MaskDiskAttrs(\n    radius: int,\n    image_shape: tuple[int, ...],\n    attr_keys: Sequence[str] | None = None,\n    output_key: str = DEFAULT_ATTR_KEYS.MASK,\n)\n</code></pre> <p>               Bases: <code>GenericFuncNodeAttrs</code></p> <pre><code>\n              flowchart TD\n              tracksdata.nodes.MaskDiskAttrs[MaskDiskAttrs]\n              tracksdata.nodes._generic_nodes.GenericFuncNodeAttrs[GenericFuncNodeAttrs]\n              tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator[BaseNodeAttrsOperator]\n\n                              tracksdata.nodes._generic_nodes.GenericFuncNodeAttrs --&gt; tracksdata.nodes.MaskDiskAttrs\n                                tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator --&gt; tracksdata.nodes._generic_nodes.GenericFuncNodeAttrs\n                \n\n\n\n              click tracksdata.nodes.MaskDiskAttrs href \"\" \"tracksdata.nodes.MaskDiskAttrs\"\n              click tracksdata.nodes._generic_nodes.GenericFuncNodeAttrs href \"\" \"tracksdata.nodes._generic_nodes.GenericFuncNodeAttrs\"\n              click tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator href \"\" \"tracksdata.nodes._base_node_attrs.BaseNodeAttrsOperator\"\n            </code></pre> <p>Operator to create a disk mask for each node.</p> <p>Masks are created in space, so temporal information should not be provided.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_node_attrs</code>             \u2013              <p>Add attributes to nodes of a graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_mask.py</code> <pre><code>def __init__(\n    self,\n    radius: int,\n    image_shape: tuple[int, ...],\n    attr_keys: Sequence[str] | None = None,\n    output_key: str = DEFAULT_ATTR_KEYS.MASK,\n):\n    if attr_keys is None:\n        default_columns = [\"z\", \"y\", \"x\"]\n        attr_keys = default_columns[-len(image_shape) :]\n\n    if len(attr_keys) != len(image_shape):\n        raise ValueError(\n            f\"Expected image shape {image_shape} to have the same number of dimensions as attr_keys '{attr_keys}'.\"\n        )\n\n    super().__init__(\n        func=lambda **kwargs: Mask.from_coordinates(\n            center=np.asarray(list(kwargs.values())),\n            radius=radius,\n            image_shape=image_shape,\n        ),\n        output_key=output_key,\n        attr_keys=attr_keys,\n        default_value=None,\n        batch_size=0,\n    )\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(radius)","title":"<code>radius</code>","text":"(<code>int</code>)           \u2013            <p>The radius of the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(image_shape)","title":"<code>image_shape</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The shape of the image, must match the number of  of the attr_keys.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(attr_keys)","title":"<code>attr_keys</code>","text":"(<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The attributes for the center of the mask. If not provided, \"z\", \"y\", \"x\" will be used.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>MASK</code> )           \u2013            <p>The key of the attribute to store the mask.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(graph: BaseGraph) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, default_value=self.default_value)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time","title":"_node_attrs_per_time","text":"<pre><code>_node_attrs_per_time(\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def _node_attrs_per_time(\n    self,\n    t: int,\n    *,\n    graph: BaseGraph,\n    frames: NDArray | None = None,\n) -&gt; tuple[list[int], dict[str, list[Any]]]:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add attributes for.\n    graph : BaseGraph\n        The graph to add attributes to.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that, when provided, `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    # Get node IDs for the specified time point\n    graph_filter = graph.filter(NodeAttr(DEFAULT_ATTR_KEYS.T) == t)\n\n    if graph_filter.is_empty():\n        LOG.warning(f\"No nodes at time point {t}\")\n        return []\n\n    # Get attributes for these nodes\n    node_attrs = graph_filter.node_attrs(attr_keys=self.attr_keys)\n\n    args = []\n    if frames is not None:\n        args.append(np.asarray(frames[t]))\n\n    results = []\n    if self.batch_size &gt; 0:\n        size = len(node_attrs)\n        for i in range(0, size, self.batch_size):\n            batch_node_attrs = node_attrs.slice(i, self.batch_size)\n            batch_results = self.func(*args, **batch_node_attrs.to_dict())\n            results.extend(batch_results)\n\n    else:\n        for data_dict in node_attrs.rows(named=True):\n            result = self.func(*args, **data_dict)\n            results.append(result)\n\n    return graph_filter.node_ids(), {self.output_key: results}\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add attributes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs._node_attrs_per_time(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that, when provided, <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs","title":"add_node_attrs","text":"<pre><code>add_node_attrs(\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None\n</code></pre> <p>Add attributes to nodes of a graph.</p> <p>Parameters:</p> Source code in <code>src/tracksdata/nodes/_generic_nodes.py</code> <pre><code>def add_node_attrs(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    frames: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add attributes to nodes of a graph.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add attributes to.\n    t : int | None\n        The time point to add attributes for. If None, add attributes for all time points.\n    frames : NDArray | None\n        The frames to index by time point to pass to the `func` function.\n        Such that `frames[t]` will be passed to the `func` function.\n    \"\"\"\n    super().add_node_attrs(graph, t=t, frames=frames)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add attributes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The time point to add attributes for. If None, add attributes for all time points.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.MaskDiskAttrs.add_node_attrs(frames)","title":"<code>frames</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>The frames to index by time point to pass to the <code>func</code> function. Such that <code>frames[t]</code> will be passed to the <code>func</code> function.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes","title":"RandomNodes","text":"<pre><code>RandomNodes(\n    n_time_points: int,\n    n_nodes_per_tp: tuple[int, int],\n    n_dim: Literal[2, 3] = 3,\n    random_state: int = 0,\n)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <pre><code>\n              flowchart TD\n              tracksdata.nodes.RandomNodes[RandomNodes]\n              tracksdata.nodes._base_nodes.BaseNodesOperator[BaseNodesOperator]\n\n                              tracksdata.nodes._base_nodes.BaseNodesOperator --&gt; tracksdata.nodes.RandomNodes\n                \n\n\n              click tracksdata.nodes.RandomNodes href \"\" \"tracksdata.nodes.RandomNodes\"\n              click tracksdata.nodes._base_nodes.BaseNodesOperator href \"\" \"tracksdata.nodes._base_nodes.BaseNodesOperator\"\n            </code></pre> <p>Generate random node coordinates for testing and simulation purposes.</p> <p>RandomNodes creates nodes with randomly distributed coordinates within the unit hypercube [0,1]^n. This is useful for testing tracking algorithms, generating synthetic datasets, or creating baseline comparisons. The number of nodes per time point can vary randomly within a specified range.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>n_time_points</code>               (<code>int</code>)           \u2013            <p>Number of time points to generate.</p> </li> <li> <code>n_nodes</code>               (<code>tuple[int, int]</code>)           \u2013            <p>Range of nodes per time point.</p> </li> <li> <code>spatial_cols</code>               (<code>list[str]</code>)           \u2013            <p>Names of spatial coordinate columns.</p> </li> <li> <code>rng</code>               (<code>Generator</code>)           \u2013            <p>Random number generator instance.</p> </li> </ul> See Also <p>RegionPropsNodes:     Extract nodes from segmented images using region properties.</p> <p>Mask:     Node operator for mask-based objects.</p> <p>Examples:</p> <p>Generate 2D random nodes:</p> <pre><code>from tracksdata.nodes import RandomNodes\n\nnode_op = RandomNodes(n_time_points=10, n_nodes_per_tp=(5, 15), n_dim=2, random_state=42)\n</code></pre> <p>Add nodes to a graph:</p> <pre><code>node_op.add_nodes(graph)\n</code></pre> <p>Generate nodes for a specific time point:</p> <pre><code>node_op.add_nodes(graph, t=5)\n</code></pre> <p>Use 3D coordinates with consistent node count:</p> <pre><code>node_op = RandomNodes(\n    n_time_points=20,\n    n_nodes_per_tp=(10, 10),  # exactly 10 nodes per time point\n    n_dim=3,\n)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Override the base add_nodes method to handle n_time_points parameter.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def __init__(\n    self,\n    n_time_points: int,\n    n_nodes_per_tp: tuple[int, int],\n    n_dim: Literal[2, 3] = 3,\n    random_state: int = 0,\n):\n    super().__init__()\n    if isinstance(n_nodes_per_tp, int):\n        raise ValueError(\"`n_nodes_per_tp` must be a tuple of two integers\")\n\n    self.n_time_points = n_time_points\n    self.n_nodes = n_nodes_per_tp\n\n    if n_dim == 2:\n        self.spatial_cols = [\"x\", \"y\"]\n    elif n_dim == 3:\n        self.spatial_cols = [\"x\", \"y\", \"z\"]\n    else:\n        raise ValueError(f\"Invalid number of dimensions: {n_dim}\")\n\n    self.rng = np.random.default_rng(random_state)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_time_points)","title":"<code>n_time_points</code>","text":"(<code>int</code>)           \u2013            <p>The number of time points to generate nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_nodes_per_tp)","title":"<code>n_nodes_per_tp</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The minimum and maximum number of nodes to generate per time point. The actual number is randomly chosen within this range for each time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(n_dim)","title":"<code>n_dim</code>","text":"(<code>Literal[2, 3]</code>, default:                   <code>3</code> )           \u2013            <p>The spatial dimensionality of the coordinates:</p> <ul> <li>2: generates (x, y) coordinates</li> <li>3: generates (x, y, z) coordinates</li> </ul>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes(random_state)","title":"<code>random_state</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Random seed for reproducible results.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(\n    t: int, **kwargs: Any\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    **kwargs: Any,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point.\n\n    Parameters\n    ----------\n    t : int\n        The time point to add nodes for.\n    **kwargs : Any\n        Additional keyword arguments to pass to add_node.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n    \"\"\"\n    n_nodes_at_t = self.rng.integers(\n        self.n_nodes[0],\n        self.n_nodes[1],\n    )\n\n    coords = self.rng.uniform(\n        low=0,\n        high=1,\n        size=(n_nodes_at_t, len(self.spatial_cols)),\n    ).tolist()\n\n    return [{\"t\": t, **dict(zip(self.spatial_cols, c, strict=True)), **kwargs} for c in coords]\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to add nodes for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes._nodes_per_time(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to add_node.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RandomNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(\n    graph: BaseGraph, *, t: int | None = None, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Override the base add_nodes method to handle n_time_points parameter.</p> <p>When t=None, iterates over range(n_time_points) instead of graph.time_points(). When t is specified, uses the base implementation.</p> Source code in <code>src/tracksdata/nodes/_random.py</code> <pre><code>def add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    t: int | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Override the base add_nodes method to handle n_time_points parameter.\n\n    When t=None, iterates over range(n_time_points) instead of graph.time_points().\n    When t is specified, uses the base implementation.\n    \"\"\"\n    # Register each spatial column individually\n    for col in self.spatial_cols:\n        if col not in graph.node_attr_keys:\n            graph.add_node_attr_key(col, -999999.0)\n\n    if t is None:\n        time_points = range(self.n_time_points)\n    else:\n        time_points = [t]\n\n    _add_nodes_per_time = partial(self._nodes_per_time, **kwargs)\n    for node_attrs in multiprocessing_apply(\n        _add_nodes_per_time,\n        time_points,\n        desc=\"Adding nodes\",\n    ):\n        graph.bulk_add_nodes(node_attrs)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes","title":"RegionPropsNodes","text":"<pre><code>RegionPropsNodes(\n    extra_properties: list[\n        str | Callable[[RegionProperties], Any]\n    ]\n    | None = None,\n    spacing: tuple[float, float] | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseNodesOperator</code></p> <pre><code>\n              flowchart TD\n              tracksdata.nodes.RegionPropsNodes[RegionPropsNodes]\n              tracksdata.nodes._base_nodes.BaseNodesOperator[BaseNodesOperator]\n\n                              tracksdata.nodes._base_nodes.BaseNodesOperator --&gt; tracksdata.nodes.RegionPropsNodes\n                \n\n\n              click tracksdata.nodes.RegionPropsNodes href \"\" \"tracksdata.nodes.RegionPropsNodes\"\n              click tracksdata.nodes._base_nodes.BaseNodesOperator href \"\" \"tracksdata.nodes._base_nodes.BaseNodesOperator\"\n            </code></pre> <p>Operator that adds nodes to a graph using scikit-image's regionprops.</p> <p>Extracts region properties from labeled images to create graph nodes using scikit-image's regionprops function to compute geometric and intensity-based features. Automatically adds centroid coordinates and mask information, with additional properties computed based on the extra_properties parameter.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--parameters","title":"Parameters","text":"<p>extra_properties : list[str | Callable[[RegionProperties], Any]] | None, optional     Additional properties to compute for each region. Can be:     - String names of built-in regionprops properties (e.g., 'area', 'perimeter')     - Callable functions that take a RegionProperties object and return a value     If None, only centroid coordinates and masks are extracted. spacing : tuple[float, float] | None, optional     Physical spacing between pixels. If provided, affects distance-based     measurements. Should be (row_spacing, col_spacing) for 2D or     (depth_spacing, row_spacing, col_spacing) for 3D.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--attributes","title":"Attributes","text":"<p>_extra_properties : list     List of additional properties to compute. _spacing : tuple[float, float] | None     Physical spacing between pixels.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes--examples","title":"Examples","text":"<p>Create a basic RegionPropsNodes operator:</p> <pre><code>from tracksdata.nodes import RegionPropsNodes\n\nnode_op = RegionPropsNodes()\n</code></pre> <p>Add common geometric properties:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\", \"eccentricity\"])\n</code></pre> <p>Add custom properties using functions:</p> <pre><code>def custom_property(region):\n    return region.area / region.perimeter\n\n\nnode_op = RegionPropsNodes(extra_properties=[\"area\", custom_property])\n</code></pre> <p>Use with physical spacing:</p> <pre><code>node_op = RegionPropsNodes(\n    spacing=(0.5, 0.1, 0.1),  # z, y, x spacing\n    extra_properties=[\"area\", \"volume\"],\n)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.random.randint(0, 10, (10, 100, 100))\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Methods:</p> <ul> <li> <code>add_nodes</code>             \u2013              <p>Add nodes to a graph using region properties from labeled images.</p> </li> <li> <code>attr_keys</code>             \u2013              <p>Get the keys of the node attributes that will be extracted.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def __init__(\n    self,\n    extra_properties: list[str | Callable[[RegionProperties], Any]] | None = None,\n    spacing: tuple[float, float] | None = None,\n):\n    super().__init__()\n    self._extra_properties = extra_properties or []\n    if \"centroid\" in self._extra_properties:\n        raise ValueError(\n            \"`centroid` is not supported as an extra property. It's already included by default as (z), y, x.\"\n        )\n    if \"bbox\" in self._extra_properties:\n        raise ValueError(\"`bbox` is not supported as an extra property. It's already included by default.\")\n    self._spacing = spacing\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names","title":"_axis_names","text":"<pre><code>_axis_names(labels: NDArray[integer]) -&gt; list[str]\n</code></pre> <p>Get the names of the axes of the labels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The names of the axes of the labels.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _axis_names(self, labels: NDArray[np.integer]) -&gt; list[str]:\n    \"\"\"\n    Get the names of the axes of the labels.\n\n    Parameters\n    ----------\n    labels : NDArray[np.integer]\n        The (t + nD) labels to get the axis names for.\n\n    Returns\n    -------\n    list[str]\n        The names of the axes of the labels.\n    \"\"\"\n    if labels.ndim == 3:\n        return [\"y\", \"x\"]\n    elif labels.ndim == 4:\n        return [\"z\", \"y\", \"x\"]\n    else:\n        raise ValueError(f\"`labels` must be 't + 2D' or 't + 3D', got '{labels.ndim}' dimensions.\")\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._axis_names(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>The (t + nD) labels to get the axis names for.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._init_node_attrs","title":"_init_node_attrs","text":"<pre><code>_init_node_attrs(\n    graph: BaseGraph, axis_names: list[str], ndims: int\n) -&gt; None\n</code></pre> <p>Initialize the node attributes for the graph.</p> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _init_node_attrs(self, graph: BaseGraph, axis_names: list[str], ndims: int) -&gt; None:\n    \"\"\"\n    Initialize the node attributes for the graph.\n    \"\"\"\n    if DEFAULT_ATTR_KEYS.MASK not in graph.node_attr_keys:\n        graph.add_node_attr_key(DEFAULT_ATTR_KEYS.MASK, None)\n\n    if DEFAULT_ATTR_KEYS.BBOX not in graph.node_attr_keys:\n        graph.add_node_attr_key(DEFAULT_ATTR_KEYS.BBOX, np.zeros(2 * (ndims - 1), dtype=int))\n\n    if \"label\" in self.attr_keys() and \"label\" not in graph.node_attr_keys:\n        graph.add_node_attr_key(\"label\", 0)\n\n    # initialize the remaining attribute keys\n    for attr_key in axis_names + self.attr_keys():\n        if attr_key not in graph.node_attr_keys:\n            graph.add_node_attr_key(attr_key, -1.0)\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time","title":"_nodes_per_time","text":"<pre><code>_nodes_per_time(\n    t: int,\n    *,\n    labels: NDArray[integer],\n    intensity_image: NDArray | None = None,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Add nodes for a specific time point using region properties.</p> <p>Processes a single time point, computing region properties for each labeled region and creating corresponding graph nodes. Determines spatial dimensions from label shape, ensures required attribute keys exist, computes region properties, extracts coordinates and extra properties, creates mask objects, and bulk adds all nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>The nodes to add to the graph.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If labels is not 2D or 3D.</p> </li> </ul> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def _nodes_per_time(\n    self,\n    t: int,\n    *,\n    labels: NDArray[np.integer],\n    intensity_image: NDArray | None = None,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Add nodes for a specific time point using region properties.\n\n    Processes a single time point, computing region properties for each labeled\n    region and creating corresponding graph nodes. Determines spatial dimensions\n    from label shape, ensures required attribute keys exist, computes region\n    properties, extracts coordinates and extra properties, creates mask objects,\n    and bulk adds all nodes.\n\n    Parameters\n    ----------\n    t : int\n        The time point to assign to the created nodes.\n    labels : NDArray[np.integer]\n        2D or 3D labeled image for a single time point.\n    intensity_image : NDArray | None, optional\n        Corresponding intensity image for computing intensity-based properties.\n\n    Returns\n    -------\n    list[dict[str, Any]]\n        The nodes to add to the graph.\n\n    Raises\n    ------\n    ValueError\n        If labels is not 2D or 3D.\n    \"\"\"\n    axis_names = self._axis_names(labels)\n\n    labels = np.asarray(labels[t])\n\n    if intensity_image is not None:\n        intensity_image = np.asarray(intensity_image[t])\n\n    nodes_data = []\n\n    for obj in regionprops(\n        labels,\n        intensity_image=intensity_image,\n        spacing=self._spacing,\n        cache=True,\n    ):\n        attrs = dict(zip(axis_names, obj.centroid, strict=False))\n\n        for prop in self._extra_properties:\n            if callable(prop):\n                attrs[prop.__name__] = prop(obj)\n            else:\n                attrs[prop] = getattr(obj, prop)\n\n        attrs[DEFAULT_ATTR_KEYS.MASK] = Mask(obj.image, obj.bbox)\n        attrs[DEFAULT_ATTR_KEYS.BBOX] = np.asarray(obj.bbox, dtype=int)\n        attrs[DEFAULT_ATTR_KEYS.T] = t\n\n        nodes_data.append(attrs)\n        obj._cache.clear()  # clearing to reduce memory footprint\n\n    if len(nodes_data) == 0:\n        LOG.warning(\"No valid nodes found for time point %d\", t)\n\n    return nodes_data\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(t)","title":"<code>t</code>","text":"(<code>int</code>)           \u2013            <p>The time point to assign to the created nodes.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>2D or 3D labeled image for a single time point.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes._nodes_per_time(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Corresponding intensity image for computing intensity-based properties.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes","title":"add_nodes","text":"<pre><code>add_nodes(\n    graph: BaseGraph,\n    *,\n    labels: NDArray[integer],\n    t: int | None = None,\n    intensity_image: NDArray | None = None,\n) -&gt; None\n</code></pre> <p>Add nodes to a graph using region properties from labeled images.</p> <p>Extracts region properties from labeled images and creates corresponding nodes in the graph. Can handle both single time point and time series data. When t is None, the first axis of labels represents time and processes each time point sequentially. Automatically initializes required attribute keys in the graph schema before adding nodes.</p> <p>Parameters:</p> <p>Examples:</p> <p>Add nodes from a single 2D labeled image:</p> <pre><code>labels = skimage.measure.label(binary_image)\nnode_op.add_nodes(graph, labels=labels, t=0)\n</code></pre> <p>Add nodes from a time series:</p> <pre><code>labels_series = np.stack(\n    [\n        skimage.measure.label(binary_image_t0),\n        skimage.measure.label(binary_image_t1),\n    ]\n)\nnode_op.add_nodes(graph, labels=labels_series)\n</code></pre> <p>Add nodes with intensity information:</p> <pre><code>node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>@override\ndef add_nodes(\n    self,\n    graph: BaseGraph,\n    *,\n    labels: NDArray[np.integer],\n    t: int | None = None,\n    intensity_image: NDArray | None = None,\n) -&gt; None:\n    \"\"\"\n    Add nodes to a graph using region properties from labeled images.\n\n    Extracts region properties from labeled images and creates corresponding\n    nodes in the graph. Can handle both single time point and time series data.\n    When t is None, the first axis of labels represents time and processes each\n    time point sequentially. Automatically initializes required attribute keys\n    in the graph schema before adding nodes.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph to add nodes to.\n    labels : NDArray[np.integer]\n        Labeled image(s) where each unique positive integer represents\n        a different region/object. Can be:\n        - 3D array (time, height, width) for 2D time series\n        - 4D array (time, depth, height, width) for 3D time series\n        When `t` is provided, it should be padded to include the time dimension.\n    t : int | None, optional\n        Time point for the nodes. If None, labels are treated as a time\n        series where the first axis represents time.\n    intensity_image : NDArray | None, optional\n        Intensity image(s) corresponding to the labels. Used for computing\n        intensity-based properties. Must have the same shape as labels\n        (excluding the label values).\n\n    Examples\n    --------\n    Add nodes from a single 2D labeled image:\n\n    ```python\n    labels = skimage.measure.label(binary_image)\n    node_op.add_nodes(graph, labels=labels, t=0)\n    ```\n\n    Add nodes from a time series:\n\n    ```python\n    labels_series = np.stack(\n        [\n            skimage.measure.label(binary_image_t0),\n            skimage.measure.label(binary_image_t1),\n        ]\n    )\n    node_op.add_nodes(graph, labels=labels_series)\n    ```\n\n    Add nodes with intensity information:\n\n    ```python\n    node_op.add_nodes(graph, labels=labels, t=0, intensity_image=fluorescence_image)\n    ```\n    \"\"\"\n    axis_names = self._axis_names(labels)\n    self._init_node_attrs(graph, axis_names, ndims=labels.ndim)\n\n    if \"shape\" not in graph.metadata:\n        graph.update_metadata(shape=labels.shape)\n\n    if t is None:\n        time_points = range(labels.shape[0])\n    else:\n        time_points = [t]\n\n    node_ids = []\n    for nodes_data in multiprocessing_apply(\n        func=partial(self._nodes_per_time, labels=labels, intensity_image=intensity_image),\n        sequence=time_points,\n        desc=\"Adding region properties nodes\",\n    ):\n        node_ids.extend(graph.bulk_add_nodes(nodes_data))\n</code></pre>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph to add nodes to.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(labels)","title":"<code>labels</code>","text":"(<code>NDArray[integer]</code>)           \u2013            <p>Labeled image(s) where each unique positive integer represents a different region/object. Can be: - 3D array (time, height, width) for 2D time series - 4D array (time, depth, height, width) for 3D time series When <code>t</code> is provided, it should be padded to include the time dimension.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(t)","title":"<code>t</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Time point for the nodes. If None, labels are treated as a time series where the first axis represents time.</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.add_nodes(intensity_image)","title":"<code>intensity_image</code>","text":"(<code>NDArray | None</code>, default:                   <code>None</code> )           \u2013            <p>Intensity image(s) corresponding to the labels. Used for computing intensity-based properties. Must have the same shape as labels (excluding the label values).</p>"},{"location":"reference/tracksdata/nodes/#tracksdata.nodes.RegionPropsNodes.attr_keys","title":"attr_keys","text":"<pre><code>attr_keys() -&gt; list[str]\n</code></pre> <p>Get the keys of the node attributes that will be extracted.</p> <p>Returns only the keys for extra_properties. The centroid coordinates (x, y, z) and mask are always included but not listed here.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of attribute key names that will be added to nodes.</p> </li> </ul> <p>Examples:</p> <pre><code>node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\nkeys = node_op.attr_keys()\nprint(keys)  # ['area', 'perimeter']\n</code></pre> Source code in <code>src/tracksdata/nodes/_regionprops.py</code> <pre><code>def attr_keys(self) -&gt; list[str]:\n    \"\"\"\n    Get the keys of the node attributes that will be extracted.\n\n    Returns only the keys for extra_properties. The centroid coordinates\n    (x, y, z) and mask are always included but not listed here.\n\n    Returns\n    -------\n    list[str]\n        List of attribute key names that will be added to nodes.\n\n    Examples\n    --------\n    ```python\n    node_op = RegionPropsNodes(extra_properties=[\"area\", \"perimeter\"])\n    keys = node_op.attr_keys()\n    print(keys)  # ['area', 'perimeter']\n    ```\n    \"\"\"\n    return [prop.__name__ if callable(prop) else prop for prop in self._extra_properties]\n</code></pre>"},{"location":"reference/tracksdata/options/","title":"options","text":""},{"location":"reference/tracksdata/options/#tracksdata.options","title":"tracksdata.options","text":"<p>Global options system for TracksData.</p> <p>Classes:</p> <ul> <li> <code>Options</code>           \u2013            <p>Global options for TracksData.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_options</code>             \u2013              <p>Get the current global options.</p> </li> <li> <code>options_context</code>             \u2013              <p>Context manager for temporarily modifying options.</p> </li> <li> <code>set_options</code>             \u2013              <p>Set the global options pushing a new Options object to the stack.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options","title":"Options  <code>dataclass</code>","text":"<pre><code>Options(\n    show_progress: bool = True,\n    n_workers: int = 1,\n    gav_chunk_shape: tuple[int, ...] | int = 512,\n    gav_default_dtype: dtype | str = np.uint64,\n    gav_buffer_cache_size: int = 4,\n)\n</code></pre> <p>Global options for TracksData.</p> <p>This class provides a centralized way to control various behaviors across the library, such as progress display and multiprocessing.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options--parameters","title":"Parameters","text":"<p>show_progress : bool, default True     Whether to display progress bars during operations. n_workers : int     Number of worker processes to use for multiprocessing operations.     - 0 or 1: use default behavior (sequential)     - &gt; 1: use exactly this many worker processes     NOTE: Overhead of multiprocessing is significant, experiment with 1 before increasing. gav_chunk_size : tuple[int, ...] | int     Spatial chunk size for displaying data as GraphArrayView. If the length     is less than the number of dimensions, the remaining dimensions will be     filled with 1 from the left.     If an int is provided, it will be used for all dimensions. gav_default_dtype : np.dtype     Default dtype for GraphArrayView. gav_buffer_size : int     Number of chunks to buffer for GraphArrayView.</p> <p>Methods:</p> <ul> <li> <code>__enter__</code>             \u2013              <p>Enter the context manager.</p> </li> <li> <code>__exit__</code>             \u2013              <p>Exit the context manager.</p> </li> <li> <code>copy</code>             \u2013              <p>Return a copy of the options.</p> </li> <li> <code>update</code>             \u2013              <p>Update the options with the given keyword arguments.</p> </li> </ul>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Options\n</code></pre> <p>Enter the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __enter__(self) -&gt; \"Options\":\n    \"\"\"Enter the context manager.\"\"\"\n    # Push current options to stack\n    _options_stack.append(self)\n    return self\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None\n</code></pre> <p>Exit the context manager.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -&gt; None:\n    \"\"\"Exit the context manager.\"\"\"\n    # Pop this options from stack\n    if _options_stack:\n        _options_stack.pop()\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.copy","title":"copy","text":"<pre><code>copy() -&gt; Options\n</code></pre> <p>Return a copy of the options.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def copy(self) -&gt; \"Options\":\n    \"\"\"Return a copy of the options.\"\"\"\n    return Options(**self.__dict__)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.Options.update","title":"update","text":"<pre><code>update(**kwargs: Any) -&gt; None\n</code></pre> <p>Update the options with the given keyword arguments.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>def update(self, **kwargs: Any) -&gt; None:\n    \"\"\"Update the options with the given keyword arguments.\"\"\"\n    valid_keys = set(self.__dict__.keys())\n    for key, value in kwargs.items():\n        if key not in valid_keys:\n            raise ValueError(f\"Invalid option: {key}. Expected one of {valid_keys}\")\n        setattr(self, key, value)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.get_options","title":"get_options","text":"<pre><code>get_options() -&gt; Options\n</code></pre> <p>Get the current global options.</p> <p>Returns:</p> <ul> <li> <code>Options</code>           \u2013            <p>The current global options instance.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def get_options() -&gt; Options:\n    \"\"\"\n    Get the current global options.\n\n    Returns\n    -------\n    Options\n        The current global options instance.\n    \"\"\"\n    # Return the top of the stack, or default if stack is empty\n    return _options_stack[-1] if _options_stack else _default_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context","title":"options_context","text":"<pre><code>options_context(\n    **kwargs: Any,\n) -&gt; Generator[Options, None, None]\n</code></pre> <p>Context manager for temporarily modifying options.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Options</code>           \u2013            <p>The options object with the temporary settings.</p> </li> </ul> <p>Examples:</p> <pre><code>from tracksdata.options import options_context\n\nwith options_context(show_progress=False):\n    # Operations here will not show progress\n    pass\n</code></pre> See Also <p>Options:     The global options class.</p> Source code in <code>src/tracksdata/options.py</code> <pre><code>@contextmanager\ndef options_context(**kwargs: Any) -&gt; Generator[Options, None, None]:\n    \"\"\"\n    Context manager for temporarily modifying options.\n\n    Parameters\n    ----------\n    **kwargs : Any\n        Options parameters to temporarily set.\n\n    Yields\n    ------\n    Options\n        The options object with the temporary settings.\n\n    Examples\n    --------\n    ```python\n    from tracksdata.options import options_context\n\n    with options_context(show_progress=False):\n        # Operations here will not show progress\n        pass\n    ```\n\n    See Also\n    --------\n    [Options][tracksdata.options.Options]:\n        The global options class.\n\n    \"\"\"\n    temp_options = Options(**kwargs)\n    with temp_options:\n        yield temp_options\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.options_context(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Options parameters to temporarily set.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options","title":"set_options","text":"<pre><code>set_options(\n    options: Options | None = None, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Set the global options pushing a new Options object to the stack.</p> <p>Parameters:</p> <p>Examples:</p> <p>Set options using an Options object:</p> <pre><code>&gt;&gt;&gt; from tracksdata.options import Options, set_options\n&gt;&gt;&gt; set_options(Options(show_progress=False))\n</code></pre> <p>Set options using keyword arguments:</p> <pre><code>&gt;&gt;&gt; set_options(show_progress=False)\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both options and kwargs are provided, or if neither are provided.</p> </li> </ul> Source code in <code>src/tracksdata/options.py</code> <pre><code>def set_options(options: Options | None = None, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Set the global options pushing a new Options object to the stack.\n\n    Parameters\n    ----------\n    options : Options | None, optional\n        The options object to set as global. If None, kwargs will be used to create a new Options object.\n    **kwargs : Any\n        Individual option parameters to set. Only used if options is None.\n\n    Examples\n    --------\n    Set options using an Options object:\n\n    &gt;&gt;&gt; from tracksdata.options import Options, set_options\n    &gt;&gt;&gt; set_options(Options(show_progress=False))\n\n    Set options using keyword arguments:\n\n    &gt;&gt;&gt; set_options(show_progress=False)\n\n    Raises\n    ------\n    ValueError\n        If both options and kwargs are provided, or if neither are provided.\n    \"\"\"\n    if options is not None and kwargs:\n        raise ValueError(\"Cannot provide both 'options' and keyword arguments\")\n\n    if options is None and not kwargs:\n        raise ValueError(\"Must provide either 'options' or keyword arguments\")\n\n    if options is None:\n        options = get_options().copy()\n        options.update(**kwargs)\n\n    _options_stack.append(options)\n</code></pre>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(options)","title":"<code>options</code>","text":"(<code>Options | None</code>, default:                   <code>None</code> )           \u2013            <p>The options object to set as global. If None, kwargs will be used to create a new Options object.</p>"},{"location":"reference/tracksdata/options/#tracksdata.options.set_options(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Individual option parameters to set. Only used if options is None.</p>"},{"location":"reference/tracksdata/solvers/","title":"solvers","text":""},{"location":"reference/tracksdata/solvers/#tracksdata.solvers","title":"tracksdata.solvers","text":"<p>Solvers for finding a valid tracking solution from a candidate graph.</p> <p>Classes:</p> <ul> <li> <code>ILPSolver</code>           \u2013            <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> </li> <li> <code>NearestNeighborsSolver</code>           \u2013            <p>Solver for tracking problems using nearest neighbor edge selection.</p> </li> </ul>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver","title":"ILPSolver","text":"<pre><code>ILPSolver(\n    *,\n    edge_weight: str\n    | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    node_weight: str | ExprInput = 0.0,\n    appearance_weight: str | ExprInput = 0.0,\n    disappearance_weight: str | ExprInput = 0.0,\n    division_weight: str | ExprInput = 0.0,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    num_threads: int = 1,\n    reset: bool = True,\n    return_solution: bool = True,\n    gap: float = 0.0,\n    timeout: float | None = None,\n)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <pre><code>\n              flowchart TD\n              tracksdata.solvers.ILPSolver[ILPSolver]\n              tracksdata.solvers._base_solver.BaseSolver[BaseSolver]\n\n                              tracksdata.solvers._base_solver.BaseSolver --&gt; tracksdata.solvers.ILPSolver\n                \n\n\n              click tracksdata.solvers.ILPSolver href \"\" \"tracksdata.solvers.ILPSolver\"\n              click tracksdata.solvers._base_solver.BaseSolver href \"\" \"tracksdata.solvers._base_solver.BaseSolver\"\n            </code></pre> <p>Optimal tracking solver using Integer Linear Programming (ILP).</p> <p>ILPSolver formulates the multi-object tracking problem as an Integer Linear Programming optimization problem. It finds globally optimal solutions by minimizing a cost function while satisfying flow conservation constraints. The solver supports appearance, disappearance, and division events, making it suitable for complex biological tracking scenarios.</p> <p>The optimization problem includes:</p> <ul> <li>Node selection variables (whether a detection is part of a track)</li> <li>Edge selection variables (connections between detections)</li> <li>Appearance variables (track starts)</li> <li>Disappearance variables (track ends)</li> <li>Division variables (cell divisions or track splits)</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edge_weight_expr</code>               (<code>EdgeAttr</code>)           \u2013            <p>Compiled edge weight expression.</p> </li> <li> <code>node_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled node weight expression.</p> </li> <li> <code>appearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled appearance weight expression.</p> </li> <li> <code>disappearance_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled disappearance weight expression.</p> </li> <li> <code>division_weight_expr</code>               (<code>NodeAttr</code>)           \u2013            <p>Compiled division weight expression.</p> </li> </ul> See Also <p>NearestNeighborsSolver:     Greedy nearest neighbors tracking solver.</p> <p>NodeAttr:     For creating node attribute expressions.</p> <p>EdgeAttr:     For creating edge attribute expressions.</p> <p>Examples:</p> <p>Basic tracking with distance-based costs:</p> <pre><code>from tracksdata.solvers import ILPSolver\n\nsolver = ILPSolver(edge_weight=\"distance\")\nsolution = solver.solve(graph)\n</code></pre> <p>Tracking with appearance and disappearance costs:</p> <pre><code>solver = ILPSolver(edge_weight=\"distance\", appearance_weight=10.0, disappearance_weight=10.0)\nsolution = solver.solve(graph)\n</code></pre> <p>Using attribute expressions for complex costs:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = ILPSolver(edge_weight=EdgeAttr(\"distance\") + 0.1 * EdgeAttr(\"angle_change\"), division_weight=5.0)\nsolution = solver.solve(graph)\n</code></pre> Notes <p>The solver uses the ilpy library which provides interfaces to commercial solvers (Gurobi) and open-source solvers (SCIP). For best performance, install Gurobi if available, otherwise SCIP will be used as fallback.</p> <p>The ILP formulation ensures:</p> <ul> <li>Flow conservation: incoming flow equals outgoing flow for each node</li> <li>Track consistency: each detection belongs to at most one track</li> <li>Optimal solution: globally minimizes the total cost function</li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def __init__(\n    self,\n    *,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    node_weight: str | ExprInput = 0.0,\n    appearance_weight: str | ExprInput = 0.0,\n    disappearance_weight: str | ExprInput = 0.0,\n    division_weight: str | ExprInput = 0.0,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    num_threads: int = 1,\n    reset: bool = True,\n    return_solution: bool = True,\n    gap: float = 0.0,\n    timeout: float | None = None,\n):\n    super().__init__(output_key=output_key, reset=reset, return_solution=return_solution)\n    self.edge_weight_expr = EdgeAttr(edge_weight)\n    self.node_weight_expr = NodeAttr(node_weight)\n    self.appearance_weight_expr = NodeAttr(appearance_weight)\n    self.disappearance_weight_expr = NodeAttr(disappearance_weight)\n    self.division_weight_expr = NodeAttr(division_weight)\n    self.num_threads = num_threads\n    self.gap = gap\n    self.timeout = timeout\n    self.reset_model()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(edge_weight)","title":"<code>edge_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>DEFAULT_ATTR_KEYS.EDGE_WEIGHT</code> )           \u2013            <p>Edge attribute or expression to use as edge costs in the optimization. Lower values indicate preferred connections.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(node_weight)","title":"<code>node_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Node attribute or expression to use as node costs.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(appearance_weight)","title":"<code>appearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track appearances (new tracks starting).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(disappearance_weight)","title":"<code>disappearance_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track disappearances (tracks ending).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(division_weight)","title":"<code>division_weight</code>","text":"(<code>str | ExprInput</code>, default:                   <code>0.0</code> )           \u2013            <p>Cost for track divisions (one track splitting into two).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(output_key)","title":"<code>output_key</code>","text":"(<code>str</code>, default:                   <code>DEFAULT_ATTR_KEYS.SOLUTION</code> )           \u2013            <p>Attribute key to store the solution (True/False for selected items).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(num_threads)","title":"<code>num_threads</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of threads to use for solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(reset)","title":"<code>reset</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to reset previous solutions before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(return_solution)","title":"<code>return_solution</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return a subgraph containing only the solution.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(gap)","title":"<code>gap</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Optimality gap tolerance (0.0 for exact solutions).</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver(timeout)","title":"<code>timeout</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Time limit for solving in seconds. If None, no timeout is set.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr","title":"_evaluate_inf_expr","text":"<pre><code>_evaluate_inf_expr(\n    inf_expr: list[Attr], df: DataFrame, node_key: str\n) -&gt; list[int]\n</code></pre> <p>Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>The node ids that satisfy the expressions.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_ilp_solver.py</code> <pre><code>def _evaluate_inf_expr(\n    self,\n    inf_expr: list[Attr],\n    df: pl.DataFrame,\n    node_key: str,\n) -&gt; list[int]:\n    \"\"\"\n    Evaluate a list of infinity expressions and return the node ids that satisfy the expressions.\n\n    Parameters\n    ----------\n    inf_expr : list[AttrExpr]\n        The list of infinity expressions to evaluate.\n    df : pl.DataFrame\n        The dataframe to evaluate the expressions on.\n    node_key : str\n        The key of the node column to filter on.\n\n    Returns\n    -------\n    list[int]\n        The node ids that satisfy the expressions.\n    \"\"\"\n    if len(inf_expr) == 0:\n        return []\n    mask = False\n    for expr in inf_expr:\n        mask = mask | expr.evaluate(df)\n    return df.select(node_key).filter(mask).to_series().to_list()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(inf_expr)","title":"<code>inf_expr</code>","text":"(<code>list[AttrExpr]</code>)           \u2013            <p>The list of infinity expressions to evaluate.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(df)","title":"<code>df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>The dataframe to evaluate the expressions on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.ILPSolver._evaluate_inf_expr(node_key)","title":"<code>node_key</code>","text":"(<code>str</code>)           \u2013            <p>The key of the node column to filter on.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver","title":"NearestNeighborsSolver","text":"<pre><code>NearestNeighborsSolver(\n    max_children: int = 2,\n    edge_weight: str\n    | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    reset: bool = True,\n    return_solution: bool = True,\n)\n</code></pre> <p>               Bases: <code>BaseSolver</code></p> <pre><code>\n              flowchart TD\n              tracksdata.solvers.NearestNeighborsSolver[NearestNeighborsSolver]\n              tracksdata.solvers._base_solver.BaseSolver[BaseSolver]\n\n                              tracksdata.solvers._base_solver.BaseSolver --&gt; tracksdata.solvers.NearestNeighborsSolver\n                \n\n\n              click tracksdata.solvers.NearestNeighborsSolver href \"\" \"tracksdata.solvers.NearestNeighborsSolver\"\n              click tracksdata.solvers._base_solver.BaseSolver href \"\" \"tracksdata.solvers._base_solver.BaseSolver\"\n            </code></pre> <p>Solver for tracking problems using nearest neighbor edge selection.</p> <p>Implements a greedy nearest neighbor approach to solve tracking problems by selecting the best edges while enforcing constraints on parent-child relationships. Works by sorting all edges by weight, greedily selecting edges starting from the best weights, and enforcing constraints (each node can have at most one parent and max_children children). Runs in O(n log n) time due to sorting, where n is the number of edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--parameters","title":"Parameters","text":"<p>max_children : int, default 2     Maximum number of children (successors) each node can have.     This constrains cell division events in biological tracking. edge_weight : str | AttrExpr, default DEFAULT_ATTR_KEYS.EDGE_WEIGHT     Edge attribute key or expression to use as edge weights for sorting.     Lower weights are preferred (treated as better matches).     Can be a string key or AttrExpr for complex expressions. output_key : str, default DEFAULT_ATTR_KEYS.SOLUTION     Attribute key to store the solution boolean values in nodes and edges.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--attributes","title":"Attributes","text":"<p>max_children : int     Maximum number of children per node. solution_key : str     Key used to store solution results. edge_weight_expr : AttrExpr     Expression used to compute edge weights. output_key : str     The key to store the solution in the graph. reset : bool     Whether to reset the solution values in the whole graph before solving.</p>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver--examples","title":"Examples","text":"<p>Basic usage with default settings:</p> <pre><code>from tracksdata.solvers import NearestNeighborsSolver\n\nsolver = NearestNeighborsSolver()\nsolver.solve(graph)\n</code></pre> <p>Customize maximum children for cell division tracking:</p> <pre><code>solver = NearestNeighborsSolver(max_children=3)\nsolver.solve(graph)\n</code></pre> <p>Use custom edge weight expression:</p> <pre><code>from tracksdata.attrs import EdgeAttr\n\nsolver = NearestNeighborsSolver(\n    edge_weight=-EdgeAttr(\"iou\"),  # Higher IoU is better\n    max_children=2,\n)\n</code></pre> <p>Combine multiple edge attributes:</p> <pre><code>weight_expr = EdgeAttr(\"distance\") + 0.5 * EdgeAttr(\"color_diff\")\nsolver = NearestNeighborsSolver(edge_weight=weight_expr)\n</code></pre> <p>Methods:</p> <ul> <li> <code>solve</code>             \u2013              <p>Solve the tracking problem using nearest neighbor edge selection.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def __init__(\n    self,\n    max_children: int = 2,\n    edge_weight: str | ExprInput = DEFAULT_ATTR_KEYS.EDGE_DIST,\n    output_key: str = DEFAULT_ATTR_KEYS.SOLUTION,\n    reset: bool = True,\n    return_solution: bool = True,\n):\n    super().__init__(\n        output_key=output_key,\n        reset=reset,\n        return_solution=return_solution,\n    )\n    self.max_children = max_children\n    self.edge_weight_expr = Attr(edge_weight)\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve","title":"solve","text":"<pre><code>solve(graph: BaseGraph) -&gt; GraphView | None\n</code></pre> <p>Solve the tracking problem using nearest neighbor edge selection.</p> <p>Applies the nearest neighbor algorithm to find the optimal set of edges that form valid tracking paths while respecting parent-child relationship constraints. Automatically extends the graph schema to include the solution key if it doesn't already exist.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>solver = NearestNeighborsSolver(max_children=2)\nsolver.solve(graph)\n</code></pre> <p>Access solution edges:</p> <pre><code>solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n</code></pre> <p>Returns:</p> <ul> <li> <code>GraphView | None</code>           \u2013            <p>The graph view of the solution if <code>return_solution</code> is True, otherwise None.</p> </li> </ul> Source code in <code>src/tracksdata/solvers/_nearest_neighbors_solver.py</code> <pre><code>def solve(\n    self,\n    graph: BaseGraph,\n) -&gt; GraphView | None:\n    \"\"\"\n    Solve the tracking problem using nearest neighbor edge selection.\n\n    Applies the nearest neighbor algorithm to find the optimal set of edges\n    that form valid tracking paths while respecting parent-child relationship\n    constraints. Automatically extends the graph schema to include the solution\n    key if it doesn't already exist.\n\n    Parameters\n    ----------\n    graph : BaseGraph\n        The graph containing nodes and edges to solve. The graph will be\n        modified in-place to add solution attributes to nodes and edges.\n\n    Examples\n    --------\n    ```python\n    solver = NearestNeighborsSolver(max_children=2)\n    solver.solve(graph)\n    ```\n\n    Access solution edges:\n\n    ```python\n    solution_edges = graph.edge_attrs().filter(pl.col(\"solution\") == True)\n    ```\n\n    Returns\n    -------\n    GraphView | None\n        The graph view of the solution if `return_solution` is True, otherwise None.\n    \"\"\"\n    # get edges and sort them by weight\n    edges_df = graph.edge_attrs(attr_keys=self.edge_weight_expr.columns)\n\n    if len(edges_df) == 0:\n        raise ValueError(\"No edges found in the graph, there is nothing to solve.\")\n\n    weights = self.edge_weight_expr.evaluate(edges_df).to_numpy()\n    sorted_indices = np.argsort(weights)\n\n    sorted_source = edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_target = edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy()[sorted_indices].astype(np.int64)\n    sorted_solution = np.zeros(len(sorted_source), dtype=bool)\n\n    if graph.has_overlaps():\n        overlapping_sets = _build_constraint_dict(\n            np.asarray(graph.overlaps(), dtype=np.int64),\n        )\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n            overlapping_sets,\n        )\n    else:\n        _constrained_nearest_neighbors(\n            sorted_source,\n            sorted_target,\n            sorted_solution,\n            self.max_children,\n        )\n    del sorted_source, sorted_target\n\n    inverted_indices = np.empty_like(sorted_indices)\n    inverted_indices[sorted_indices] = np.arange(len(sorted_indices))\n    solution = sorted_solution[inverted_indices]\n    del sorted_solution, inverted_indices, sorted_indices\n\n    solution_edges_df = edges_df.filter(solution)\n\n    if self.output_key not in graph.edge_attr_keys:\n        graph.add_edge_attr_key(self.output_key, False)\n    elif self.reset:\n        graph.update_edge_attrs(attrs={self.output_key: False})\n\n    graph.update_edge_attrs(\n        edge_ids=solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_ID].to_numpy(),\n        attrs={self.output_key: True},\n    )\n\n    node_ids = np.unique(\n        np.concatenate(\n            [\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_SOURCE].to_numpy(),\n                solution_edges_df[DEFAULT_ATTR_KEYS.EDGE_TARGET].to_numpy(),\n            ]\n        )\n    )\n\n    if self.output_key not in graph.node_attr_keys:\n        graph.add_node_attr_key(self.output_key, False)\n\n    graph.update_node_attrs(\n        node_ids=node_ids,\n        attrs={self.output_key: True},\n    )\n\n    if self.return_solution:\n        return graph.filter(\n            NodeAttr(self.output_key) == True,\n            EdgeAttr(self.output_key) == True,\n        ).subgraph()\n</code></pre>"},{"location":"reference/tracksdata/solvers/#tracksdata.solvers.NearestNeighborsSolver.solve(graph)","title":"<code>graph</code>","text":"(<code>BaseGraph</code>)           \u2013            <p>The graph containing nodes and edges to solve. The graph will be modified in-place to add solution attributes to nodes and edges.</p>"},{"location":"reference/tracksdata/utils/","title":"utils","text":""},{"location":"reference/tracksdata/utils/#tracksdata.utils","title":"tracksdata.utils","text":"<p>Utility functions for data processing, type conversions, and progress tracking.</p>"}]}